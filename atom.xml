<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[(learn&think)]]></title>
  <link href="http://dreamrunner.org/atom.xml" rel="self"/>
  <link href="http://dreamrunner.org/"/>
  <updated>2014-06-22T20:29:37+08:00</updated>
  <id>http://dreamrunner.org/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Double-Checked Locking Works in C++11]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/22/double-checked-locking-works-in-c-plus-plus-11/"/>
    <updated>2014-06-22T14:07:01+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/22/double-checked-locking-works-in-c-plus-plus-11</id>
    <content type="html"><![CDATA[<p>在
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">浅谈设计模式六: 单例模式(Singleton)</a>
中提到double-checked locking pattern(DCLP)来实现Singleton设计模式，但是
在C++11之前，没有安全方法在可移植的C++中去实现它．具体原因可见
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
或Scott Meyers和Andrei Alexandrescu发布的原文
<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">“C++ and the Perils of Double-Checked Locking”</a>
．</p>

<p>C++11引入了新的内存模型和线程库，使得能在C++中实现可移植的DCLP．本文说
明如何实现它．</p>

<!-- more -->

<h2 id="double-checked-locking">什么是Double-Checked Locking</h2>
<p>在
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
很好的介绍什么是DCLP,这里稍作回顾.</p>

<p>线程安全的方式实现Signleton模式如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>singleton.cc</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">Lock</span> <span class="n">lock</span><span class="p">;</span>    <span class="c1">// acquire lock (params omitted for simplicity)</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">pInstance</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">pInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>  <span class="c1">// release lock (via Lock destructor)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>每次获取 Singleton 都要获取一个锁，但是实际上，我们只有当初始化 pInstance 时才需要一个锁。也就是只发生在第一次调用 instance 时。如果在一个程序运行时， instance 被调用了n次，我们只需要锁在第一次调用时。当我们知道那n-1次锁是没必要的.</p>

<p>DCLP的关键点是发现，大多数 instance 的调用将看到 pInstance 是非空的，因此根本没必要去尝试初始化它。因此，DCLP判断 pInstance 是否为空在尝试获取锁前。只有当判断成功（ pInstance 还没有被初始化）才去获取锁，然后之后这个判断在此进行一次确保 pInstance 是仍然空的。（所以名字叫双重检查锁）。第二个检查是有必要的，因为从上可以看到，另外的线程可能碰巧初始化了 pInstance 在 pInstance 被第一次判断和获取锁之间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>singleton-dclp.cc</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">Singleton</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line">  <span class="p">...</span>  <span class="c1">// need memory barrier</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 1st test</span>
</span><span class="line">  <span class="n">Lock</span> <span class="n">lock</span><span class="p">;</span>
</span><span class="line">  <span class="n">tmp</span> <span class="o">=</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 2nd test</span>
</span><span class="line">    <span class="n">tmp</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
</span><span class="line">  <span class="p">...</span>  <span class="c1">// need memory barrier</span>
</span><span class="line">    <span class="n">pInstance</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">return</span> <span class="n">pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
说明了各种不安全实现的缺陷,主要原因是1) 编译器的乱序编译 和2) CPU的乱
序执行指令.所以安全的实现依靠memory barrier,防止它们的乱序,使得在多线
程中得到同步,C++11之前没有可移植的C/C++函数,但现在,C++11有了.</p>

<h2 id="c11acqurerelease-fence">使用C++11的Acqure和Release Fence</h2>
<p>使用Acqure和Release Fence来实现它,并且保证对实例<code>pInstance</code>进行原子操
作,把它定义为<code>atomic</code>类型,并用<code>memory_order_relaxed</code>操作.(Relaxed
ordering: there are no synchronization or ordering constraints, only
atomicity is required of this operation.)如下实现代码.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span> <span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_mutex</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">Singleton</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
</span><span class="line">      <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class="line">      <span class="n">m_pInstance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在多核系统中,这整个代码也是稳健的,因为memory fences在多个线程间建立了
同步的关系.<code>Singleton::m_pInstance</code>作为guard variable,singleton变
量自身成为payload.</p>

<p>如果没有这层同步关系的话,就不能保证第一个线程的所有写操作(这里就是
singleton实力的创建)被第二个线程读取到,即使<code>m_pInstance</code>已经被第二个线
程能看到.</p>

<h2 id="c11">使用C++11的底层的内存顺序约束</h2>
<p>在C++11中也可以在单元操作时附加底层的内存顺序约束来达到同样的目的.一个
write-release能同步于一个read-release.</p>

<ol>
  <li>
    <p><code>memory_order_acquire</code>: A load operation with this memory order performs the acquire operation on the affected memory location: prior writes made to other memory locations by the thread that did the release become visible in this thread.</p>
  </li>
  <li>
    <p><code>memory_order_release</code>: A store operation with this memory order performs the release operation: prior writes to other memory locations become visible to the threads that do a consume or an acquire on the same location.</p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span> <span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_mutex</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">Singleton</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
</span><span class="line">      <span class="n">m_pInstance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从深层分析来看,这种形式的免锁机制的同步比上面单独memory fences来的约束
更小.这种形式的操作只意味在这个操作周围防止内存乱序,而memory fences意
味着在一块区域内防止内存乱序.更多细节参考preshing的
<a href="http://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/">Acquire and Release Fences Don’t Work the Way You’d Expect</a>
的分析.
## 使用C++11的Sequentially-consistent ordering
C++11还提供了其他的方法来写lock-free的代码.当在atomic操作函数中忽略
<code>std::memory_order</code>参数项,那么默认值是<code>std::memory_order_seq_cst</code>,使得
所有原子参数成为
<a href="http://en.wikipedia.org/wiki/Sequential_consistency">sequentically consistent(SC)</a>
原子.通过SC原子性,整个算法保证sequentically consistent只要没有<a href="http://www.devx.com/cplus/Article/42725">data races</a>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span> <span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_mutex</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">Singleton</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">m_pInstance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
</span><span class="line">      <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class="line">      <span class="n">m_pInstance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">m_pInstance</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>SC的原子性可能更容易理解.权衡点就是它产生的机器代码没有之前做法的高效.比
如如下是Gcc 4.8.2 intle X64对上面代码产生的机器代码,通过<code>g++ -O2 -std=c++11 -S</code>.
<img src="http://dreamrunner.org/images/blog/2014/multithreading/sc.png" title="sc'" /></p>

<p>因为使用了SC原子性,对<code>m_pInstance</code>的存储实现使用了<code>mfence</code>指令,起到一
个在X64上的full memory fence.这是个更严格的指令想对于DCLP在X64上的实际
需求.一个普通的<code>mov</code>足以胜任.但也无关紧要,因为<code>mfence</code>指令也仅仅执行一
次而已,就在创建singleton的实例的代码路径上.</p>

<h2 id="more">More</h2>
<p>使用<a href="http://preshing.com">Preshing</a>的小型可移植的lock-free库,在没有C++11
的支持下,使用它的<a href="http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/#using-mintomic-fences">Mintomic Fences实现DCLP</a>.</p>

<p>更多关于C++11的multithreading库的详解见之后的文章.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 6]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/15/The-Algorithm-Design-Manual6/"/>
    <updated>2014-06-15T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/15/The-Algorithm-Design-Manual6</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">6.1 Minimum Spanning Trees</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">6.1.1 Prim’s Algorithm</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
A greedy algorithm suffices for correctness: we always add the
lowest-weight edge linking a vertex in the tree to a vertex on the
outside. （选取相邻最近的不在树内的点。）
</p>

<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">prim</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">intree</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is the vertex in the tree yet? */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">distance</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">cost of adding to tree */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">current vertex to process */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">candidate next vertex */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge weight */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dist</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">best current distance from start */</span>
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++) {
    intree[i] = FALSE;
    distance[i] = MAXINT;
    parent[i] = -1;
  }
  distance[start] = 0;
  v = start;
  <span style="color: #00ffff;">while</span> (intree[v] == FALSE) {
    intree[v] = TRUE;
    p = g-&gt;edges[v];
    <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
      w = p-&gt;y;
      weight = p-&gt;weight;
      <span style="color: #00ffff;">if</span> ((distance[w] &gt; weight) &amp;&amp; (intree[w] == FALSE)) {
        distance[w] = weight;
        parent[w] = v;
      }
      p = p-&gt;next;
    }
    v = 1;
    dist = MAXINT;
    <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++)
      <span style="color: #00ffff;">if</span> ((intree[i] == FALSE) &amp;&amp; (dist &gt; distance[i])) {
        dist = distance[i];
        v=i;
      }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">6.1.2 Kruskal’s Algorithm</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
The algorithm repeatedly considers the lightest remaining edge and
tests whether its two endpoints lie within the same connected
component. (最短边）
</p>

<p>
a clever data structure calledunion-find,can support such queries
in O(lgn) time. With this data structure, Kruskal’s algorithm runs in
O(mlgm) time.
</p>

<p>
<b>Implementation</b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">kruskal</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #98fb98;">set_union</span> <span style="color: #eedd82;">s</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">set union data structure */</span>
  <span style="color: #98fb98;">edge_pair</span> <span style="color: #eedd82;">e</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array of edges data structure */</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">weight_compare</span>();
  set_union_init(&amp;s, g-&gt;nvertices);
  to_edge_array(g, e); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">sort edges by increasing cost */</span>
  qsort(&amp;e,g-&gt;nedges,<span style="color: #00ffff;">sizeof</span>(edge_pair),weight_compare);
  <span style="color: #00ffff;">for</span> (i=0; i&lt;(g-&gt;nedges); i++) {
    <span style="color: #00ffff;">if</span> (!same_component(s,e[i].x,e[i].y)) {
      printf(<span style="color: #ffa07a;">"edge (%d,%d) in MST\n"</span>,e[i].x,e[i].y);
      union_sets(&amp;s,e[i].x,e[i].y);
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">6.1.3 The Union-Find Data Structure</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>Find(i)– Find the root of tree containing elementi, by walking up
the parent pointers until there is nowhere to go. Return the label
of the root.
</li>

<li>Union(i,j)– Link the root of one of the trees (say
containingi)to the root of the tree containing the other
(say j) so <code>find(i)</code> now equals <code>find(j)</code>.
</li>
</ul>

<p>
We must double the number of nodes in the tree to get an
extra unit of height. How many doublings can we do before we use up allnnodes?
At most, lg2ndoublings can be performed. Thus, we can do both unions and finds
in O(logn), good enough for Kruskal’s algorithm. In fact, union-find
can be done even faster, as discussed in Section 12.5.
</p>

<p>
<b>Implementation</b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>[SET_SIZE+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent element */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>[SET_SIZE+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of elements in subtree i */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of elements in set */</span>
} <span style="color: #98fb98;">set_union</span>;

<span style="color: #87cefa;">set_union_init</span>(<span style="color: #98fb98;">set_union</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=n; i++) {
    s-&gt;p[i] = i;
    s-&gt;size[i] = 1;
  }
  s-&gt;n = n;
}
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">find</span>(<span style="color: #98fb98;">set_union</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>)
{
  <span style="color: #00ffff;">if</span> (s-&gt;p[x] == x)
    <span style="color: #00ffff;">return</span>(x);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span>( find(s,s-&gt;p[x]) );
}
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">union_sets</span>(<span style="color: #98fb98;">set_union</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s2</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r1</span>, <span style="color: #eedd82;">r2</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">roots of sets */</span>
  r1 = find(s,s1);
  r2 = find(s,s2);
  <span style="color: #00ffff;">if</span> (r1 == r2) <span style="color: #00ffff;">return</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">already in same set */</span>
  <span style="color: #00ffff;">if</span> (s-&gt;size[r1] &gt;= s-&gt;size[r2]) {
    s-&gt;size[r1] = s-&gt;size[r1] + s-&gt;size[r2];
    s-&gt;p[ r2 ] = r1;
  }
  <span style="color: #00ffff;">else</span> {
    s-&gt;size[r2] = s-&gt;size[r1] + s-&gt;size[r2];
    s-&gt;p[ r1 ] = r2;
  }
}
<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">same_component</span>(<span style="color: #98fb98;">set_union</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s2</span>)
{
  <span style="color: #00ffff;">return</span> ( find(s,s1) == find(s,s2) );
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">More MST</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
<a href="http://www.seas.gwu.edu/~simhaweb/champalg/mst/mst.html">http://www.seas.gwu.edu/~simhaweb/champalg/mst/mst.html</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">6.3 Shortest Paths</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">6.3.1 Dijkstra’s Algorithm</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Given a particular start vertexs, it finds the shortest path from s to
every other vertex in the graph, including your desired destination t.
</p>

<p>
<b>Implementation</b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">dijkstra</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>) <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">WAS prim(g,start) */</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">intree</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is the vertex in the tree yet? */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">distance</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">distance vertex is from start */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">current vertex to process */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">w</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">candidate next vertex */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge weight */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dist</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">best current distance from start */</span>
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++) {
    intree[i] = FALSE;
    distance[i] = MAXINT;
    parent[i] = -1;
  }
  distance[start] = 0;
  v = start;
  <span style="color: #00ffff;">while</span> (intree[v] == FALSE) {
    intree[v] = TRUE;
    p = g-&gt;edges[v];
    <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
      w = p-&gt;y;
      weight = p-&gt;weight;
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">CHANGED */</span> <span style="color: #00ffff;">if</span> (distance[w] &gt; (distance[v]+weight)) {
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">CHANGED */</span> distance[w] = distance[v]+weight;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">CHANGED */</span> parent[w] = v;
      }
      p = p-&gt;next;
    }
    v=1;
    dist = MAXINT;
    <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++)
      <span style="color: #00ffff;">if</span> ((intree[i] == FALSE) &amp;&amp; (dist &gt; distance[i])) {
        dist = distance[i];
        v=i;
      }
  }
}
</pre>
</div>
<p>
As implemented here, the complexity is O(n<sup>2</sup>). 
</p>

<p>
Dijkstra works correctly only on graphs without negative-cost edges. The reason
is that midway through the execution we may encounter an edge with weight so
negative that it changes the cheapest way to get froms to some other vertex
already in the tree.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">6.3.2 All-Pairs Shortest Path</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>[MAXV+1][MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">adjacency/weight info */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nvertices</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of vertices in graph */</span>
} <span style="color: #98fb98;">adjacency_matrix</span>;
</pre>
</div>

<p>
The critical issue in an adjacency matrix implementation is how we denote the
edges absent from the graph. A common convention for unweighted graphs denotes
graph edges by 1 and non-edges by 0. This gives exactly the wrong interpretation
if the numbers denote edge weights, for the non-edges get interpreted
as a free ride between vertices. Instead, we should initialize each
non-edge to MAXINT. 
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">floyd</span>(<span style="color: #98fb98;">adjacency_matrix</span> *<span style="color: #eedd82;">g</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>,<span style="color: #eedd82;">j</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">dimension counters */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">intermediate vertex counter */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">through_k</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">distance through vertex k */</span>
  <span style="color: #00ffff;">for</span> (k=1; k&lt;=g-&gt;nvertices; k++)
    <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++)
      <span style="color: #00ffff;">for</span> (j=1; j&lt;=g-&gt;nvertices; j++) {
        through_k = g-&gt;weight[i][k]+g-&gt;weight[k][j];
        <span style="color: #00ffff;">if</span> (through_k &lt; g-&gt;weight[i][j])
          g-&gt;weight[i][j] = through_k;
      }
}
</pre>
</div>

<p>
The Floyd-Warshall all-pairs shortest path runs in O(n<sup>3</sup>) time, which
is asymptotically no better thanncalls to Dijkstra’s algorithm.
However, the loops are so tight and the program so short that it runs
better in practice.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">6.4 War Story: Dialing for Documents</h3>
<div class="outline-text-3" id="text-1-3">
<p>
“We can get good word-use frequencies and grammatical information
from a big text database called the Brown Corpus. It contains
thousands of typical English sentences, each parsed according to parts
of speech. But how do we factor it all in?” Harald asked.
</p>

<p>
Each possible sentence interpretation can be thought of as a path in a
graph. The vertices of this graph are the complete set of possible
word choices. There will be an edge from each possible choice for the
ith word to each possible choice for the (i + 1)st word. The cheapest
path across this graph defines the best interpretation of the
sentence.
</p>

<p>
Perhaps we can count how often that pair of words occurred together in
previous texts. Or we can weigh them by the part of speech of each
word. Maybe nouns don’t like to be next to nouns as much as they like
being next to verbs.
</p>

<p>
We can pay a cost for walking through a particular vertex that depends
upon the frequency of the word. Our best sentence will be given by the
shortest path across the graph.
</p>

<p>
The constraints for many pattern recognition problems can be naturally
formulated as shortest path problems in graphs. In fact, there is a
particularly convenient dynamic programming solution for these
problems (the Viterbi algorithm). Despite the fancy name, the Viterbi
algorithm is basically solving a shortest path problem on a DAG.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">6.5 Network Flows and Bipartite Matching</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The <i>network flow problem</i> asks for the maximum amount of flow which can
be sent from vertices s to t in a given weighted graph G while
respecting the maximum capacities of each pipe.
</p>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">6.5.1 Bipartite Matching</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
The largest bipartite matching can be readily found using network
flow. Create a source nodes that is connected to every vertex in L by
an edge of weight 1. Create a sink node t and connect it to every
vertex in R by an edge of weight 1. Finally, assign each edge in the
bipartite graph G a weight of 1. Now, the maximum possible flow
fromstotdefines the largest matching in G.
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">6.5.2 Computing Network Flows</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
The key structure is the residual flow graph, denoted as R(G, f), where Gis
the input graph andfis the current flow through G. 
</p>

<p>
The maximum flow fromstotalways equals the weight of the minimums-t
cut. Thus, flow algorithms can be used to solve general edge and
vertex connectivity problems in graphs.
</p>

<p>
<b>Implementation</b>
</p>
<div class="org-src-container">

<pre class="src src-c++">        <span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">neighboring vertex */</span>
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">capacity</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">capacity of edge */</span>
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flow</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">flow through edge */</span>
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">residual</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">residual capacity of edge */</span>
          <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">next</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">next edge in list */</span>
        } <span style="color: #98fb98;">edgenode</span>;

      <span style="color: #87cefa;">netflow</span>(<span style="color: #98fb98;">flow_graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">source</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sink</span>)
      {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">volume</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">weight of the augmenting path */</span>
        add_residual_edges(g);
        initialize_search(g);
        bfs(g,source);
        volume = path_volume(g, source, sink, parent);
        <span style="color: #00ffff;">while</span> (volume &gt; 0) {
          augment_path(g,source,sink,parent,volume);
          initialize_search(g);
          bfs(g,source);
          volume = path_volume(g, source, sink, parent);
        }
      }

    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">valid_edge</span>(<span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">e</span>)
    {
      <span style="color: #00ffff;">if</span> (e-&gt;residual &gt; 0) <span style="color: #00ffff;">return</span> (TRUE);
      <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">return</span>(FALSE);
    }

  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">path_volume</span>(<span style="color: #98fb98;">flow_graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">end</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parents</span>[])
  {
    <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">e</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge in question */</span>
    <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">find_edge</span>();
    <span style="color: #00ffff;">if</span> (parents[end] == -1) <span style="color: #00ffff;">return</span>(0);
    e = find_edge(g,parents[end],end);
    <span style="color: #00ffff;">if</span> (start == parents[end])
      <span style="color: #00ffff;">return</span>(e-&gt;residual);
    <span style="color: #00ffff;">else</span>
      <span style="color: #00ffff;">return</span>( min(path_volume(g,start,parents[end],parents),
                  e-&gt;residual) );
  }
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #87cefa;">find_edge</span>(<span style="color: #98fb98;">flow_graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
  {
    <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
    p = g-&gt;edges[x];
    <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
      <span style="color: #00ffff;">if</span> (p-&gt;v == y) <span style="color: #00ffff;">return</span>(p);
      p = p-&gt;next;
    }
    <span style="color: #00ffff;">return</span>(<span style="color: #7fffd4;">NULL</span>);
  }

<span style="color: #87cefa;">augment_path</span>(<span style="color: #98fb98;">flow_graph</span>*<span style="color: #eedd82;">g</span>,intstart,intend,<span style="color: #98fb98;">intparents</span>[],intvolume)
{
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">e</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge in question */</span>
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">find_edge</span>();
  <span style="color: #00ffff;">if</span> (start == end) <span style="color: #00ffff;">return</span>;
  e = find_edge(g,parents[end],end);
  e-&gt;flow += volume;
  e-&gt;residual -= volume;
  e = find_edge(g,end,parents[end]);
  e-&gt;residual += volume;
  augment_path(g,start,parents[end],parents,volume);
}
</pre>
</div>

<p>
Edmonds and Karp [EK72] proved that always selecting ashortest
unweighted augmenting path guarantees that O(n<sup>3</sup>) augmentations
suffice for optimization.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">6.6 Design Graphs, Not Algorithms</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The secret is learning to design graphs, not algorithms. We have
already seen a few instances of this idea:
</p>

<ul class="org-ul">
<li>The maximum spanning tree can be found by negating the edge weights
of the input graph G and using aminimumspanning tree algorithm on
the result. The most negative weight spanning tree will define the
maximum weight tree in G.
</li>
<li>To solve bipartite matching, we constructed a special network flow
graph such that the maximum flow corresponds to a maximum
cardinality matching.
</li>
</ul>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Bucketing Rectangles</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Problem: “In my graphics work I need to solve the following problem.
Given an arbitrary set of rectangles in the plane, how can I
distribute them into a minimum number of buckets such that no subset
of rectangles in any given bucket intersects another? In other words,
there can not be any overlapping area between two rectangles in the same bucket.”
</p>

<p>
Solution: We formulate a graph where each vertex is a rectangle, and
there is an edge if two rectangles intersect. Each bucket corresponds
to anindependent set of rectangles, so there is no overlap between any
two. Avertex coloringof a graph is a partition of the vertices into
independent sets, so minimizing the number of colors is exactly what
you want.
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">Names in Collision</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Problem:“In porting code from UNIX to DOS, I have to shorten several
hundred file names down to at most 8 characters each. I can’t just
use the first eight characters from each name, because “filename1”
and “filename2” would be assigned the exact same name. How can I
meaningfully shorten the names while ensuring that they do not
collide?”
</p>

<p>
Solution: Construct a bipartite graph with vertices corresponding to
each original file namefi for 1≤i≤n, as well as a collection of
acceptable shortenings for each name f<sub>i1</sub>,&#x2026;,f<sub>ik</sub>. Add an edge
between each original and shortened name. We now seek a set of n edges
that have no vertices in common, so each file name is mapped to a
distinct acceptable substitute. Bipartite matching, discussed in
Section 15.6 (page 498), is exactly this problem of finding an
independent set of edges in a graph.
</p>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Separate the Text</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Problem: “We need a way to separate the lines of text in the optical
characterrecognition system that we are building. Although there is
some white space between the lines, problems like noise and the tilt
of the page makes it hard to find. How can we do line segmentation?
</p>

<p>
Solution: Consider the following graph formulation. Treat each pixel
in the image as a vertex in the graph, with an edge between two
neighboring pixels. The weight of this edge should be proportional to
how dark the pixels are. A segmentation between two lines is a path in
this graph from the left to right side of the page. We seek a
relatively straight path that avoids as much blackness as possible.
This suggests that theshortest pathin the pixel graph will likely find
a good line segmentation.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">2-3</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Is the path between two vertices in a minimum spanning tree necessarily a
shortest path between the two vertices in the full graph? Give a proof
or a counterexample.
</p>

<p>
Assume that all edges in the graph have distinct edge weights (i.e. ,
no pair of edges have the same weight). Is the path between a pair of
vertices in a minimum spanning tree necessarily a shortest path
between the two vertices in the full graph? Give a proof or a
counterexample.
</p>

<p>
不必要. 如下图,若a是6的话,minimum spanning tree不会选择a,但A和C间的最短路径会选择a.
</p>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/6_4.jpg" />
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">4</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Can Prim’s and Kruskal’s algorithm yield different minimum spanning
trees? Explain why or why not.
</p>

<p>
能.当有相同weight的边.
</p>

<p>
当所有边的weight不同时,图存在唯一的minimum spanning trees,两者生成同样的树.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">5</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Does either Prim&#8217;s and Kruskal&#8217;s algorithm work if there are negative
edge weights? Explain why or why not. 
</p>

<p>
可以.Prim每次选相邻最近的不在树内的点,有负weight的边并不影响它. 而
Kruskal每次选最短的边,同样不受影响.
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">6</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Suppose we are given the minimum spanning tree T of a given graph G
(with n vertices and m edges) and a new edge e = (u,v) of weight w
that we will add to G. Give an efficient algorithm to find the
minimum spanning tree of the graph G + e. Your algorithm should run
in O(n) time to receive full credit.
</p>

<p>
新添加的e在顶点u和v中间,原本的MST中u和v通过u-&gt;a1-&gt;ai-&gt;v,把此路径的边与
e比较,用Prim算法选最临近点.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">7</h3>
<div class="outline-text-3" id="text-2-5">
<p>
(a) Let T be a minimum spanning tree of a weighted graph G. Construct
a new graph G′ by adding a weight of k to every edge of G. Do the
edges of T form a minimum spanning tree of G′? Prove the statement or
give a counterexample.
</p>

<p>
(b) Let P = {s, &#8230; , t} describe a shortest weighted path between
vertices s and t of a weighted graph G. Construct a new graph G′ by
adding a weight of k to every edge of G. Does P describe a shortest
path from s to t in G′? Prove the statement or give a counterexample.
</p>

<p>
(a)和(b)都对,并没有改变边之间的比较关系.
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">8</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Devise and analyze an algorithm that takes a weighted graph G and
finds the smallest change in the cost to a non-MST edge that would
cause a change in the minimum spanning tree of G. Your algorithm must
be correct and run in polynomial time. 
</p>

<ol class="org-ol">
<li>遍历图的边,掠过MST中的边,当遇到non-MST的边E(i,j).
</li>
<li>利用MST中的parent遍历出顶点i到j的所有MST边,并得到其中最大weight的边
mst<sub>e</sub><sub>max</sub>.
</li>
<li>计算E(i,j)与mst<sub>e</sub><sub>max的差值</sub>.
</li>
<li>遍历所有的non-MST的边,得到最小差值就是改变的最小值.
</li>
</ol>

<p>
总共边数m,算法复杂度O(m<sup>2</sup>).
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">9</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Consider the problem of finding a minimum weight connected subset T of
edges from a weighted connected graph G. The weight of T is the sum of
all the edge weights in T.
</p>

<ol class="org-ol">
<li>Why is this problem not just the minimum spanning tree problem?
Hint: think negative weight edges.
</li>
<li>Give an efficient algorithm to compute the minimum weight connected
subset T. 
</li>
</ol>

<p>
MST不能有环路,minimum weight connected subset T可以有环路,所以如果一条负数weight的边,不在MST中,但却包含在T中,因为它能使T的总权值减小.
</p>

<ol class="org-ol">
<li>把所有负数weight的边加入T中,若剩下1个连通图,结束.
</li>
<li>若剩下C(&gt;1)个连通图,对C个连通图使用Kruskal,直到剩下一个连通图T.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">sort</span>(edges);
c := n;
<span style="color: #00ffff;">for</span> edge<span style="color: #00ffff;"> in</span> edges:
    <span style="color: #00ffff;">if</span> edge.weight &lt; 0:
        <span style="color: #00ffff;">if</span> find(edge.firstEnd) != find(edge.secondEnd):
            --c;
        unite(edge.firstEnd, edge.secondEnd);
    <span style="color: #00ffff;">else</span>:
        <span style="color: #00ffff;">if</span> <span style="color: #eedd82;">c</span> == 1: break;
        <span style="color: #00ffff;">if</span> find(edge.firstEnd) != find(edge.secondEnd):
            unite(edge.firstEnd, edge.secondEnd);
            --c;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">10</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Let G=(V,E) be an undirected graph. A set F⊆E of edges is called a
feedback-edge set if every cycle of G has at least one edge in F.
</p>

<ol class="org-ol">
<li>Suppose that Gis unweighted. Design an efficient algorithm to find
a minimum-size feedback-edge set.
</li>

<li>Suppose that Gis a weighted undirected graph with positive edge
weights. Design an efficient algorithm to find a minimum-weight
feedback-edge set.
</li>

<li><b>Minimum size feedback edge set:</b> 使用DFS,从任意点开始,遇到回归边,
把它加入结果set中,当DFS完成,结果set就是答案.
</li>
<li><b>minimum-weight feedback-edge set:</b> 对所有weight值取反,用Kruskal算法,当遇到边E的顶点在同一个集合中,把E加入到结果set中,当Kruskal遍历完所有边后,结果set就是答案.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">11</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Modify Prim&#8217;s algorithm so that it runs in time O(nlogk) on a
graph that has only k different edges costs. 
</p>

<ul class="org-ul">
<li>k个不同的边值,使用一个k个元素的min-heap,heap的节点是相同距离的顶点链表.
</li>
<li>Prim每次选择和更新顶点的距离在min-heap完成,做到O(nlogk).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">12</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Devise an efficient data structure to handle the following operations
on a weighted directed graph:
</p>

<ol class="org-ol">
<li>Merge two given components.
</li>
<li>Locate which component contains a given vertex v.
</li>
<li>Retrieve a minimum edge from a given component. 
</li>
</ol>

<p>
使用Union-Find并添加minimum edge.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>[SET_SIZE+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent element */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>[SET_SIZE+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of elements in subtree i */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">minedge</span>[SET_SIZE+1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of elements in set */</span>
} <span style="color: #98fb98;">set_union</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">14</h3>
<div class="outline-text-3" id="text-2-11">
<p>
The single-destination shortest path problem for a directed graph
seeks the shortest path from every vertex to a specified vertex v. Give
an efficient algorithm to solve the single-destination shortest paths
problem.
</p>

<p>
用Floyd-Warshall对于顶点v反向更新距离值.得到最终shortest paths.
</p>
</div>
</div>

<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">19</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Let G be a weighted directed graph with n vertices and m edges, where
all edges have positive weight. A directed cycle is a directed path
that starts and ends at the same vertex and contains at least one
edge. Give an O(n<sup>3</sup>) algorithm to find a directed cycle in G of minimum
total weight. Partial credit will be given for an O(n<sup>2</sup>m) algorithm. 
</p>

<div class="org-src-container">

<pre class="src src-c++">run Floyd Warshall on the <span style="color: #98fb98;">graph</span>
<span style="color: #eedd82;">min</span> &lt;- MAX_INT
vertex &lt;- None
<span style="color: #00ffff;">for</span> each pair of vertices u,<span style="color: #87cefa;">v</span>
    <span style="color: #00ffff;">if</span> (dist(u,v) + dist(v,u) &lt; min):
           min &lt;- dist(u,v) + dist(v,u)
           pair &lt;- (u,v)
<span style="color: #00ffff;">return</span> path(u,v) + path(v,u)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">20</h3>
<div class="outline-text-3" id="text-2-13">
<p>
Can we modify Dijkstra’s algorithm to solve the single-source longest
path problem by changing minimum to maximum? If so, then prove your
algorithm correct. If not, then provide a counterexample.
</p>

<p>
没有负weight的边,可以.
</p>
</div>
</div>

<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">21</h3>
<div class="outline-text-3" id="text-2-14">
<p>
LetG=(V,E) be a weighted acyclic directed graph with possibly negative
edge weights. Design a linear-time algorithm to solve the
single-source shortest-path problem from a given source v.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">for</span> each vertex y<span style="color: #00ffff;"> in</span> a topological ordering of G
    choose edge (x,y) minimizing d(s,x)+length(x,y)
    path(s,y) = path(s,x) + edge (x,y)
    d(s,y) = d(s,x) + length(x,y)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">22</h3>
<div class="outline-text-3" id="text-2-15">
<p>
Let G=(V,E) be a directed weighted graph such that all the weights are
positive. Let v and w be two vertices in G and k≤|V| be an integer. Design
an algorithm to find the shortest path from v to w that contains
exactly k edges. Note that the path need not be simple.
</p>

<div class="org-src-container">

<pre class="src src-sh">create the table D[V,k];
<span style="color: #eedd82;">D</span>[v,1] = 0;
<span style="color: #00ffff;">for</span> i<span style="color: #00ffff;"> in</span> other vertex except v:
         <span style="color: #eedd82;">D</span>[i,1] = MAX_INT;
<span style="color: #00ffff;">for</span> <span style="color: #eedd82;">m</span>=2 to k:
    <span style="color: #00ffff;">for</span> every edge(i,j):
        <span style="color: #eedd82;">D</span>[j,m] = D[i,m-1] + D[i,j]
        <span style="color: #eedd82;">P</span>[i,m] = i
<span style="color: #eedd82;">Path</span> = emtpy list
<span style="color: #eedd82;">i</span> = w
<span style="color: #00ffff;">for</span> <span style="color: #eedd82;">m</span>=k down to 1:
    Path.append(m);
    <span style="color: #eedd82;">i</span> = P[m,k]
 Path.append(V);
 Path.reverse();
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">23</h3>
<div class="outline-text-3" id="text-2-16">
<p>
Arbitrage is the use of discrepancies in currency-exchange rates to
make a profit. For example, there may be a small window of time during
which 1 U.S. dollar buys 0.75 British pounds, 1 British pound buys 2
Australian dollars, and 1 Australian dollar buys 0.70 U.S. dollars. At
such a time, a smart trader can trade one U.S. dollar and end up with
0.75 × 2 × 0.7 = 1.05 U.S. dollars—a profit of 5%. Suppose that
there are n currencies c1 , …, cn and an n × n table R of exchange
rates, such that one unit of currency ci buys R[i,j] units of currency
cj. Devise and analyze an algorithm to determine the maximum value of
R[c1, ci1] · R[ci1, ci2] · · · R[cik−1, cik] · R[cik, c1]
</p>

<p>
log(a*b*c) = loga + lgob + log.所以求最长路径.
</p>

<ol class="org-ol">
<li>用Floyd-Warshall算法算出i,j的最长路径;
</li>
<li>计算所有C<sub>(1i)</sub>*C<sub>(i1)</sub>的值,得出最大值.
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 5]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/12/The-Algorithm-Design-Manual5/"/>
    <updated>2014-06-12T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/12/The-Algorithm-Design-Manual5</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">5.1 Flavors of Graphs</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Undirected vs. Directed
</li>
<li>Weighted vs. Unweighted
</li>
<li>Simple vs. Non-simple
</li>
<li>Sparse vs. Dense
</li>
<li>Cyclic vs. Acyclic
</li>
<li>Embedded vs. Topological
</li>
<li>Implicit vs. Explicit
</li>
<li>Labeled vs. Unlabeled
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">5.2 Data Structures for Graphs</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Adjacency Matrix: We can represent G using an n×n matrix M, where
element M[i, j] = 1 if(i, j) is an edge of G, and 0 if it isn’t.
</li>
<li>Adjacency Lists: We can more efficiently represent sparse graphs by
using linked lists to store the neighbors adjacent to each vertex.
</li>
</ul>

<p>
Adjacency lists are the right data structure for most applications of
graphs.
</p>

<p>
<b>Adjacency Lists</b>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXV</span> 1000  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">maximum number of vertices</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">adjacency info</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">edge weight, if any</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">next</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">next edge in list</span>
} <span style="color: #98fb98;">edgenode</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">edges</span>[MAXV + 1];   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">adjacency info</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">degree</span>[MAXV + 1];  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">outdegree of each vertex</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nvertices</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">number of vertices in graph</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nedges</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">number of edges in graph</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">is the graph directed</span>
} <span style="color: #98fb98;">graph</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">initialize_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  g-&gt;nvertices = 0;
  g-&gt;nedges = 0;
  g-&gt;directed = directed;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= NMAX; ++i) {
    g-&gt;degree[i] = 0;
    g-&gt;edges[i] = <span style="color: #7fffd4;">NULL</span>;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">insert_edge</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>;
  p = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">edgenode</span>;
  p-&gt; weight = 0;
  p-&gt;y = y;
  p-&gt;next = g-&gt;edges[x];
  g-&gt;edges[x] = p;
  g-&gt;degree[x]++;
  <span style="color: #00ffff;">if</span> (directed == <span style="color: #7fffd4;">false</span>) {
    insert_edge(g, y, x, <span style="color: #7fffd4;">true</span>);
  } <span style="color: #00ffff;">else</span> {
    g-&gt;nedges++;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">read_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>;
  initialize_graph(g, directed);
  scanf(<span style="color: #ffa07a;">"%d %d"</span>, &amp;(g-&gt;nvertices), &amp;m);
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= m; ++i) {
    scanf(<span style="color: #ffa07a;">"$d %d"</span>, &amp;x, &amp;y);
    insert_edge(g, x, y, directed);
  }
}

<span style="color: #87cefa;">print_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= g-&gt;nvertices; ++i) {
    printf(<span style="color: #ffa07a;">"%d: "</span>, i);
    p = g-&gt;edges[i];
    <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
      printf(<span style="color: #ffa07a;">"%d "</span>, p-&gt;y);
      p = p-&gt;next;
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">5.5 Traversing a Graph</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The key idea behind graph traversal is to mark each vertex when we
first visit it and keep track of what we have not yet completely
explored. Although bread crumbs or unraveled threads have been used to
mark visited places in fairy-tale mazes, we will rely on Boolean flags
or enumerated types.
</p>

<p>
Each vertex will exist in one of three states:
</p>
<ul class="org-ul">
<li>undiscovered– the vertex is in its initial, virgin state.
</li>
<li>discovered– the vertex has been found, but we have not yet checked
out all its incident edges.
</li>
<li>processed– the vertex after we have visited all its incident edges.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">5.6 Breadth-First Search</h3>
<div class="outline-text-3" id="text-1-4">
<p>
先遍历完一个点的所有相邻点。
</p>

<div class="org-src-container">

<pre class="src src-c++">    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">processed</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">which vertices have been processed */</span>
    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">discovered</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">which vertices have been found */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">discovery relation */</span>

    <span style="color: #87cefa;">initialize_search</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>)
    {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
      <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++) {
        processed[i] = discovered[i] = FALSE;
        parent[i] = -1;
      }
    }

  <span style="color: #87cefa;">bfs</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>)
  {
    <span style="color: #98fb98;">queue</span> <span style="color: #eedd82;">q</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">queue of vertices to visit */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">current vertex */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">successor vertex */</span>
    <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
    init_queue(&amp;q);
    enqueue(&amp;q,start);
    discovered[start] = TRUE;
    <span style="color: #00ffff;">while</span> (empty_queue(&amp;q) == FALSE) {
      v = dequeue(&amp;q);
      process_vertex_early(v);
      processed[v] = TRUE;
      p = g-&gt;edges[v];
      <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
        y = p-&gt;y;
        <span style="color: #00ffff;">if</span> ((processed[y] == FALSE) || g-&gt;directed)
          process_edge(v,y);
        <span style="color: #00ffff;">if</span> (discovered[y] == FALSE) {
          enqueue(&amp;q,y);
          discovered[y] = TRUE;
          parent[y] = v;
        }
        p = p-&gt;next;
      }
      process_vertex_late(v);
    }
  }

<span style="color: #87cefa;">find_path</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">end</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parents</span>[])
{
  <span style="color: #00ffff;">if</span> ((start == end) || (end == -1))
    printf(<span style="color: #ffa07a;">"\n%d"</span>,start);
  <span style="color: #00ffff;">else</span> {
    find_path(start,parents[end],parents);
    printf(<span style="color: #ffa07a;">" %d"</span>,end);
  }
}
</pre>
</div>

<p>
Because vertices are discovered in order of increasing distance from the root,
this tree has a very important property. The unique tree path from the root to
each node x∈V uses the smallest number of edges (or equivalently, intermediate
nodes) possible on any root-to-xpath in the graph.
</p>

<p>
There are <b>two points</b> to remember when using breadth-first search to find a
shortest path fromxtoy: First, the shortest path tree is only useful if BFS was
performed with x as the root of the search. Second, BFS gives the shortest path
only if the graph is unweighted.
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">5.7 Applications of Breadth-First Search</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Properly implemented using adjacency lists, any such algorithm is
destined to be linear, since BFS runs in O(n+m) time on both directed
and undirected graphs. This is optimal, since it is as fast as one can
hope to read any n-vertex, m-edge graph.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">5.8 Depth-First Search</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The difference between BFS and DFS results is in the order in which they
explore vertices. This order depends completely upon the container
data structure used to store the discovered but not processed
vertices.
</p>

<ul class="org-ul">
<li>Queue– By storing the vertices in a first-in, first-out (FIFO)
queue, we explore the oldest unexplored vertices first. Thus our
explorations radiate out slowly from the starting vertex, defining a
breadth-first search.
</li>

<li>Stack– By storing the vertices in a last-in, first-out (LIFO) stack,
we explore the vertices by lurching along a path, visiting a new
neighbor if one is available, and backing up only when we are
surrounded by previously discovered vertices. Thus, our explorations
quickly wanderaway from our starting point, defining a depth-first
search.
</li>
</ul>

<p>
DFS organizes vertices by entry/exit times, and edges into tree and
back edges. This organization is what gives DFS its real power.
</p>

<p>
<b>Implementation</b>
</p>

<p>
The beauty of implementingdfsrecursively is that recursion eliminates
the need to keep an explicit stack:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">dfs</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">successor vertex */</span>
  <span style="color: #00ffff;">if</span> (finished) <span style="color: #00ffff;">return</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">allow for search termination */</span>
  discovered[v] = TRUE;
  time = time + 1;
  entry_time[v] = time;
  process_vertex_early(v);
  p = g-&gt;edges[v];
  <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    y = p-&gt;y;
    <span style="color: #00ffff;">if</span> (discovered[y] == FALSE) {
      parent[y] = v;
      process_edge(v,y);
      dfs(g,y);
    }
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ((!processed[y]) || (g-&gt;directed))
      process_edge(v,y);
    <span style="color: #00ffff;">if</span> (finished) <span style="color: #00ffff;">return</span>;
    p = p-&gt;next;
  }
  process_vertex_late(v);
  time = time + 1;
  exit_time[v] = time;
  processed[v] = TRUE;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">5.9 Applications of Depth-First Search</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">Finding Cycles</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
But any back edge going from x to an ancestorycreates a cycle with the
tree path fromytox. Such a cycle is easy to find using dfs:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #00ffff;">if</span> (parent[x] != y) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">found back edge! */</span>
    printf(<span style="color: #ffa07a;">"Cycle from %d to %d:"</span>,y,x);
    find_path(y,x,parent);
    printf(<span style="color: #ffa07a;">"\n\n"</span>);
    finished = TRUE;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">Articulation Vertices</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Observe that there is a single point of failure—a single vertex whose
deletion disconnects a connected component of the graph. Such a vertex
is called an articulation vertex or cut-node.
</p>

<p>
More robust graphs without such a vertex are said to be biconnected.
</p>

<p>
Temporarily delete each vertex v, and then do a BFS or DFS traversal
of the remaining graph to establish whether it is still connected. The
total time fornsuch traversals is O(n(m+n)). There is a clever
linear-time algorithm, however, that tests all the vertices of a
connected graph using a single depth-first search.
</p>

<p>
Let <code>reachable_ancestor[v]</code> denote the earliest reachable ancestor of
vertex v, meaning the oldest ancestor ofvthat we can reach by a
combination of tree edges and back edges. Initially,
<code>reachable_ancestor[v] = v</code>:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">reachable_ancestor</span>[MAXV+1]; <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">earliestreachableancestorofv*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tree_out_degree</span>[MAXV+1];  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">DFStree outdegree ofv*/</span>
<span style="color: #87cefa;">process_vertex_early</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  reachable_ancestor[v] = v;
}
</pre>
</div>

<p>
We update <code>reachable_ancestor[v]</code> whenever we encounter a back edge
that takes us to an earlier ancestor than we have previously seen. The
relative age/rank of our ancestors can be determined from
their <code>entry_time’s</code>:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #00ffff;">class</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge class */</span>
  <span style="color: #00ffff;">class</span> = edge_classification(x,y);
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == TREE)
    tree_out_degree[x] = tree_out_degree[x] + 1;
  <span style="color: #00ffff;">if</span> ((<span style="color: #00ffff;">class</span> == BACK) &amp;&amp; (parent[x] != y)) {
    <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ reachable_ancestor[x] ] )
      reachable_ancestor[x] = y;
  }
}
</pre>
</div>

<p>
The key issue is determining how the reachability relation impacts
whether vertexv is an articulation vertex. There are three cases:
</p>
<ul class="org-ul">
<li>Root cut-nodes– If the root of the DFS tree has two or more
children, it must be an articulation vertex. No edges from the
subtree of the second child can possibly connect to the subtree of
the first child.
</li>

<li>Bridge cut-nodes– If the earliest reachable vertex fromvis v, then
deleting the single edge (parent[v],v) disconnects the graph.
Clearlyparent[v] must be an articulation vertex, since it cuts v from
the graph. Vertex vis also an articulation vertex unless it is a
leaf of the DFS tree. For any leaf, nothing falls off when you cut it.
</li>
<li>Parent cut-nodes– If the earliest reachable vertex fromvis the
parent of v, then deleting the parent must severvfrom the tree
unless the parent is the root.
</li>
</ul>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/articulation_vertices.jpg" />

<p>
The routine below systematically evaluates each of the three
conditions as we back up from the vertex after traversing all outgoing
edges. We use <code>entry_time[v]</code> to represent the age of vertex v. The
reachability time <code>time_v</code> calculated below denotes the oldest vertex that
can be reached using back edges.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_vertex_late</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">root</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is the vertex the root of the DFS tree? */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time_v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">earliest reachable time for v */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time_parent</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">earliest reachable time for parent[v] */</span>
  <span style="color: #00ffff;">if</span> (parent[v] &lt; 1) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">test if v is the root */</span>
    <span style="color: #00ffff;">if</span> (tree_out_degree[v] &gt; 1)
      printf(<span style="color: #ffa07a;">"root articulation vertex: %d \n"</span>,v);
    <span style="color: #00ffff;">return</span>;
  }
  root = (parent[parent[v]] &lt; 1); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is parent[v] the root? */</span>
  <span style="color: #00ffff;">if</span> ((reachable_ancestor[v] == parent[v]) &amp;&amp; (!root))
    printf(<span style="color: #ffa07a;">"parent articulation vertex: %d \n"</span>,parent[v]);
  <span style="color: #00ffff;">if</span> (reachable_ancestor[v] == v) {
    printf(<span style="color: #ffa07a;">"bridge articulation vertex: %d \n"</span>,parent[v]);
    <span style="color: #00ffff;">if</span> (tree_out_degree[v] &gt; 0) <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">test if v is not a leaf */</span>
      printf(<span style="color: #ffa07a;">"bridge articulation vertex: %d \n"</span>,v);
  }
  time_v = entry_time[reachable_ancestor[v]];
  time_parent = entry_time[ reachable_ancestor[parent[v]] ];
  <span style="color: #00ffff;">if</span> (time_v &lt; time_parent)
    reachable_ancestor[parent[v]] = reachable_ancestor[v];
}
</pre>
</div>

<p>
We can alternately talk about reliability in terms of edge failures
instead of vertex failures. 
</p>

<p>
In fact
all bridges can be identified in the same O(n+m) time. Edge (x, y) is a
bridge if (1) it is a tree edge, and (2) no back edge connects from
yor below toxor above. This can be computed with a minor modification
of the <code>reachable_ancestor</code> function.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">5.10 Depth-First Search on Directed Graphs</h3>
<div class="outline-text-3" id="text-1-8">
<p>
For directed graphs, depth-first search labelings can take on a wider
range of possibilities. Indeed, all four of the edge cases in Figure
below can occur in traversing directed graphs.
</p>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/edge_cases_for_traversl.jpg" />

<p>
The correct labeling of each edge can be readily determined from the
state, discovery time, and parent of each vertex, as encoded in the
following function:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">edge_classification</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #00ffff;">if</span> (parent[y] == x) <span style="color: #00ffff;">return</span>(TREE);
  <span style="color: #00ffff;">if</span> (discovered[y] &amp;&amp; !processed[y]) <span style="color: #00ffff;">return</span>(BACK);
  <span style="color: #00ffff;">if</span> (processed[y] &amp;&amp; (entry_time[y]&gt;entry_time[x])) <span style="color: #00ffff;">return</span>(FORWARD);
  <span style="color: #00ffff;">if</span> (processed[y] &amp;&amp; (entry_time[y]&lt;entry_time[x])) <span style="color: #00ffff;">return</span>(CROSS);
  printf(<span style="color: #ffa07a;">"Warning: unclassified edge (%d,%d)\n"</span>,x,y);
}
</pre>
</div>
</div>

<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">Strongly Connected Components</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
A directed graph isstrongly connectedif there is a directed path
between any two vertices.
</p>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/strongly_connected_components.jpg" />

<p>
The algorithm is based on the observation that it is easy to find a
directed cycle using a depth-first search, since any back edge plus
the down path in the DFS tree gives such a cycle. All vertices in this
cycle must be in the same strongly connected component. Thus, we can
shrink (contract) the vertices on this cycle down to a single vertex
representing the component, and then repeat. This process terminates
when no directed cycle remains, and each vertex represents a different
strongly connected component.
</p>

<p>
We update our notion of the oldest reachable vertex in response to (1)
nontree edges and (2) backing up from a vertex.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">strong_components</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=(g-&gt;nvertices); i++) {
    low[i] = i;
    scc[i] = -1;
  }
  components_found = 0;
  init_stack(&amp;active);
  initialize_search(&amp;g);
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=(g-&gt;nvertices); i++)
    <span style="color: #00ffff;">if</span> (discovered[i] == FALSE) {
      dfs(g,i);
    }
}
</pre>
</div>

<p>
Define low[v]to be the oldest vertex known to be in the same strongly
connected component asv. This vertex is not necessarily an ancestor,
but may also be a distant cousin of v because of cross edges. Cross
edges that point vertices from previous strongly connected components
of the graph cannot help us, because there can be no way back from
them tov, but otherwise cross edges are fair game. Forward edges have
no impact on reachability over the depth-first tree edges, and hence
can be disregarded:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">oldest vertex surely in component of v */</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">scc</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">strong component number for each vertex */</span>
<span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #00ffff;">class</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge class */</span>
  <span style="color: #00ffff;">class</span> = edge_classification(x,y);
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == BACK) {
    <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ low[x] ] )
      low[x] = y;
  }
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == CROSS) {
    <span style="color: #00ffff;">if</span> (scc[y] == -1) <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">component not yet assigned */</span>
      <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ low[x] ] )
        low[x] = y;
  }
}
</pre>
</div>

<p>
A new strongly connected component is found whenever the lowest reachable
vertex fromvis v. If so, we can clear the stack of this component.
Otherwise, we give our parent the benefit of the oldest ancestor we
can reach and backtrack:
</p>

<div class="org-src-container">

<pre class="src src-c++">  <span style="color: #87cefa;">process_vertex_early</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
  {
    push(&amp;active,v);
  }

<span style="color: #87cefa;">process_vertex_late</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #00ffff;">if</span> (low[v] == v) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge (parent[v],v) cuts off scc */</span>
    pop_component(v);
  }
  <span style="color: #00ffff;">if</span> (entry_time[low[v]] &lt; entry_time[low[parent[v]]])
    low[parent[v]] = low[v];
}

<span style="color: #87cefa;">pop_component</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">vertex placeholder */</span>
  components_found = components_found + 1;
  scc[ v ] = components_found;
  <span style="color: #00ffff;">while</span> ((t = pop(&amp;active)) != v) {
    scc[ t ] = components_found;
  }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">5</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Give a linear algorithm to compute the chromatic number of graphs
where each vertex has degree at most 2. Must such graphs be bipartite?
</p>

<p>
这样的图不必要是bipartite的.反例是:3个顶点,两两相连.
</p>

<p>
因为每个顶点最多2度,使用DFS遍历,对子顶点着色与父顶点相反的颜色.当遇到一个回归的边,那么对当前定点着色与父顶点不同,并且与回归边上的祖先定点不同.
</p>

<p>
只有一次遍历,复杂度O(m+n) (m edges, n vertices).
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">7</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Given pre-order and in-order traversals of a binary tree, is it
possible to reconstruct the tree? If so, sketch an algorithm to do it.
If not, give a counterexample. Repeat the problem if you are given the
pre-order and post-order traversals.
</p>

<p>
没有相同元素,给予pre-order and in-order traversals能重构binary search
tree.代码如下.若有相同元素,给予:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #eedd82;">preorder</span> = {1,1}
<span style="color: #eedd82;">inorder</span> = {1,1}
</pre>
</div>
<p>
可以重构:
</p>
<div class="org-src-container">

<pre class="src src-sh">  1                     1
 /           or          <span style="color: #ffa07a;">\</span>
1                         1
</pre>
</div>

<p>
每次preorder的数都要去搜索在inoder所在位置,若书是平衡的,那么n个元素每次搜索后总的算法复杂度O(nlogn),但不是平衡的,一下就变成O(n<sup>2</sup>).
</p>

<p>
所以利用hash table,先把inorder的元素和位置hash起来,那么总的算法时间:O(n).
</p>

<p>
以下假设元素都小于255,简单的利用数组映射来模拟hash table.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">left</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">right</span>;
  <span style="color: #87cefa;">Node</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val_in</span>) {
    val = val_in;
    left = <span style="color: #7fffd4;">NULL</span>;
    right = <span style="color: #7fffd4;">NULL</span>;
  }
};

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMax</span> = 256;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">map_index</span>[kMax];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">MapToIndex</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inorder</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    map_index[inorder[i]] = i;
  }
}

<span style="color: #98fb98;">Node</span> *<span style="color: #87cefa;">BuildInorderPreorder</span>(<span style="color: #98fb98;">in</span> <span style="color: #eedd82;">in</span>[], <span style="color: #98fb98;">in</span> <span style="color: #eedd82;">pre</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>) {
  <span style="color: #00ffff;">if</span> (n == 0) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>:
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">root_val</span> = pre[0];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = map_index[root_val] - offset;
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">root</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Node</span>(root_val);
  root-&gt;left = BuildInorderPreorder(in, pre+1, i, offset);
  root-&gt;right = BuildInorderPreorder(in+i+1, pre+i+1, offset+i+1);
  <span style="color: #00ffff;">return</span> root;
}
</pre>
</div>

<ul class="org-ul">
<li>给予pre-order and post-order traversals, 不能重构binary search tree.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">12</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The square of a directed graph G = (V,E) is the graph G<sup>2</sup> = (V,E<sup>2</sup>) such
that (u,w)∈E<sup>2</sup> iff there exists v∈V, such that (u,v)∈E  and
(u,w)∈E; i.e., there is a path of exactly two edges from u to w.
square of a graph Give efficient algorithms for both adjacency lists
and matrices.
</p>

<p>
<b>adjacency matrices</b>
算法复杂度：O(n<sup>3</sup>).
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">MakeSquareGraph</span>(G, n)
<span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>=1 to n
    <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">j</span>=1 to n
        <span style="color: #eedd82;">G2</span>[i][j] = 0
<span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>=1 to n
    <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">j</span>=1 to n
        <span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">G</span>[i][j] == 1)
           <span style="color: #00ffff;">for</span> <span style="color: #eedd82;">k</span>=1 to n
               <span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">G</span>[j][k] == 1)
                  <span style="color: #eedd82;">G2</span>[i][k] = 1
<span style="color: #00ffff;">return</span> G2
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">18</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Consider a set of movies \(M_1, M_2, \ldots, M_k\). There is a set of
customers, each one of which indicates the two movies they would like
to see this weekend. Movies are shown on Saturday evening and Sunday
evening. Multiple movies may be screened at the same time. You must
decide which movies should be televised on Saturday and which on
Sunday, so that every customer gets to see the two movies they
desire. Is there a schedule where each movie is shown at most once?
Design an efficient algorithm to find such a schedule if one exists.
</p>

<p>
把问题转换成图问题解决。建立无向图，顶点是每部电影，边E(1,2)表示有个客户想看M1和M2.如下图实例，有电影M1-M4,3个客户，1个客户想看M1和M3,一个客户想看M1和M4，一个客户想看M2和M4.那么把图分成（M1，M2）和（M3,M4），周六日各放一组,满足所有客户要求。
</p>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/movie1.jpg" />

<p>
若多一个客户想看M3和M4,如下图，无论怎么分图，都有2部电影相连，所以不能满足所有客户的要求。可以得出：若原本的图是bipartite graph，那么能找到满足客户的放映安排。若不是，就不能满足客户要求。
</p>

<img src="http://dreamrunner.org/images/blog/2014/AlgorithmDesignManual/movie2.jpg" />
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">23</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Your job is to arrange n ill-behaved children in a straight line,
facing front. You are given a list of m statements of the form i hates
j. If i hates j, then you do not want put i somewhere behind j,
because then i is capable of throwing something at j.
</p>

<ol class="org-ol">
<li>Give an algorithm that orders the line, (or says that it is not
possible) in O(m + n) time.
</li>

<li>Suppose instead you want to arrange the children in rows such that
if i hates j, then i must be in a lower numbered row than j. Give
an efficient algorithm to find the minimum number of rows needed,
if it is possible.
</li>

<li>创建一幅有向图,顶点代表孩子,有向边E(i,j)代表孩子i hates 孩子j;
</li>
<li>topological sort得到队列，或BFS时发现环，证明不可能。只BFS遍历一次，
O(m + n)。
</li>

<li>如题1创建有向图;
</li>
<li>作DFS遍历，用遍历的level作为行号。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">31</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Which data structures are used in depth-first and breath-first search?
</p>
<ol class="org-ol">
<li>BFS:使用queue
</li>
<li>DFS:使用stack,通常使用递归代替stack.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">32</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Write a function to traverse binary search tree and return the ith
node in sorted order.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">left</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">right</span>;
  <span style="color: #87cefa;">Node</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val_in</span>) {
    val = val_in;
    left = <span style="color: #7fffd4;">NULL</span>;
    right = <span style="color: #7fffd4;">NULL</span>;
  }
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindIthElementCore</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">root</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ith</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">index</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">value</span>) {
  <span style="color: #00ffff;">if</span> (root == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">if</span> (FindIthElementCore(root-&gt;left, ith, index, value)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  cout &lt;&lt; ith &lt;&lt; <span style="color: #ffa07a;">": "</span> &lt;&lt; *index &lt;&lt; <span style="color: #ffa07a;">": "</span> &lt;&lt; root-&gt;val &lt;&lt; endl;
  <span style="color: #00ffff;">if</span> (ith == *index) {
    *value = root-&gt;val;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  (*index)++;
  <span style="color: #00ffff;">if</span> (FindIthElementCore(root-&gt;right, ith, index, value)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindIthElement</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">root</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ith</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">value</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span> = 0;
  <span style="color: #00ffff;">return</span> FindIthElementCore(root, ith, &amp;start, value);
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 4]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/09/The-Algorithm-Design-Manual4/"/>
    <updated>2014-06-09T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/09/The-Algorithm-Design-Manual4</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">4.3 Heapsort: Fast Sorting via Data Structures</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Where in the Heap?</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Problem: Given an array-based heap on n elements and a real number x,
efficiently determine whether the kth smallest element in the heap is
greater than or equal to x. Your algorithm should be O(k) in the
worst-case, independent of the size of the heap. Hint: you do not have
to find the kth smallest element; you need only determine its
relationship to x.
</p>

<p>
Solution: There are at least two different ideas that lead to correct
but inefficient algorithms for this problem:
</p>

<ol class="org-ol">
<li>Call extract-minktimes, and test whether all of these are less
thanx. This explicitly sorts the firstkelements and so gives us
more information than the desired answer, but it takes O(klogn) time
to do so.
</li>
<li>The kth smallest element cannot be deeper than the kth level of the
heap, since the path from it to the root must go through elements
of decreasing value. Thus we can look at all the elements on the
first k levels of the heap, and count how many of them are less
thanx, stopping when we either find k of them or run out of
elements. This is correct, but takes O(min(n,2<sup>k</sup>-1)) time, since
the top k elements have 2<sup>k</sup>-1 elements.
</li>
</ol>

<p>
An O(k) solution can look at only k elements smaller than x, plus at
most O(k) elements greater than x. Consider the following recursive
procedure, called at the root with i= 1 with count=k:
</p>

<!-- more -->


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">heap_compare</span>(<span style="color: #98fb98;">priority_queue</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>)
{
  <span style="color: #00ffff;">if</span> ((count &lt;= 0) || (i &gt; q-&gt;n)) <span style="color: #00ffff;">return</span>(count);
  <span style="color: #00ffff;">if</span> (q-&gt;q[i] &lt; x) {
    count = heap_compare(q, pq_young_child(i), count-1, x);
    count = heap_compare(q, pq_young_child(i)+1, count, x);
  }
  <span style="color: #00ffff;">return</span>(count);
}
</pre>
</div>

<p>
If the root of the min-heap is ≥ x, then no elements in the heap can
be less than x, as by definition the root must be the smallest
element. This procedure searches the children of all nodes of weight
smaller than x until either (a) we have found k of them, when it returns
0, or (b) they are exhausted, when it returns a value greater than
zero. Thus it will find enough small elements if they exist.
</p>

<p>
But how long does it take? The only nodes whose children we look at
are those &lt; x, and at most k of these in total. Each have at most
visited two children, so we visit at most 3k nodes, for a total time
of O(k).
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">4.5 Mergesort: Sorting by Divide-and-Conquer</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Mergesort is a great algorithm for sorting linked lists, because it
does not rely on random access to elements as does heapsort or
quicksort. Its primary disadvantage is the need for an auxilliary
buffer when sorting arrays. It is easy to merge two sorted linked
lists without using any extra space, by just rearranging the pointers.
However, to merge two sorted arrays (or portions of an array), we need
use a third array to store the result of the merge to avoid stepping
on the component arrays
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">4.9 Binary Search and Related Algorithms</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binary_search</span>(<span style="color: #98fb98;">item_type</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">item_type</span> <span style="color: #eedd82;">key</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">high</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">middle</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">index of middle element */</span>
  <span style="color: #00ffff;">if</span> (low &gt; high) <span style="color: #00ffff;">return</span> (-1); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">key not found */</span>
  middle = (low+high)/2;
  <span style="color: #00ffff;">if</span> (s[middle] == key) <span style="color: #00ffff;">return</span>(middle);
  <span style="color: #00ffff;">if</span> (s[middle] &gt; key)
    <span style="color: #00ffff;">return</span> (binary_search(s,key,low,middle-1));
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> (binary_search(s,key,middle+1,high));
}
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Counting Occurrences</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
This algorithm runs inO(lgn+s), wheresis the number of occurrences of
the key. This can be as bad as linear if the entire array consists of
identical keys. A faster algorithm results by modifying binary search
to search for the boundary of the block containing k, instead of
kitself. Suppose we delete the equality test
</p>

<p>
<code>if (s[middle] == key) return(middle);</code>
</p>

<p>
from the implementation above and return the index <code>low</code> instead of
<code>−1</code> on each unsuccessful search. All searches will now be
unsuccessful, since there is no equality test. The search will proceed
to the right half whenever the key is compared to an identical array
element, eventually terminating at the <b>right boundary</b>. Repeating the
search after reversing the direction of the binary comparison will
lead us to the <b>left boundary</b>. Each search takes O(lgn) time, so we can
count the occurrences in logarithmic time regardless of the size of
the block.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">One-Sided Binary Search</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Now suppose we have an array A consisting of a run of 0’s, followed
by an unbounded run of 1’s, and would like to identify the exact
point of transition between them. Binary search on the array would
provide the transition point in lgn tests, if we had a bound non the
number of elements in the array. In the absence of such
a bound, we can test repeatedly at larger intervals (<code>A[1], A[2],
A[4], A[8], A[16],...</code>) until we find a first nonzero value. Now we
have a window containing the target and can proceed with binary
search. This <i>one-sided binary search</i> finds the transition pointpusing at
most 2lgp comparisons, regardless of how large the array actually is.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Square and Other Roots</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
First, observe that the square root ofn≥1 must be at least 1 and at
most n. Let <code>l = 1</code> and <code>r = n</code>. Consider the midpoint of this
interval, <code>m=(l+r)/2</code>. How does m<sup>2</sup> compare to n? If n≥m<sup>2</sup> , then the
square root must be greater than m, so the algorithm repeats with
<code>l=m</code>. If n&lt;m<sup>2</sup> , then the square root must be less than m, so the
algorithm repeats with <code>r=m</code>. 
</p>

<p>
Suppose that we start with values l and r such that f(l)&gt;0 and f(r)&lt;0.
If f is a continuous function, there must exist a root between l and
r. Depending upon the sign of f(m), where <code>m=(l+r)/2</code>, we can cut this
window containing the root in half with each test and stop soon as our
estimate becomes sufficiently accurate.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">4.10 Divide-and-Conquer</h3>
<div class="outline-text-3" id="text-1-4">
<p>
divide-and-conquer recurrences of the form T(n)=aT(n/b)+f(n)
</p>

1. If $f(n) = O(n^{log_{b}^{a-\epsilon}})$ for some constant $\epsilon
   &gt; 0$, then $T(n) = \Theta(n^{log_{b}^a})$. <br /> 
2. If $f(n) = O(n^{log_{b}^{a}})$, then $T(n) =
   \Theta(n^{log_{b}^a}lgn)$.  <br /> 
3. If $f(n) = O(n^{log_{b}^{a+\epsilon}})$ for some constant $\epsilon
   &gt; 0$ and if $af(n/b) \leq cf(n)$ for some $c&lt;1$, then $T(n) =
   \Theta(f(n))$.  <br /> 
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The Grinch is given the job of partitioning 2n players into two teams
of n players each. Each player has a numerical rating that measures
how good he/she is at the game. He seeks to divide the players as
unfairly as possible, so as to create the biggest possible talent
imbalance between team A and team B. Show how the Grinch can do the
job in O(nlogn) time.
</p>

<p>
用个O(nlogn)的排序算法对2n个队根据实力排序，前n个作为一队，后n个作为一队。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
For each of the following problems, give an algorithm that finds the
desired numbers within the given amount of time. To keep your answers
brief, feel free to use algorithms from the book as subroutines. For
the example,S={6,13,19,3,8}, 19−3 maximizes the difference, while 8−6
minimizes the difference.
</p>


<p>
(a) Let S be an unsorted array of n integers. Give an algorithm that
finds the pair x, y∈S that maximizes|x−y|. Your algorithm must run in
O(n) worst-case time.
</p>

<p>
(b) Let S be a sorted array of n integers. Give an algorithm that finds
the pair x, y∈S that maximizes |x−y|. Your algorithm must run in O(1)
worst-case time.
</p>

<p>
(c) Let S be an unsorted array of n integers. Give an algorithm that finds
the pair x, y∈S that minimizes |x−y|, for x &ne; y. Your algorithm must run
in O(nlogn) worst-case time.
</p>

<p>
(d) Let S be a sorted array of n integers. Give an algorithm that finds the pair
x, y∈S that minimizes |x−y|, for x &ne; y. Your algorithm must run in O(n)
worst-case time.
</p>


<ul class="org-ul">
<li>(a) 扫描S一次获得最小和最大值.
</li>
<li>(b) 取首尾数。
</li>
<li>(c) O(nlogn)的算法排序，扫描排序好的S，获得最小差的相邻元素对。
</li>
<li>(d) 扫描排序好的S，获得最小差的相邻元素对。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Take a sequence of 2n real numbers as input. Design an O(nlogn)
algorithm that partitions the numbers intonpairs, with the property
that the partition minimizes the maximum sum of a pair. For example,
say we are given the numbers (1,3,5,9). The possible partitions are
((1,3),(5,9)), ((1,5),(3,9)), and ((1,9),(3,5)). The pair sums for
these partitions are (4,14), (6,12), and (10,8). Thus the third
partition has 10 as its maximum sum, which is the minimum over the
three partitions.
</p>

<ol class="org-ol">
<li>O(nlogn)的算法排序
</li>
<li><div class="org-src-container">

<pre class="src src-c++">start = 0;
end = 2n - 1;
<span style="color: #00ffff;">while</span> (start &lt; end) {
  pair(S[star], S[end]);
  start++;
  end--;
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Assume that we are given n pairs of items as input, where the first item
is a and the second item is one of three colors (red, blue, or
yellow). Further assume that the items are sorted by number. Give
an O(n) algorithm to sort the items by color (all reds before all blues
before all yellows) such that the numbers for identical colors stay
sorted. For example: (1,blue), (3,red), (4,blue), (6,yellow), (9,red)
should become (3,red), (9,red), (1,blue), (4,blue), (6,yellow).
</p>

<ol class="org-ol">
<li>创建3个分别存储red，blue，yellow的数组;
</li>
<li>扫描input，依次按颜色装入不同的数组;
</li>
<li>分别从red，blue，yellow的数组中输出结果。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The mode of a set of numbers is the number that occurs most frequently
in the set. The set (4,6,2,4,3,1) has a mode of 4. Give an efficient
and correct algorithm to compute the mode of a set of n numbers.
</p>

<ul class="org-ul">
<li>O(nlogn): O(nlogn)排序，扫描Set一遍得到频率最大的数。
</li>
<li>O(n): 使用hash map扫描一遍存储数字频率，扫描hash map得到频率最大数。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Given two sets S1 and S2 (each of size n), and a number x, describe an
O(nlogn) algorithm for finding whether there exists a pair of
elements, one from S1 and one from S2, that add up to x. (For partial
credit, give a Θ(n<sup>2</sup>) algorithm for this problem.)
</p>

<ol class="org-ol">
<li>从S1中减去n，O(nlogn)排序S1和S2,然后能否找出相同的元素（binary search或扫描比较）。
</li>
<li>Sort and Scan
<div class="org-src-container">

<pre class="src src-sh">sort S1<span style="color: #00ffff;"> in</span> O(nlogn)
sort S2<span style="color: #00ffff;"> in</span> O(nlogn)
<span style="color: #eedd82;">begin</span> = 0;
<span style="color: #eedd82;">end</span> = n - 1;
<span style="color: #00ffff;">while</span> (begin &lt; n &amp;&amp; end &gt;=0) {
          <span style="color: #00ffff;">if</span> ((S1[begin] + S2[end]) &lt; X) {
                 begin++;
          }
          <span style="color: #00ffff;">else if</span> ((S1[begin] + S2[end]) &gt; X) {
                 end--;
          } <span style="color: #00ffff;">else</span> {
              <span style="color: #00ffff;">return </span><span style="color: #b0c4de;">true</span>;
          }
}
<span style="color: #00ffff;">return </span><span style="color: #b0c4de;">false</span>;
</pre>
</div>
</li>
<li>Binary Search
<ul class="org-ul">
<li>O(nlogn)排序S1
</li>
<li>X-S2[i]去binary search排序好的S1，是否找到元素。
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Outline a reasonable method of solving each of the following problems.
Give the order of the worst-case complexity of your methods.
</p>

<ol class="org-ol">
<li>You are given a pile of thousands of telephone bills and thousands
of checks sent in to pay the bills. Find out who did not pay.
</li>

<li>You are given a list containing the title, author, call number and
publisher of all the books in a school library and another list of
30 publishers. Find out how many of the books in the library were
published by each company.
</li>

<li>You are given all the book checkout cards used in the campus
library during the past year, each of which contains the name of
the person who took out the book. Determine how many distinct
people checked out at least one book.
</li>
</ol>

<p>
都使用Hash Table，O(n)
</p>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Given a set of S containing n real numbers, and a real number x. We
seek an algorithm to determine whether two elements of S exist whose
sum is exactly x.
</p>

<ul class="org-ul">
<li>Assume that S is unsorted. Give an O(nlogn) algorithm for the problem.
</li>
<li>Assume that S is sorted. Give an O(n) algorithm for the problem.
</li>
</ul>

<p>
(1):
Binary search
</p>
<div class="org-src-container">

<pre class="src src-sh">sort S<span style="color: #00ffff;"> in</span> O(nlogn);
<span style="color: #00ffff;">for</span> (int <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
        binarysearch S[i]<span style="color: #00ffff;"> in</span> S[i+1,n]
}
</pre>
</div>

<p>
Scan
</p>
<div class="org-src-container">

<pre class="src src-sh">sort S<span style="color: #00ffff;"> in</span> O(nlogn);
<span style="color: #eedd82;">i</span> = 0;
<span style="color: #eedd82;">j</span> = n - 1;
<span style="color: #00ffff;">while</span> (i &lt; j) {
  <span style="color: #00ffff;">if</span> (s[i] + s[j] &lt; X) {
    i++;
  } <span style="color: #00ffff;">else if</span> (s[i] + s[j] &gt; X) {
    j--;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">break</span>;
  }
}
</pre>
</div>

<p>
(2)
</p>
<div class="org-src-container">

<pre class="src src-c++">i = 0;
j = n - 1;
<span style="color: #00ffff;">while</span> (i &lt; j) {
  <span style="color: #00ffff;">if</span> (s[i] + s[j] &lt; X) {
    i++;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (s[i] + s[j] &gt; X) {
    j--;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">break</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">9</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Give an efficient algorithm to compute the union of sets A and B,
where n = max( | A | , | B | ). The output should be an array of
distinct elements that form the union of the sets, such that they
appear more than once in the union.
</p>

<ul class="org-ul">
<li>Assume that A and B are unsorted. Give an O(nlogn) algorithm for the
problem.
</li>

<li>Assume that A and B are sorted. Give an O(n) algorithm for the problem.
</li>

<li>O(nlogn)对Ａ和Ｂ排序，然后用2的O(n)的方法。
</li>
<li>若Ａ和Ｂ以升序排序
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #b0c4de;">set</span> U to empty;
int <span style="color: #eedd82;">i</span> = 0;
int <span style="color: #eedd82;">j</span> = 0;
<span style="color: #00ffff;">while</span> (i &lt; na &amp;&amp; j &lt; na) {
  <span style="color: #00ffff;">if</span> (A[i] &lt; B[j]) {
    add A[i] into U;
    i++;
  } <span style="color: #00ffff;">else</span> (A[i] &gt; B[j]) {
      add B[j] into U;
      j++;
    }
  <span style="color: #00ffff;">else</span> {
     add A[i] into U;
    i++;
    j++;
  }
}
<span style="color: #00ffff;">if</span> (i &lt; na) {
  <span style="color: #00ffff;">while</span> (i &lt; na) {
    add A[i] into U;
    i++;
  }
<span style="color: #00ffff;">if</span> (j &lt; nb) {
  <span style="color: #00ffff;">while</span> (j &lt; nb) {
   add B[j] into U;
      j++;
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">10</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Given a set S of n integers and an integer T, give an O(n<sup>k − 1</sup>logn)
algorithm to test whether k of the integers in S add up to T.
</p>

<ol class="org-ol">
<li>O(nlogn）对数组排序
</li>
<li>(k-1)个数的组合有n<sup>k-1</sup>，并计算k-1个数的和sum
</li>
<li>用binary search在数组中搜索T-sum
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">11</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Design an O(n) algorithm that, given a list of n elements, finds all
the elements that appear more than n / 2 times in the list. Then,
design an O(n) algorithm that, given a list of n elements, finds all
the elements that appear more than n / 4 times.
</p>

<p>
Hash Table 可以解决。或
</p>
</div>

<div id="outline-container-sec-2-11-1" class="outline-4">
<h4 id="sec-2-11-1">Find the elements that appear more than n / 2 times</h4>
<div class="outline-text-4" id="text-2-11-1">
<p>
数组中最多有一个数超过重复n/2次，并且排序后的第ceiling(n/2)个数必定是这个数。
</p>
<ol class="org-ol">
<li>method1
<ul class="org-ul">
<li>利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Median%20Problem.html#sec-5">BFPRT</a> 以O(n)的复杂度找到第ceiling(n/2)个小数;
</li>
<li>扫描数组，计数这个数的重复数是否大于n/2.
</li>
</ul>
</li>
<li>method2
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stack&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">stack</span>;

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindMoreThanHalf</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">res</span>) {
  <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">stk</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">if</span> (stk.empty()) {
      stk.push(array[i]);
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">if</span> (stk.top() == array[i]) {
        stk.push(array[i]);
      } <span style="color: #00ffff;">else</span> {
        stk.pop();
      }
    }
  }
  <span style="color: #00ffff;">if</span> (stk.empty()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">candidate</span> = stk.top();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">times</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">if</span> (array[i] == candidate) {
      times++;
    }
  }
  <span style="color: #00ffff;">if</span> (times &gt; n / 2) {
    *res = candidate;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-11-2" class="outline-4">
<h4 id="sec-2-11-2">Find the elements that appear more than n / 4 times</h4>
<div class="outline-text-4" id="text-2-11-2">
<ul class="org-ul">
<li>method1
<ol class="org-ol">
<li>利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Median%20Problem.html#sec-5">BFPRT</a> 以O(n)的复杂度找到中间数，验证中中间数是否重复
n/4(O(n));
</li>
<li>以中间元素划分数组为两部分(O(n));
</li>
<li>在上下半部分n/2中重复n/4次数的元素，同第一个问题一样找(O(n));
</li>
</ol>
</li>
<li>method2
<ol class="org-ol">
<li>初始3个空的槽，想对应的槽的3个计数为0;
</li>
<li>对于数组中每个元素：
<ul class="org-ul">
<li>若等于其中任何一个槽中数，增加计数;
</li>
<li>若有槽空，放入这个槽，并计数为1;
</li>
<li>否则，对所有槽内数的计数减1
</li>
</ul>
</li>
<li>对槽内剩下的数，扫描一遍数组，计算它们重复次数是否符合要求。
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">12</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Devise an algorithm for finding the k smallest elements of an unsorted
set of n integers in O(n + klogn).
</p>

<ol class="org-ol">
<li>O(n)的复杂度建立一个最小堆;
</li>
<li>连续k次取出最小值，最后得到第k个最小值。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">13</h3>
<div class="outline-text-3" id="text-2-13">
<p>
You wish to store a set of n numbers in either a max-heap or a sorted
array. For each application below, state which data structure is
better, or if it does not matter. Explain your answers.
</p>

<ol class="org-ol">
<li>Want to find the maximum element quickly.
</li>
<li>Want to be able to delete an element quickly.
</li>
<li>Want to be able to form the structure quickly.
</li>
<li>Want to find the minimum element quickly.
</li>

<li>都开销O(1)。
</li>
<li>若知道删除的地方，max-heap花费O(logn)，sorted array花费O(n)。若不知道删除的地方，max-heap花费O(n)查找，删除花费O(logn); sorted
array binary search花费O(logn)，删除花费O(n)。
</li>
<li>max-heap花费O(n);sorted array花费O(logn)。
</li>
<li>max-heap花费O(n);sorted array花费O(1)。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">14</h3>
<div class="outline-text-3" id="text-2-14">
<p>
Give an O(nlogk)-time algorithm that merges k sorted lists with a
total of n elements into one sorted list. (Hint: use a heap to speed
up the elementary O(kn)-time algorithm).
</p>

<ol class="org-ol">
<li>扫描k组sorted lists组成一个大小k的min-heap;
</li>
<li>从min-heap中取出最小值放入结果list。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">15</h3>
<div class="outline-text-3" id="text-2-15">
<p>
(a) Give an efficient algorithm to find the second-largest key among n
keys. You can do better than 2n − 3 comparisons. (b) Then, give an
efficient algorithm to find the third-largest key among n keys. How
many key comparisons does your algorithm do in the worst case? Must
your algorithm determine which key is largest and second-largest in
the process?
</p>

<ul class="org-ul">
<li>找第二大元素：大小为2个的数组初始化为第一二个元素，之后每个元素与这数组对比，剔除最小的，最后数组内2个元组对比得到最大和第二大元素，一共比较2(n-2)+1=2n-3，找出第二大元素。
</li>
<li>找第三大元素：同样已大小为3的数组，最后比较数3(n-3)+2=3n-7。
</li>
</ul>

<p>
<a href="http://wiki.dreamrunner.org/public_htmlAlgorithms/Theory%20of%20Algorithms/Selection%20Problem.html#sec-4">Random Selection</a>可以找出任意的第几大值，平均时间复杂度：O(n)，比较次数将是n的倍数，最坏时间复杂度可以达到：O(nlogn)。
</p>

<p>
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Selection%20Problem.html#sec-6">Tournament Algorithm</a>找第二大元素比较次数O(n+logn);找第k个最大元素，比较次数为O(n+klogn)。
</p>
</div>
</div>

<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">16</h3>
<div class="outline-text-3" id="text-2-16">
<p>
Use the partitioning idea of quicksort to give an algorithm that
finds the median element of an array of n integers in expected O(n)
time. (Hint: must you look at both sides of the partition?)
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RandomSelectionK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  swap(array[l], array[randint(l, u)]);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pivot</span> = array[l];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = u + 1;
  <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; pivot);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; pivot);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array[i], array[j]);
  }
  swap(array[l], array[j]);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    RandomSelectionK(array, j + 1, u, k);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    RandomSelectionK(array, l, j - 1, k);
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-17" class="outline-3">
<h3 id="sec-2-17">17</h3>
<div class="outline-text-3" id="text-2-17">
The median of a set of n values is the $\lceil n/2 \rceil$ th smallest
value. <br />
1. Suppose quicksort always pivoted on the median of the current
   sub-array. How many comparisons would Quicksort make then in the
   worst case? <br />

2. Suppose quicksort were always to pivot on the $\lceil n/3 \rceil$ th
   smallest value of the current sub-array. How many comparisons would
   be made then in the worst case? <br />

<p>
f(n) = 2*f(n/2) + n ==&gt; f(n) = 2<sup>k</sup> * f(n/2<sup>k</sup>) + kn = (n+2)logn
f(n) = f(n/3) + f(2n/3) + n ==&gt; f(n) = O(nlogn)
</p>
</div>
</div>

<div id="outline-container-sec-2-18" class="outline-3">
<h3 id="sec-2-18">18</h3>
<div class="outline-text-3" id="text-2-18">
<p>
Suppose an array A consists of n elements, each of which is red,
white, or blue. We seek to sort the elements so that all the reds come
before all the whites, which come before all the blues The only
operation permitted on the keys are
</p>

<ul class="org-ul">
<li>Examine(A,i) &#x2013; report the color of the ith element of A.
</li>
<li>Swap(A,i,j) &#x2013; swap the ith element of A with the jth element.
</li>
</ul>
<p>
Find a correct and efficient algorithm for red-white-blue sorting.
There is a linear-time solution.
</p>

<p>
2次扫描。
</p>
<ul class="org-ul">
<li>第一次：把red和white当成一样，用quick的partition分开与blue。
</li>
<li>第二次：只区分red和white的子区间。   
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-19" class="outline-3">
<h3 id="sec-2-19">21</h3>
<div class="outline-text-3" id="text-2-19">
<p>
Stable sorting algorithms leave equal-key items in the same relative
order as in the original permutation. Explain what must be done to
ensure that mergesort is a stable sorting algorithm.
</p>

<p>
在合并时元素相等时选index小的元素在前。
</p>
</div>
</div>

<div id="outline-container-sec-2-20" class="outline-3">
<h3 id="sec-2-20">22-23</h3>
<div class="outline-text-3" id="text-2-20">
<p>
Show that n positive integers in the range 1 to k can be sorted in
O(nlogk) time. The interesting case is when k &lt; &lt; n.
</p>

<p>
We seek to sort a sequence S of n integers with many duplications,
such that the number of distinct integers in S is O(logn). Give an
O(nloglogn) worst-case time algorithm to sort such sequences.
</p>

<p>
balanced binary search tree.
</p>
</div>
</div>

<div id="outline-container-sec-2-21" class="outline-3">
<h3 id="sec-2-21">24</h3>
<div class="outline-text-3" id="text-2-21">
<p>
Let A[1..n] be an array such that the first \(n-\sqrt n\)  elements are
already sorted (though we know nothing about the remaining elements).
Give an algorithm that sorts A in substantially better than nlogn
steps.
</p>

+ $O(\sqrt{n}log(\sqrt{n})$ 排序后面的 $\sqrt{n}$ 个元素。<br />
+ O(n)去mergesort前半部分和后半部分。
</div>
</div>

<div id="outline-container-sec-2-22" class="outline-3">
<h3 id="sec-2-22">25</h3>
<div class="outline-text-3" id="text-2-22">
<p>
Assume that the array A[1..n] only has numbers from \(\{1,\ldots, n^2\}\)
but that at most loglogn of these numbers ever appear. Devise an
algorithm that sorts A in substantially less than O(nlogn).
</p>

<p>
和23一样，用balanced binary search tree，树的高度不超过loglogn,最后的复杂度O(n*logloglogn)。
</p>
</div>
</div>
<div id="outline-container-sec-2-23" class="outline-3">
<h3 id="sec-2-23">27</h3>
<div class="outline-text-3" id="text-2-23">
<p>
Let P be a simple, but not necessarily convex, polygon and q an
arbitrary point not necessarily in P. Design an efficient algorithm
to find a line segment originating from q that intersects the maximum
number of edges of P. In other words, if standing at point q, in what
direction should you aim a gun so the bullet will go through the
largest number of walls. A bullet through a vertex of P gets credit
for only one wall. An O(nlogn) algorithm is possible.
</p>

<ol class="org-ol">
<li>以ｑ为中心点，顺时针旋转，Ｐ中所有边随着顺时针旋转都有一个起始点
(head)和结束点（end），计算它们的极角（polar angle）; O(n)
</li>
<li>对所有head和end按照angle大小排序，若相等，head在前; O(nlogn)
</li>
<li>扫描这个排序好的队列，遇到head加1,遇到end减1,最后算出这个区间的最大值。O(n)
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-24" class="outline-3">
<h3 id="sec-2-24">30</h3>
<div class="outline-text-3" id="text-2-24">
<p>
A company database consists of 10,000 sorted names, 40% of whom are known as good customers and who together account for 60% of the accesses to the database. There are two data structure options to consider for representing the database:
</p>
<ol class="org-ol">
<li>Put all the names in a single array and use binary search.
</li>
<li>Put the good customers in one array and the rest of them in a
second array.
</li>
</ol>

<p>
Only if we do not find the query name on a binary search of the first
array do we do a binary search of the second array. Demonstrate which
option gives better expected performance. Does this change if linear
search on an unsorted array is used instead of binary search for both
options?
</p>

<ul class="org-ul">
<li>single array: log10000=4
</li>
<li>two array: 0.6*log4000+0.4*(log4000+log6000) = 5.11
</li>
</ul>
<p>
single array is better.
</p>

<ul class="org-ul">
<li>single array: 10000
</li>
<li>two array: 0.6*4000+0.4*6000 = 6400
</li>
</ul>
<p>
two array is better.
</p>
</div>
</div>
<div id="outline-container-sec-2-25" class="outline-3">
<h3 id="sec-2-25">31</h3>
<div class="outline-text-3" id="text-2-25">
<p>
Suppose you are given an array A of n sorted numbers that has been
circularly shifted k positions to the right. For example,
{35,42,5,15,27,29} is a sorted array that has been circularly shifted
k = 2 positions, while {27,29,35,42,5,15} has been shifted k = 4
positions.
</p>

<ol class="org-ol">
<li>Suppose you know what k is. Give an O(1) algorithm to find the
largest number in A.
</li>

<li>Suppose you do not know what k is. Give an O(lgn) algorithm to find
the largest number in A. For partial credit, you may give an O(n)
algorithm.
</li>
</ol>


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">if</span> (k == 0) {
  <span style="color: #00ffff;">return</span> A[n-1];
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">return</span> A[k-1];
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindLargestNumber</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span>) {
  <span style="color: #00ffff;">if</span> (array[l] &lt; array[h]) {
    <span style="color: #00ffff;">return</span> array[h];
  }
  <span style="color: #00ffff;">if</span> (l == h) {
    <span style="color: #00ffff;">return</span> array[h];
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span>;
  mid = (l + h) / 2;
  <span style="color: #00ffff;">if</span> ((mid + 1 &lt;= h) &amp;&amp; array[mid] &gt; array[mid + 1]) {
    <span style="color: #00ffff;">return</span> array[mid];
  }
  <span style="color: #00ffff;">if</span> ((mid - 1 &gt;= l) &amp;&amp; array[mid - 1] &gt; array[mid]) {
    <span style="color: #00ffff;">return</span> array[mid - 1];
  }
  <span style="color: #00ffff;">if</span> (array[mid] &lt; array[h]) {
    <span style="color: #00ffff;">return</span> FindLargestNumber(array, l, mid - 1);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> FindLargestNumber(array, mid + 1, h);
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-26" class="outline-3">
<h3 id="sec-2-26">32</h3>
<div class="outline-text-3" id="text-2-26">
<p>
Consider the numerical 20 Questions game. In this game, Player 1
thinks of a number in the range 1 to n. Player 2 has to figure out
this number by asking the fewest number of true/false questions.
Assume that nobody cheats.
</p>

<ol class="org-ol">
<li>What is an optimal strategy if n is known?
</li>
<li>What is a good strategy if n is not known?
</li>
</ol>


<ol class="org-ol">
<li>binary search.
</li>
<li>2<sup>i</sup>随机选一个i，若数小，增加到2<sup>i+1</sup>,若大就二分搜索。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-27" class="outline-3">
<h3 id="sec-2-27">33</h3>
<div class="outline-text-3" id="text-2-27">
<p>
Suppose that you are given a sorted sequence of distinct integers .
Give an O(lgn) algorithm to determine whether there exists an i index
such as ai = i. For example, in { − 10, − 3,3,5,7}, a3 = 3. In
{2,3,4,5,6,7}, there is no such i.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">CheckEqualIndex</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span>) {
  <span style="color: #00ffff;">while</span> (l &lt;= h) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (l + h) / 2;
    <span style="color: #00ffff;">if</span> (array[mid] &gt; (mid + 1)) {
      h = mid - 1;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (array[mid] &lt; (mid + 1)) {
      l = mid + 1;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-28" class="outline-3">
<h3 id="sec-2-28">34</h3>
<div class="outline-text-3" id="text-2-28">
<p>
Suppose that you are given a sorted sequence of distinct integers ,
drawn from 1 to m where n &lt; m. Give an O(lgn) algorithm to find an
integer  that is not present in a. For full credit, find the smallest
such integer.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindMissingElement</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span>) {
  <span style="color: #00ffff;">while</span> (l &lt;= h) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span> = (l + h) / 2;
    <span style="color: #00ffff;">if</span> (array[mid] &gt; (mid + 1)) {
      h = mid - 1;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (array[mid] &lt;= (mid + 1)) {
      l = mid + 1;
    }
  }
  <span style="color: #00ffff;">return</span> l + 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-29" class="outline-3">
<h3 id="sec-2-29">35</h3>
<div class="outline-text-3" id="text-2-29">
<p>
Let M be an n*m  integer matrix in which the entries of each row are
sorted in increasing order (from left to right) and the entries in
each column are in increasing order (from top to bottom). Give an
efficient algorithm to find the position of an integer x in M, or to
determine that x is not there. How many comparisons of x with matrix
entries does your algorithm use in worst case?
</p>

<p>
O(m+n)
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindElement</span>(<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pos_x</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pos_y</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0, <span style="color: #eedd82;">col</span> = m - 1;
  <span style="color: #00ffff;">while</span> (row &lt; n &amp;&amp; col &gt;= 0) {
    <span style="color: #00ffff;">if</span> (array[row][col] == x) {
      *pos_x = row;
      *pos_y = col;
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (array[row][col] &gt; x) {
      col--;
    } <span style="color: #00ffff;">else</span> {
      row++;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-30" class="outline-3">
<h3 id="sec-2-30">36</h3>
<div class="outline-text-3" id="text-2-30">
<p>
Consider an n*n  array A containing integer elements (positive, negative,
and zero). Assume that the elements in each row of A are in strictly
increasing order, and the elements of each column of A are in strictly
decreasing order. (Hence there cannot be two zeroes in the same row or
the same column.) Describe an efficient algorithm that counts the
number of occurrences of the element 0 in A. Analyze its running time.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">CountZero</span>(<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = n - 1, <span style="color: #eedd82;">col</span> = n - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0;
  <span style="color: #00ffff;">while</span> (row &gt;=0 &amp;&amp; col &gt;= 0) {
    <span style="color: #00ffff;">if</span> (array[row][col] == 0) {
      count++;
      row--;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(array[row][col] &gt; 0) {
      col--;
    } <span style="color: #00ffff;">else</span> {
      row--;
    }
  }
  <span style="color: #00ffff;">return</span> count;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-31" class="outline-3">
<h3 id="sec-2-31">40</h3>
<div class="outline-text-3" id="text-2-31">
<p>
If you are given a million integers to sort, what algorithm would you
use to sort them? How much time and memory would that consume?
</p>

<ol class="org-ol">
<li>一个整数４字节，10<sup>9</sup>*4=4G,需要4G的内存，可以用快排等O(nlogn)的排序算法．
</li>
<li>用bitmap,需要10<sup>9</sup>/8=128M的内存.
</li>
<li>若内存有限,就external merge sort,利用外部存储多进行几次.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-32" class="outline-3">
<h3 id="sec-2-32">41</h3>
<div class="outline-text-3" id="text-2-32">
<p>
Describe advantages and disadvantages of the most popular sorting
algorithms.
</p>

<p>
<b>Merge sort:</b>
</p>
<ul class="org-ul">
<li>优点:适合链表,适合外排.
</li>
<li>缺点:需要多余的内存来保存合并的数据.
</li>
</ul>

<p>
<b>Insertion/Selection sort:</b>
</p>
<ul class="org-ul">
<li>优点:简单实现.
</li>
<li>缺点:太慢,当数据很大时,运行不实际.
</li>
</ul>

<p>
<b>Heap sort:</b>
</p>
<ul class="org-ul">
<li>优点:不需要递归,适合大数据.
</li>
<li>缺点:时常慢于merge sort和quick sort.
</li>
</ul>

<p>
<b>Quick sort:</b>
</p>
<ul class="org-ul">
<li>优点:很快.
</li>
<li>缺点:递归,最坏情况比较慢.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-33" class="outline-3">
<h3 id="sec-2-33">42</h3>
<div class="outline-text-3" id="text-2-33">
<p>
Implement an algorithm that takes an input array and returns only the
unique elements in it.
</p>

<p>
排序,然后扫描输出.O(nlogn).
</p>
</div>
</div>
<div id="outline-container-sec-2-34" class="outline-3">
<h3 id="sec-2-34">43</h3>
<div class="outline-text-3" id="text-2-34">
<p>
You have a computer with only 2Mb of main memory. How do you use it to
sort a large file of 500 Mb that is on disk?
</p>

<p>
利用<a href="http://en.wikipedia.org/wiki/External_sorting">external merge sort</a>.
</p>
</div>
</div>

<div id="outline-container-sec-2-35" class="outline-3">
<h3 id="sec-2-35">44</h3>
<div class="outline-text-3" id="text-2-35">
<p>
Design a stack that supports push, pop, and retrieving the minimum
element in constant time. Can you do this?
</p>

<p>
只有一个stack办不到.如果两个stack,可以利用另外一个stack存储最小值.
</p>
</div>
</div>

<div id="outline-container-sec-2-36" class="outline-3">
<h3 id="sec-2-36">45</h3>
<div class="outline-text-3" id="text-2-36">
<p>
Given a search string of three words, find the smallest snippet of the
document that contains all three of the search words&#x2014;i.e., the
snippet with smallest number of words in it. You are given the index
positions where these words occur in the document, such as word1: (1,
4, 5), word2: (3, 9, 10), and word3: (2, 6, 15). Each of the lists are
in sorted order, as above.
</p>

<ol class="org-ol">
<li>选取每个字母index的首个元素作为起始方案。
</li>
<li>如何改进它的长度：a.增加最小的位置，b.减小最大的位置，这里只能增加最小的位置。
</li>
<li>用heap来保存位置，每次取出最小的位置为O(logk).
</li>
</ol>

<p>
复杂度：O(nlogk)，n是所有字母的位置个数，k是字母个数。这里k=3,所以O(n)
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;queue&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">priority_queue</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">make_pair</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">pair</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">max</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">min</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;limits&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">numeric_limits</span>;


<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindSmallestSnippet</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">index_positions</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">max-priority, select smallest position, use -index_positions[i][j], (i,j)</span>
  <span style="color: #98fb98;">priority_queue</span>&lt;<span style="color: #98fb98;">pair</span>&lt;<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">pair</span>&lt;<span style="color: #98fb98;">int</span> ,<span style="color: #98fb98;">int</span>&gt; &gt; &gt; <span style="color: #eedd82;">queue</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max_pos</span> = 0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the max pos of  the snippet</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; index_positions.size(); ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pos</span> = index_positions[i][0];
    max_pos = max(max_pos, pos);
    queue.push(make_pair(-pos, make_pair(i, 0)));
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">smallest_len</span> = <span style="color: #7fffd4;">numeric_limits</span>&lt;<span style="color: #98fb98;">int</span>&gt;::max();
  <span style="color: #00ffff;">while</span> (queue.size() == index_positions.size()) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_pos</span> = -queue.top().first;
    smallest_len = min(smallest_len, max_pos - min_pos + 1);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">word_pos</span> = queue.top().second.first;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span> = queue.top().second.second;
    queue.pop();
    ++index;
    <span style="color: #00ffff;">if</span> (index &lt; index_positions[word_pos].size()) {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next_pos</span> = index_positions[word_pos][index];
      max_pos = max(max_pos, next_pos);
      queue.push(make_pair(-next_pos, make_pair(word_pos, index)));
    }
  }
  <span style="color: #00ffff;">return</span> smallest_len;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-37" class="outline-3">
<h3 id="sec-2-37">46</h3>
<div class="outline-text-3" id="text-2-37">
<p>
You are given 12 coins. One of them is heavier or lighter than the
rest. Identify this coin in just three weighings.
</p>

<ol class="org-ol">
<li>分3组,每组4个,其中两组称重,若相等,重的在第三组.若不等,重的在重的那一组.
</li>
<li>重的那组分4组,每组1个,第一组和第二组称重,谁重就重的那个.
</li>
<li>若step2相等,剩下第三组和第四组称重,谁重就重的那个.
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 3]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/04/The-Algorithm-Design-Manual3/"/>
    <updated>2014-06-04T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/04/The-Algorithm-Design-Manual3</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Contiguous vs. Linked Data Structures</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Contiguously-allocated structuresare composed of single slabs of
memory, and include arrays, matrices, heaps, and hash tables.
</li>
<li>Linked data structuresare composed of distinct chunks of memory
bound together bypointers, and include lists, trees, and graph
adjacency lists.
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Arrays</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Advantages of contiguously-allocated arrays include:
</p>
<ul class="org-ul">
<li>Constant-time access given the index– Because the index of each
element maps directly to a particular memory address, we can access
arbitrary data items instantly provided we know the index.
</li>
<li>Space efficiency– Arrays consist purely of data, so no space is
wasted with links or other formatting information. Further,
end-of-record information is not needed because arrays are built
from fixed-size records.
</li>
<li>Memory locality– A common programming idiom involves iterating
through all the elements of a data structure. Arrays are good for
this because they exhibit excellent memory locality. Physical
continuity between successive data accesses helps exploit the
high-speedcache memory on modern computer architectures.
</li>
</ul>

<p>
The downside of arrays is that we cannot adjust their size in the middle of
a program’s execution.
</p>

<p>
Actually, we can efficiently enlarge arrays as we need them, through the miracle
of dynamic arrays. The apparent waste in this procedure involves the recopying of the old contents
on each expansion. Thus, each of thenelements move only two times on average, and the total work
of managing the dynamic array is the sameO(n) as it would have been if a single
array of sufficient size had been allocated in advance! The primary thing lost using dynamic arrays is the guarantee that each array
access takes constant time <i>in the worst case</i>.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Pointers and Linked Structures</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The relative advantages of linked lists over static arrays include:
</p>
<ul class="org-ul">
<li>Overflow on linked structures can never occur unless the memory is
actually full.
</li>
<li>Insertions and deletions aresimplerthan for contiguous (array)
lists.
</li>
<li>With large records, moving pointers is easier and faster than moving
the items themselves.
</li>
</ul>

<p>
while the relative advantages of arrays include:
</p>
<ul class="org-ul">
<li>Linked structures require extra space for storing pointer fields.
</li>
<li>Linked lists do not allow efficient random access to items.
</li>
<li>Arrays allow better memory locality and cache performance than
random pointer jumping.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A common problem for compilers and text editors is determining whether the
parentheses in a string are balanced and properly nested. For example, the string
((())())() contains properly nested pairs of parentheses, which the strings )()( and
()) do not. Give an algorithm that returns true if a string contains properly nested
and balanced parentheses, and false if otherwise. For full credit, identify the position
of the first offending parenthesis if the string is not properly
nested and balanced.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">string</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stack&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">stack</span>;

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">BalancedParentheses</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">parentheses</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pos</span>) {
  <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">stk</span>;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLeftPar</span> = 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; parentheses.size(); ++i) {
    <span style="color: #00ffff;">if</span> (parentheses[i] == <span style="color: #ffa07a;">'('</span>) {
      stk.push(kLeftPar);
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">if</span> (stk.empty()) {
        *pos = i;
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
      }
      stk.pop();
    }
  }
  <span style="color: #00ffff;">if</span> (!stk.empty()) {
    *pos = --i;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Write a program to reverse the direction of a given singly-linked list. In other
words, after the reversal all pointers should now point backwards. Your algorithm
should take linear time.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">next</span>;
  <span style="color: #87cefa;">Node</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">in_value</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #eedd82;">in_next</span>) : value(in_value), <span style="color: #98fb98;">next</span>(<span style="color: #eedd82;">in_next</span>) {
  }
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseLinkedList</span>(<span style="color: #98fb98;">Node</span> **<span style="color: #eedd82;">head</span>) {
  <span style="color: #00ffff;">if</span> (!head || *head == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">prev</span>, *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">next</span>;
  prev = *head;
  p = prev-&gt;next;
  prev-&gt;next = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    next = p-&gt;next;
    p-&gt;next = prev;
    prev = p;
    p = next;
  }
  *head = prev;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We have seen how dynamic arrays enable arrays to grow while still achieving
constant-time amortized performance. This problem concerns extending dynamic
arrays to let them both grow and shrink on demand.
</p>

<p>
(a) Consider an underflow strategy that cuts the array size in half whenever the
array falls below half full. Give an example sequence of insertions and deletions
where this strategy gives a bad amortized cost.
</p>

<p>
(b) Then, give a better underflow strategy than that suggested above, one that
achieves constant amortized cost per deletion.
</p>

<ol class="org-ol">
<li>容量是6的数组，当有3个元素是，insertion，然后delete。它不断收缩和扩展容量。
</li>
<li>当元素个数是总个数的1/4时，把容量收缩成1/2。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Design a dictionary data structure in which search, insertion, and deletion can
all be processed inO(1) time in the worst case. You may assume the set elements
are integers drawn from a finite set 1,2, .., n, and initialization
can take O(n)time.
</p>

<p>
因为元素个数是有限集合中的数，用bit array 表示每个数。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Find the overhead fraction (the ratio of data space over total space) for each
of the following binary tree implementations on n nodes:
</p>

<p>
(a) All nodes store data, two child pointers, and a parent pointer. The data field
requires four bytes and each pointer requires four bytes.
</p>

<p>
(b) Only leaf nodes store data; internal nodes store two child pointers. The data
field requires four bytes and each pointer requires two bytes.
</p>

<ol class="org-ol">
<li>所有点都一样： 4/(4+4*3) = 1/4
</li>
<li>满树中，若页节点个数是n，那么内部节点个数是n-1,
4*n/(4*n + 4*(n-1)) = n/(2n-1)
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Describe how to modify any balanced tree data structure such that search,
insert, delete, minimum, and maximum still take O(logn) time each, but successor
and predecessor now take O(1) time each. Which operations have to be modified
to support this?
</p>

<p>
在树节点中添加指向successor和predecessor的指针。不影响操作search,
minimum, 和 maximum。只需在insert和delete操作相应更新指向successor和predecessor的指针。
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Suppose you have access to a balanced dictionary data structure, which
supports each of the operations search, insert, delete, minimum,
maximum, successor, and predecessor in O(logn) time. Explain how to
modify the insert and delete operations so they still take O(logn) but
now minimum and maximum take O(1) time. (Hint: think in terms of using
the abstract dictionary operations, instead of mucking about with
pointers and the like.)
</p>

<p>
存储max和min这两个数。
</p>
<ul class="org-ul">
<li>insert时，新元素与这个两数对比并相应更新。
</li>
<li>delete时，若是min元素被delete，用它的successor更新；若是max元素被
delete，用它的predecessor更新。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Design a data structure to support the following operations:
</p>
<ul class="org-ul">
<li>insert(x,T) – Insert item x into the set T.
</li>
<li>delete(k,T) – Delete the kth smallest element from T.
</li>
<li>member(x,T) – Return true iff x∈T.
</li>
</ul>
<p>
All operations must take O(logn) time on an n-element set.
</p>

<p>
Balanced binary tree.
</p>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">9</h3>
<div class="outline-text-3" id="text-2-9">
<p>
A concatenate operation takes two sets S1 and S2, where every key in S1
is smaller than any key in S2, and merges them together. Give an
algorithm to concatenate two binary search trees into one binary
search tree. The worst-case running time should be O(h), where h is the
maximal height of the two trees.
</p>

<p>
S1中的所有元素小于S2,用O（logn）的时间找出S2的最小元素，然后S1成为它的左子树，S2成为它的右子树，组成新的搜索树。
</p>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">10</h3>
<div class="outline-text-3" id="text-2-10">
<p>
In the bin-packing problem, we are given n metal objects, each weighing
between zero and one kilogram. Our goal is to find the smallest number
of bins that will hold the n objects, with each bin holding one
kilogram at most.
</p>

<ul class="org-ul">
<li>The best-fit heuristicfor bin packing is as follows. Consider the
objects in the order in which they are given. For each object, place
it into the partially filled bin with the smallest amount of extra
room after the object is inserted.. If no such bin exists, start a new
bin. Design an algorithm that implements the best-fit heuristic
(taking as input the n weights w1,w2, &#x2026;, wn and outputting the
number of bins used) in O(nlogn)time.
</li>

<li>Repeat the above using the worst-fit heuristic, where we put the next
object in the partially filled bin with the largest amount of extra
room after the object is inserted.
</li>
</ul>

<p>
使用BST。主要找到能容纳这个元素的最小bin，若所有bin都小于这个元素大小，就插入一个新的。
</p>
<div class="org-src-container">

<pre class="src src-c++">min_node = <span style="color: #7fffd4;">NULL</span>;
<span style="color: #00ffff;">while</span> node != <span style="color: #7fffd4;">NULL</span>:
    <span style="color: #00ffff;">if</span> (node-&gt;weight &gt;= w &amp;&amp; node-&gt;left &lt; w) {
      min_node = node;
      <span style="color: #00ffff;">break</span>;
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (node-&gt;left &gt;= w) {
      node = node-&gt;left;
    } <span style="color: #00ffff;">else</span> {
      node = node-&gt;right;
    }
<span style="color: #00ffff;">if</span> (min_node == <span style="color: #7fffd4;">NULL</span>) {
  bst-&gt;insert(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">node</span>(w));
} <span style="color: #00ffff;">else</span> {
  bst-&gt;<span style="color: #00ffff;">delete</span>(min_node);
  min_node-&gt;weight -= w;
  bst-&gt;insert(min_node);
}
</pre>
</div>

<p>
最大堆使用。每次选最大容量的bin。若最大bin小于这个元素大小，就插入一个新的。
</p>
</div>
</div>

<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">11</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Suppose that we are given a sequence of n values x1,x2, &#x2026;, xn and seek
to quickly answer repeated queries of the form: given i and j, find the
smallest value in xi,&#x2026;,xj.
</p>

<p>
(a) Design a data structure that uses O(n<sup>2</sup>) space and answers queries in O(1)
time.
</p>

<p>
(b) Design a data structure that uses O(n) space and answers queries
in O(logn) time. For partial credit, your data structure can
use O(nlogn) space and have O(logn) query time.
</p>

<ol class="org-ol">
<li>n*n的矩阵，i,j中存的就是i-j的最小元素。
</li>

<li>使用<a href="http://en.wikipedia.org/wiki/Cartesian_tree">Cartesian tree</a>或<a href="http://en.wikipedia.org/wiki/Treap">Treap</a>。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">12</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Suppose you are given an input set S of n numbers, and a black box
that if given any sequence of real numbers and an integer k instantly
and correctly answers whether there is a subset of input sequence
whose sum is exactly k. Show how to use the black box O(n) times to
find a subset of S that adds up to k.
</p>

<div class="org-src-container">

<pre class="src src-c++">R = S
<span style="color: #00ffff;">for</span> i = 1 to n:
  <span style="color: #00ffff;">if</span> bb(R/{si}) <span style="color: #98fb98;">is</span> <span style="color: #eedd82;">True</span>:
      R = R / {si}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">13</h3>
<div class="outline-text-3" id="text-2-13">
<p>
Let A[1..n] be an array of real numbers. Design an algorithm to perform
any sequence of the following operations:
</p>

<p>
• Add(i,y)– Add the value y to the ith number.
</p>

<p>
• Partial-sum(i)– Return the sum of the first i numbers
</p>

<p>
There are no insertions or deletions; the only change is to the values
of the numbers. Each operation should take O(logn) steps. You may use
one additional array of size n as a work space.
</p>

<p>
建立叶节点数ｎ的balanced binary tree，ｎ个叶节点依次存储A[1..n]，书的内节点存储子树的和。
</p>
<ol class="org-ol">
<li>Add(i,y)，比较ｉ与n/2，决定左子树还是右子树，依次遍历到叶节点，并增加相应子树和，最后找到第ｉ个元素相加。
</li>
<li>Partial-sum(i)，比较ｉ与n/2，决定左子树还是右子树，每当遍历右子树，加上左子树的和，最后到叶节点，得到总的和。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">14</h3>
<div class="outline-text-3" id="text-2-14">
<p>
Extend the data structure of the previous problem to support insertions and
deletions. Each element now has both a key and a value. An element is accessed
by its key. The addition operation is applied to the values, but the
elements are accessed by its key. The Partial sum operation is
different.
</p>

<ul class="org-ul">
<li>Add(k,y)– Add the value y to the item with key k.
</li>
<li>Insert(k,y)– Insert a new item with key k and value y.
</li>
<li>Delete(k)– Delete the item with key k.
</li>
<li>Partial-sum(k)– Return the sum of all the elements currently in the
set whose key is less than y,
</li>
</ul>

<p>
The worst case running time should still be O(nlogn) for any sequence
of O(n) operations.
</p>

<p>
建立以key排序的平衡搜索二叉树，并每个节点中添加一个左子树和的值。
</p>

<ul class="org-ul">
<li>Add(k,y)：随着搜索key k，依次加左子树和，最后key k加上y。
</li>
<li>Insert(k,y)：随着搜索key k插入位置，依次加左子树和，最后插入key k的元素。
</li>
<li>Delete(k)：：随着搜索key k，依次减少左子树和，最后删除key k元素。
</li>
<li>Partial-sum(k)：随着搜索key k，依次加上左子树的和（因为左边的元素是小于的元素）。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">15</h3>
<div class="outline-text-3" id="text-2-15">
<p>
Design a data structure that allows one to search, insert, and delete
an integer X in O(1) time (i.e. , constant time, independent of the
total number of integers stored). Assume that 1≤X≤n and that there
are m+n units of space available, where m is the maximum number of
integers that can be in the table at any one time. (Hint: use two
arrays A[1..n] and B[1..m].) You are not allowed to initialize
either A or B, as that would take O(m) or O(n) operations. This means
the arrays are full of random garbage to begin with, so you must be
very careful.
</p>

<p>
与<a href="http://dreamrunner.org/blog/2014/05/10/column1/">Programming Pearls</a>的Column课后题一样。
</p>

<p>
建立两个数组A[1..n]，B[1..m]和一个表示元素个数的变量k。
</p>

<ol class="org-ol">
<li>insert X: k = k + 1，A[X] = k, B[k] = X;
</li>
<li>search X: return (A[X] &lt;= k) &amp;&amp; B[A[X]] == X;
</li>
<li>delete X: 把A[X]与末端A[B[k]]交换，A[B[k]] = A[X], B[A[X]] = B[k];
k = k - 1;
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">18</h3>
<div class="outline-text-3" id="text-2-16">
<p>
What method would you use to look up a word in a dictionary?
</p>

<p>
Hash Table.
</p>
</div>
</div>

<div id="outline-container-sec-2-17" class="outline-3">
<h3 id="sec-2-17">19</h3>
<div class="outline-text-3" id="text-2-17">
<p>
Imagine you have a closet full of shirts. What can you do to organize
your shirts for easy retrieval?
</p>

<p>
以颜色排序，并二分搜索查找。
</p>
</div>
</div>
<div id="outline-container-sec-2-18" class="outline-3">
<h3 id="sec-2-18">20</h3>
<div class="outline-text-3" id="text-2-18">
<p>
Write a function to find the middle node of a singly-linked list.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">next</span>;
};

<span style="color: #98fb98;">Node</span>* <span style="color: #87cefa;">FindMidNode</span>(<span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">head</span>) {
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">q</span>;
  p = head;
  q = head;
  i = 0;
  <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    i++;
    p = p-&gt;next;
    <span style="color: #00ffff;">if</span> (i == 2) {
      q = q-&gt;next;
      i = 0;
    }
  }
  <span style="color: #00ffff;">return</span> q;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-19" class="outline-3">
<h3 id="sec-2-19">21</h3>
<div class="outline-text-3" id="text-2-19">
<p>
Write a function to compare whether two binary trees are identical.
Identical trees have the same key value at each position and the same
structure.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">left</span>;
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">right</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">CompareBinaryTree</span>(<span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">head_m</span>, <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">head_n</span>) {
  <span style="color: #00ffff;">if</span> (head_m == <span style="color: #7fffd4;">NULL</span> &amp;&amp; head_n == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #00ffff;">if</span> (head_m == <span style="color: #7fffd4;">NULL</span> || head_n == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> (head_m-&gt;value == head_n-&gt;value) &amp;&amp;
      CompareBinaryTree(head_m-&gt;left, head_n-&gt;left) &amp;&amp;
      CompareBinaryTree(head_m-&gt;right, head_n-&gt;right);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-20" class="outline-3">
<h3 id="sec-2-20">22</h3>
<div class="outline-text-3" id="text-2-20">
<p>
Write a program to convert a binary search tree into a linked list
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">next</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">TNode</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>;
  <span style="color: #98fb98;">TNode</span> *<span style="color: #eedd82;">left</span>;
  <span style="color: #98fb98;">TNode</span> *<span style="color: #eedd82;">right</span>;
  <span style="color: #87cefa;">TNode</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value_in</span>) {
    value = value_in;
    left = <span style="color: #7fffd4;">NULL</span>;
    right = <span style="color: #7fffd4;">NULL</span>;
  }
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">InsertToList</span>(<span style="color: #98fb98;">Node</span> **<span style="color: #eedd82;">head</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">value</span>) {
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">new_node</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Node</span>;
  new_node-&gt;value = value;
  new_node-&gt;next = *head;
  *head = new_node;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ConvertTreeToList</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">TNode</span> *<span style="color: #eedd82;">root</span>, <span style="color: #98fb98;">Node</span> **<span style="color: #eedd82;">head</span>) {
  <span style="color: #00ffff;">if</span> (root == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  }
  ConvertTreeToList(root-&gt;right, head);
  InsertToList(head, root-&gt;value);
  ConvertTreeToList(root-&gt;left, head);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-21" class="outline-3">
<h3 id="sec-2-21">23</h3>
<div class="outline-text-3" id="text-2-21">
<p>
Implement an algorithm to reverse a linked list. Now do it without
recursion.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseLinkedList</span>(<span style="color: #98fb98;">Node</span> **<span style="color: #eedd82;">head</span>) {
  <span style="color: #00ffff;">if</span> (!head || *head == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">Node</span> *<span style="color: #eedd82;">prev</span>, *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">next</span>;
  prev = *head;
  p = prev-&gt;next;
  prev-&gt;next = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    next = p-&gt;next;
    p-&gt;next = prev;
    prev = p;
    p = next;
  }
  *head = prev;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-22" class="outline-3">
<h3 id="sec-2-22">24</h3>
<div class="outline-text-3" id="text-2-22">
<p>
What is the best data structure for maintaining URLs that have been visited by
a Web crawler? Give an algorithm to test whether a given URL has already been
visited, optimizing both space and time.
</p>

<p>
Hash Table.
</p>
</div>
</div>
<div id="outline-container-sec-2-23" class="outline-3">
<h3 id="sec-2-23">26</h3>
<div class="outline-text-3" id="text-2-23">
<p>
Reverse the words in a sentence—i.e., “My name is Chris” becomes “Chris is
name My.” Optimize for time and space.
</p>

<ol class="org-ol">
<li>reverse 每个单词;
</li>
<li>reverse 整句。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Reverse</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">begin</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">end</span>) {
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">while</span> (begin &lt; end) {
    temp = *begin;
    *begin = *end;
    *end = temp;
    begin++;
    end--;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseWords</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word_begin</span>;
  word_begin = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  p = str;
  <span style="color: #00ffff;">while</span> (*p != <span style="color: #ffa07a;">'\0'</span>) {
    <span style="color: #00ffff;">if</span> (word_begin == <span style="color: #7fffd4;">NULL</span> &amp;&amp; *p != <span style="color: #ffa07a;">' '</span>) {
      word_begin = p;
    }
    <span style="color: #00ffff;">if</span> (word_begin != <span style="color: #7fffd4;">NULL</span> &amp;&amp; (*(p+1) == <span style="color: #ffa07a;">' '</span> || *(p+1) == <span style="color: #ffa07a;">'\0'</span>)) {
      Reverse(word_begin, p);
      word_begin = <span style="color: #7fffd4;">NULL</span>;
    }
    ++p;
  }
  Reverse(str, p - 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-24" class="outline-3">
<h3 id="sec-2-24">27</h3>
<div class="outline-text-3" id="text-2-24">
<p>
Determine whether a linked list contains a loop as quickly as possible
without using any extra storage. Also, identify the location of the
loop.
</p>

<p>
利用两个指针，一个快指针和一个慢指针，快的每次都比慢的多前进一个节点，如果存在loop,快的总会与慢的相重叠。
</p>

<p>
loop的起始点：
</p>
<ol class="org-ol">
<li>当快的与慢的指针相重叠时，验证有loop，之后慢的指针不动，通过快的指针计算出loop的长度
</li>
<li>重新从链表头开始，快指针比慢指针先前进loop的长度距离，提增慢和快指针，直到第一次相遇，相遇点就是loop的起始点。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-25" class="outline-3">
<h3 id="sec-2-25">28</h3>
<div class="outline-text-3" id="text-2-25">
<p>
You have an unordered array X of n integers. Find the array M containing
n elements where Mi is the product of all integers in X except for Xi. You may
not use division. You can use extra memory. (Hint: There are solutions
faster than O(n<sup>2</sup>).)
</p>

<p>
对数组X扫描2次计算出如下2组数组：
</p>

$$
\begin{align}
P_{0} = 1; P_{k}=X_{k}P_{k-1}=\prod_{i=1}^{k}X_{i} \newline
Q_{n+1} = 1; Q_{k}=X_{k}Q_{k+1}=\prod_{i=k}^{n}X_{i}
\end{align}
$$


<p>
所以得到M：
</p>

$$
\begin{align}
M_{i} = P_{i-1} Q_{i+1}, i\in[1,n]
\end{align}
$$
</div>
</div>
<div id="outline-container-sec-2-26" class="outline-3">
<h3 id="sec-2-26">29</h3>
<div class="outline-text-3" id="text-2-26">
<p>
Give an algorithm for finding an ordered word pair (e.g., “New
York”) occurring with the greatest frequency in a given webpage.
Which data structures would you use? Optimize both time and space.
</p>

<p>
Hash Table.
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Last Thing D Needs总结]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie/"/>
    <updated>2014-06-01T16:24:47+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#initialization">Initialization</a></li>
  <li><a href="#type-deduction">Type Deduction</a></li>
  <li><a href="#inheritance">Inheritance</a></li>
  <li><a href="#computational-complexity">Computational Complexity</a></li>
  <li><a href="#apis">APIs</a></li>
  <li><a href="#specifications">Specifications</a></li>
  <li><a href="#essential-and-accidental-complexity">Essential and Accidental Complexity</a></li>
</ul>

<p><a href="http://www.amazon.com/gp/product/0321334876?ie=UTF8&amp;tag=aristeia.com-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321334876">Effective C++</a>
系列的作者<a href="http://www.aristeia.com/">Scott Meyers</a>在Dconf中<a href="http://www.ustream.tv/recorded/47947981">The Last Thing D Needs</a>聊了些C++的
特性，稍微总结一下。</p>

<h2 id="initialization">Initialization</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Initialization</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="n">x1</span><span class="p">;</span>         <span class="c1">// unknown, initial(pay for it)</span>
</span><span class="line"><span class="kt">int</span> <span class="n">x2</span><span class="p">;</span>         <span class="c1">// (at global scope) 0, no run time cost</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">;</span>  <span class="c1">// 0, static initialization</span>
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>  <span class="c1">// heap memory, unknown, has run time cost</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x4</span><span class="p">;</span>    <span class="c1">// unknown, has run time cost </span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="c1">// unknown</span>
</span><span class="line"><span class="kt">int</span> <span class="n">a2</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="c1">// (at global scope) 0</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  <span class="c1">// 0</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>  <span class="c1">// 0, use run time cost</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!-- more -->

<h2 id="type-deduction">Type Deduction</h2>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Type Deduction</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">auto</span> <span class="n">my_cx1</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>          <span class="c1">// int, new independent value</span>
</span><span class="line"><span class="n">decltype</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span> <span class="n">my_cx2</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>  <span class="c1">// const int, standard said</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="n">typname</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span><span class="line"><span class="n">f1</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                    <span class="c1">// T&#39;s type, int, same rules with auto</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span><span class="line"><span class="n">f2</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                   <span class="c1">//T&#39;s type, const int, reference a chunk of memory, preserve the const</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span><span class="line"><span class="n">f3</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                  <span class="c1">//T&#39;s type, const int&amp;, perfect argument forwarding, a special rule</span>
</span><span class="line">
</span><span class="line"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">auto</span> <span class="n">lam</span><span class="o">=</span> <span class="p">[</span><span class="n">cx</span><span class="p">]</span> <span class="p">{</span><span class="n">cx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;};</span>       <span class="c1">//error!</span>
</span><span class="line"><span class="k">class</span> <span class="nc">UpToTheCompiler</span> <span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="o">???</span> <span class="n">cx</span><span class="p">;</span>                      <span class="c1">//const int</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">auto</span> <span class="n">lam</span><span class="o">=</span> <span class="p">[</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">]</span> <span class="p">{</span><span class="n">cx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;};</span>     <span class="c1">//error!</span>
</span><span class="line"><span class="k">class</span> <span class="nc">UpToTheCompiler</span> <span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="o">???</span> <span class="n">cx</span><span class="p">;</span>                          <span class="c1">//int (but acts like const int)</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="k">const</span>
</span><span class="line">  <span class="p">{</span><span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">auto</span> <span class="n">lam1</span><span class="o">=</span> <span class="p">[</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">]</span> <span class="k">mutable</span> <span class="p">{</span><span class="n">cx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;};</span>     <span class="c1">//error!</span>
</span><span class="line"><span class="k">auto</span> <span class="n">lam2</span><span class="o">=</span> <span class="p">[</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cx</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span><span class="n">cx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;};</span>     <span class="c1">//correct</span>
</span><span class="line"><span class="k">class</span> <span class="nc">UpToTheCompiler</span> <span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="o">???</span> <span class="n">cx</span><span class="p">;</span>                          <span class="c1">//int (but acts like int)</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>For</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">const int cx = 0;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>type deduction for cx yields:</p>

<style>
table,th,td
{
border:1px solid black;
}
</style>

<table border="1" style="width:500px">
<tr>
<th> Context </th>
<th> Type </th>
</tr>

<tr>
<td> auto </td>
<td> int </td>
</tr>

<tr>
<td> decltype </td>
<td>  const int</td>
</tr>

<tr>
<td> template(T parameter)  </td>
<td> int </td>
</tr>

<tr>
<td> template(T&amp; parameter)  </td>
<td> const int </td>
</tr>

<tr>
<td> template(T&amp;&amp; parameter)  </td>
<td> const int&amp; </td>
</tr>

<tr>
<td> lambda (by-value capture) </td>
<td> const int  </td>
</tr>

<tr>
<td> lambda (int capture) </td>
<td>  int</td>
</tr>
</table>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Type Deduction</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="c1">//all do the same thing</span>
</span><span class="line"><span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">x2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="kt">int</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="n">x4</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">auto</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// int</span>
</span><span class="line"><span class="k">auto</span> <span class="n">x2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// int</span>
</span><span class="line"><span class="k">auto</span> <span class="n">x3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="c1">// initializer_list&lt;int&gt;</span>
</span><span class="line"><span class="k">auto</span> <span class="n">x4</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <span class="c1">// initializer_list&lt;int&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="n">typname</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span><span class="line"><span class="n">f</span><span class="p">({</span><span class="mi">0</span><span class="p">});</span>       <span class="c1">// error! &quot;{0}&quot; has no type</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="inheritance">Inheritance</h2>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>inheritance</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doBaseWork</span><span class="p">();</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doDerivedWord</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="n">doBaseWord</span><span class="p">();</span>               <span class="c1">//ok</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doBaseWork</span><span class="p">();</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doDerivedWord</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="n">doBaseWord</span><span class="p">();</span>               <span class="c1">//no compile, later specialized version</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Base</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">();</span>  <span class="c1">// no doBasework</span>
</span><span class="line">
</span><span class="line"><span class="n">Derived</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line"><span class="n">d</span><span class="p">.</span><span class="n">doDerivedWord</span><span class="p">();</span>  <span class="c1">// fail</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In essence, the <strong>One Definition Rule</strong> states that the same entity should have the exact same definition throughout an application, otherwise the effects are undefined.</p>

<p>The fundamental problem is that the code that doesn’t see the specialized version of your class template member function might still compile, is likely to link, and sometimes might even run. This is because in the absence of (a forward declaration of) the explicit specialization, the non-specialized version kicks in, likely implementing a generic functionality that works for your specialized type as well.</p>

<h2 id="computational-complexity">Computational Complexity</h2>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>computational Complexity</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>   <span class="c1">// O(nlogn)</span>
</span><span class="line">
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span><span class="p">;</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">li</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">li</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">// not compile, list doesnot have random access iterator</span>
</span><span class="line">
</span><span class="line"><span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// O(logn)</span>
</span><span class="line">
</span><span class="line"><span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span>
</span><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">li</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">li</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// O(n), officially(number of compares): O(logn)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="apis">APIs</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>example</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">si</span><span class="p">;</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">si</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>    <span class="c1">// eliminate all 14s from si</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>set             –&gt;  erase</li>
  <li>multiset        –&gt;     erase</li>
  <li>map             –&gt;     erase</li>
  <li>multimap        –&gt;     erase</li>
  <li>unordered_set   –&gt;     erase</li>
  <li>unordered_multiset –&gt;  erase</li>
  <li>unordered_map      –&gt;  erase</li>
  <li>unordered_multimap –&gt;  erase</li>
  <li>list               –&gt;  remove</li>
  <li>forward_list       –&gt;  remove</li>
</ul>

<p>Sorts can be stable or unstable. Which are guaranteed to be stable?
* sort –&gt; not guaranteed
* stable_sort  –&gt; guaranteed
* list::sort –&gt; guaranteed</p>

<h2 id="specifications">Specifications</h2>
<p>Five sequence containers:</p>

<ul>
  <li>array –&gt; No</li>
  <li>deque –&gt; Yes</li>
  <li>forward_list  –&gt; No(fulfill of 1 of 16)</li>
  <li>list  –&gt; Yes</li>
  <li>vector – &gt; Yes</li>
</ul>

<h2 id="essential-and-accidental-complexity">Essential and Accidental Complexity</h2>
<p>Essential Complexity: due to inherent design tensions.</p>

<ul>
  <li>Simplicity and regularity vs expressiveness.</li>
  <li>Abstraction and portability vs efficiency.</li>
  <li>New approaches vs compatibility with legacy systems.</li>
  <li>Expressiveness vs ability to issue good diagnostics.</li>
</ul>

<p><em>Essential Complexity</em></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Point</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>What is the type of Point::x?</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Point</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Point</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line"><span class="k">const</span> <span class="n">Point</span> <span class="o">&amp;</span><span class="n">cp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>What is the type of cp.x?</p>

<p>C++ soluction:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">decltype</span><span class="p">(</span><span class="n">cp</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">int</span>
</span><span class="line"><span class="n">decltype</span><span class="p">((</span><span class="n">cp</span><span class="p">.</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>inheritance</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doBaseWork</span><span class="p">();</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">doDerivedWord</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="n">doBaseWrd</span><span class="p">();</span>               <span class="c1">//okay?</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Assume typo and diagnose now?</p>

<ul>
  <li>Wrong if later specialization offers doBaseWrk.</li>
</ul>

<p>Assume later specialization and defer lookup until instantiation?</p>

<ul>
  <li>If typo, imposes diagnostics for library errors on clients.</li>
</ul>

<p>C++ solution:</p>

<ul>
  <li>Template author has control
    <ul>
      <li>doBaseWrk() -&gt; lookup name when parsing template.</li>
      <li>this-&gt;doBaseWrk() -&gt; lookup name when instantiating template.</li>
    </ul>
  </li>
</ul>

<p><em>Accidental Complexity</em></p>

<ul>
  <li>ints are sometimes initialized to 0.</li>
  <li>By-value lambda capture somtimes retains the constness of what’s captured.</li>
  <li>mutable lambdas must declare a parameter list, but non-mutable lambdas don’t</li>
  <li>Braced initializers (e.g.”{0}”) sometimes have a type.</li>
  <li>Computation complexity guarantees usually meaningful.</li>
  <li>Elimination all container elements with a given value usually means
calling <code>erase</code>.</li>
  <li><code>sort</code> is sometimes stable.</li>
  <li>Container “requirements” are sometimes required.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 2]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/29/The-Algorithm-Design-Manual2/"/>
    <updated>2014-05-29T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/29/The-Algorithm-Design-Manual2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
<p>
Our two most important tools are (1) the RAM model of
computation and (2) the asymptotic analysis of worst-case complexity.
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
What value is returned by the following function? Express your answer
as a function of n. Give the worst-case running time using the Big Oh
notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">mystery</span>(n)
      <span style="color: #b0c4de;">r</span>:=0
      <span style="color: #00ffff;">for</span> i:=1 to n-1 do
          <span style="color: #00ffff;">for</span> j:=i+1 to n do
              <span style="color: #00ffff;">for</span> k:=1 to j do
                  <span style="color: #b0c4de;">r</span>:=r+1
       <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>

$$
\begin{align}
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\sum_{k=1}^{j}1 = 
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}j =
\sum_{i=1}^{n-1}(\sum_{j=1}^{n}j - \sum_{j=1}^{i}j) = \newline 
\sum_{i=1}^{n-1}(\frac{n(n+1)}{2} - \frac{i(i+1)}{2} = 
\frac{1}{2}\sum_{i=1}^{n-1}(n^2+n-i^2-i) = \newline 
\frac{1}{2}((n-1)n^2+(n-1)n-(\frac{n(n+1)(2n+1)}{6}-n^2)-(\frac{n(n+1)}{2}-n))
\end{align}
$$

<p>
Time: O(n<sup>3</sup>)
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">pesky</span>(n)
      <span style="color: #b0c4de;">r</span>:=0
      <span style="color: #00ffff;">for</span> i:=1 to n do
          <span style="color: #00ffff;">for</span> j:=1 to i do
              <span style="color: #00ffff;">for</span> k:=j to i+j do
                  <span style="color: #b0c4de;">r</span>:=r+1
      <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>

\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}


<p>
Time: O(n<sup>3</sup>).
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">prestiferous</span>(n)
       <span style="color: #b0c4de;">r</span>:=0
       <span style="color: #00ffff;">for</span> i:=1 to n do
           <span style="color: #00ffff;">for</span> j:=1 to i do
               <span style="color: #00ffff;">for</span> k:=j to i+j do
                   <span style="color: #00ffff;">for</span> l:=1 to i+j-k do
                       <span style="color: #b0c4de;">r</span>:=r+1
       <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>


\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}


<p>
Time: O(n<sup>4</sup>).
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">19</h3>
<div class="outline-text-3" id="text-2-4">
\begin{align}
(1/3)^n &lt; 6 &lt; loglogn &lt; logn = lnn &lt; (logn)^2 &lt; n^\frac{1}{3}+logn &lt; \sqrt{n}
 \newline 
 &lt; \frac{n}{logn} &lt; n &lt; nlogn &lt; n^2 = n^2+logn &lt; n^3 &lt; n-n^3+7n^5 &lt; (3/2)^2 
 \newline 
= 2^n &lt; n!
\end{align}
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">34</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Assume that Christmas hasndays. Exactly how many presents did my “true
love” send me? (Do some research if you do not understand this
question.)
</p>

<p>
假设一共有ｎ天，每i天收到的礼物数是： 
</p>

\begin{align}
p_i = \sum_{k=1}^{i}k
\end{align}


<p>
总的礼物数：
</p>

\begin{align}
\sum_{i=1}^{n} p_i = \sum_{i=1}^{n}\sum_{k=1}^{i}k=\frac{n^3+3n^2+2n}{6}
\end{align}
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">43</h3>
<div class="outline-text-3" id="text-2-6">
<p>
You are given a set S of n numbers. You must pick a subset S&#8217; of k
numbers from S such that the probability of each element of S
occurring in S&#8217; is equal (i.e., each is selected with probability k /
n). You may make only one pass over the numbers. What if n is unknown?
</p>

<p>
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Reservoir%20Sampling.html">Reservoir sampling issue</a>.
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">44</h3>
<div class="outline-text-3" id="text-2-7">
<p>
We have 1,000 data items to store on 1,000 nodes. Each node can store
copies of exactly three different items. Propose a replication scheme
to minimize data loss as nodes fail. What is the expected number of
data entries that get lost when three random nodes fail?
</p>

<p>
不考虑RAID的XOR做法这里。
</p>

<p>
1000个数据做3份拷贝，如何做3份拷贝呢？
</p>

<ol class="org-ol">
<li>随机的3个点失败只损失一个数据
</li>
</ol>
<p>
3份拷贝以相邻一格的方式存储，如下
</p>
<div class="org-src-container">

<pre class="src src-sh">nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data1000 data1    data2 ..  data999
copy3:   data999  data1000 data1 ..  data998
</pre>
</div>

随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000, 每种组合丢失一个数据
所以丢失数据期望 $1000 / \binom{1000}{3} = 6.01804e-06$ 

<ol class="org-ol">
<li>随机的3个点失败损失3个数据
</li>
</ol>
<p>
每3个点共享3个拷贝点，如下
</p>
<div class="org-src-container">

<pre class="src src-sh">nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data3    data1    data2 ..  data999
copy3:   data2    data3    data1 ..  data998
</pre>
</div>

随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000/3, 每种组合丢失3个数据，
所以丢失数据期望 $1000/3×3 / \binom{1000}{3} = 6.01804e-06$ 
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">45</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Consider the following algorithm to find the minimum element in an
array of numbers . One extra variable tmp is allocated to hold the
current minimum value. Start from <code>A[0]</code>; &#8220;tmp&#8221; is compared against
<code>A[1], A[2], , A[N]</code> in order. When <code>A[i] &lt; tmp, tmp = A[i]</code>. What is the
expected number of times that the assignment operation tmp = A[i] is
performed?
</p>

<p>
期望的次数是第ｎ个元素是最小值的概率的总和。ｎ个元素平均分布，任意元素是最小值的概率是1/ｎ。
</p>

<p>
<code>E(n) = E(n-1) +1/n， E[1] = 1</code>
</p>


\begin{align}
E(n) = \sum_{i=1}^{n}\frac{1}{i} \approx lnn
\end{align}
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">46</h3>
<div class="outline-text-3" id="text-2-9">
<p>
You have a 100-story building and a couple of marbles. You must
identify the lowest floor for which a marble will break if you drop it
from this floor. How fast can you find this floor if you are given an
infinite supply of marbles? What if you have only two marbles?
</p>

<ol class="org-ol">
<li>无限个玻璃球，采用二分搜索法，celing(log100) = 7. 最快7次。
</li>
<li>如果只有2个玻璃球
</li>
</ol>
<p>
n个球时在总楼层r中某个楼层x抛，两种情况： 1.破碎，剩下的总楼层x-1用剩下的n-1个球; 2.没破碎，剩下的总楼层r-x用n个球
</p>

<p>
如此把问题分解成小问题。如下代码求得最快的次数为14。其中一条最坏情况：
9&#x2013;&gt;22&#x2013;&gt;34&#x2013;&gt;45&#x2013;&gt;55&#x2013;&gt;64&#x2013;&gt;72&#x2013;&gt;79&#x2013;&gt;85&#x2013;&gt;90&#x2013;&gt;94&#x2013;&gt;97&#x2013;&gt;99
</p>


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Drop Marbles</span>
<span style="color: #ff7f24;">   n: num of marbles</span>
<span style="color: #ff7f24;">   r: num of floors</span>
<span style="color: #ff7f24;">   drop_qeq: the drop sequence</span>
<span style="color: #ff7f24;">   marble_drop: minimum number of trails needed to find the critical floor in</span>
<span style="color: #ff7f24;">   worst case</span>
<span style="color: #ff7f24;">   marble_drop[n][r] = 1 + min{max(marble_drop[n-1][x-1], marble[n][r-x]) :</span>
<span style="color: #ff7f24;">   x in {1,2,...,r}}</span>
<span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DropMarbles</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">drop_seq</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">marble_drop</span>[n+1][r+1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (j = 0; j &lt;= r; ++j) {
    marble_drop[1][j] = j;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt;= n; ++i) {
    marble_drop[i][1] = 1;
    marble_drop[i][0] = 0;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_sofar</span>;
  <span style="color: #00ffff;">for</span> (i = 2; i &lt;= n; ++i) {
    <span style="color: #00ffff;">for</span> (j = 2; j &lt;= r; ++j) {
      marble_drop[i][j] = <span style="color: #7fffd4;">numeric_limits</span>&lt;<span style="color: #98fb98;">int</span>&gt;::max();
      <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 1; x &lt;= j; ++x) {
        min_sofar = 1 + max(marble_drop[i-1][x-1], marble_drop[i][j-x]);
        <span style="color: #00ffff;">if</span> (min_sofar &lt; marble_drop[i][j]) {
          marble_drop[i][j] = min_sofar;
          drop_seq[i][j] = x;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> marble_drop[n][r];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">47</h3>
<div class="outline-text-3" id="text-2-10">
<p>
You are given 10 bags of gold coins. Nine bags contain coins that each
weigh 10 grams. One bag contains all false coins that weigh one gram
less. You must identify this bag in just one weighing. You have a
digital balance that reports the weight of what is placed on it.
</p>

<p>
一共10袋bag1-10, 分别从bag1中取1个金币，bag2中取2个金币……bag10中取10
个金币，称重总的重量W。如果每个金币都是10grams的话，所以金币总重量是550。N=550-W。得到缺失的重量，也是bag的号数，所以bagN中含有错误金币。
</p>
</div>
</div>
<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">48</h3>
<div class="outline-text-3" id="text-2-11">
<p>
You have eight balls all of the same size. Seven of them weigh the
same, and one of them weighs slightly more. How can you find the ball
that is heavier by using a balance and only two weighings?
</p>

<p>
8==&gt; 3,3,2
</p>

<ol class="org-ol">
<li>称重3和3两组
</li>
<li>若不同，选出重的一组，3==&gt; 1,1,1 称重1和1,不同，那么重的就是，相同，另外个是。
</li>
<li>若相同，2==&gt;1,1，称重1和1,重的就是
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">49</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Suppose we start with n companies that eventually merge into one big
company. How many different ways are there for them to merge?
</p>

1. 2个公司(a,b)时，合并只有一种方法[ab]
2. 当有n个公司时，如何把它用n-1个公司表示，f(n)=f(n-1)g(n)
3. n个公司第一步从中选择两个公司合并，连带合并后的新公司一共n-1个公司，
   化简到n-1个公司表示。
4. n个选2个的组合个数是： $\binom{1000}{2}=n(n-1)/2$

<p>
所以
</p>

<p>
f(n) = &sum;<sub>i=2</sub><sup>n</sup>\frac{i(i-1)}{2} = \frac{n!(n-1)!}{2<sup>n-2</sup>}
</p>
</div>
</div>

<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">50</h3>
<div class="outline-text-3" id="text-2-13">
<p>
A Ramanujam number can be written two different ways as the sum of two
cubes&#x2014;i.e., there exist distinct a, b, c, and d such that a3 + b3 =
c3 + d3. Generate all Ramanujam numbers where a,b,c,d &lt; n.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindEqual</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &amp;<span style="color: #eedd82;">num_cube</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">high</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">sum</span>,
               <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">res</span>) {
  <span style="color: #00ffff;">if</span> (low &gt;= high) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  i = low;
  j = high;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">add</span>;
  <span style="color: #00ffff;">while</span> (i &lt; j) {
    add = num_cube[i] + num_cube[j];
    <span style="color: #00ffff;">if</span> (add == sum) {
      res-&gt;push_back(i);
      res-&gt;push_back(j);
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    }
    <span style="color: #00ffff;">if</span> (add &gt; sum) {
      --j;
    } <span style="color: #00ffff;">else</span> {
      ++i;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RamanujamNum</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">res</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_cube</span>(n);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    num_cube[i] = i*i*i;
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">ram_num</span>;
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">find</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n - 1; ++i) {
    <span style="color: #00ffff;">for</span> (j = i + 3; j &lt; n; ++j) {
      find = FindEqual(num_cube, i+1, j-1, num_cube[i] + num_cube[j], &amp;ram_num);
      <span style="color: #00ffff;">if</span> (find) {
        ram_num.push_back(i);
        ram_num.push_back(j);
        res-&gt;push_back(ram_num);
        ram_num.clear();
      }
    }
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">51</h3>
<div class="outline-text-3" id="text-2-14">
<p>
Six pirates must divide $300 dollars among themselves. The division is
to proceed as follows. The senior pirate proposes a way to divide the
money. Then the pirates vote. If the senior pirate gets at least half
the votes he wins, and that division remains. If he doesn&#8217;t, he is
killed and then the next senior-most pirate gets a chance to do the
division. Now you have to tell what will happen and why (i.e., how
many pirates survive and how the division is done)? All the pirates
are intelligent and the first priority is to stay alive and the next
priority is to get as much money as possible.
</p>

<p>
从后往前推
</p>
<ul class="org-ul">
<li>2个海盗，(1, 2) &#x2014;&gt; (0, 300)
</li>
<li>3个海盗，(1, 2, 3) &#x2014;&gt; (1, 0, 299)
</li>
<li>4个海盗，(1, 2, 3, 4) &#x2014;&gt; (0, 1, 0, 299)
</li>
<li>5个海盗，(1, 2, 3, 4, 5) &#x2014;&gt; (1, 0, 1, 0, 298)
</li>
<li>6个海盗，(1, 2, 3, 4, 5, 6) &#x2014;&gt; (0, 1, 0, 1, 298)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">52</h3>
<div class="outline-text-3" id="text-2-15">
<p>
Reconsider the pirate problem above, where only one indivisible dollar
is to be divided. Who gets the dollar and how many are killed?
</p>

<ul class="org-ul">
<li>2: (1, 2) &#x2014;&gt; (0, 1)
</li>
<li>3: (1, 2, 3) &#x2014;&gt; （1, 0, 0)
</li>
<li>4: (1, 2, 3, 4) &#x2014;&gt; (0, 0, 1, 0)
</li>
<li>5: dead
</li>
<li>6: (1, 2, 3, 4, 5, 6) &#x2014;&gt; (0, 0, 0, 1, 0, 0)
</li>
</ul>
<p>
要至少一半的同意，间隔要有一半的人会死去才会同意之前那个人，所以之后每
2+2<sup>K</sup> (K&gt;=1)的海盗才能活。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 1]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/26/The-Algorithm-Design-Manual1/"/>
    <updated>2014-05-26T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/26/The-Algorithm-Design-Manual1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Combinatorial Objects</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Permutations - arrangements, or orderings, of items (&#8220;arrangement&#8221;
&#8220;tour&#8221; &#8220;ordering&#8221; or &#8220;sequence&#8221; )
</li>
<li>Subsets - selections from a set of items (&#8220;cluster&#8221; &#8220;collection&#8221;
&#8220;committee&#8221; &#8220;group&#8221; &#8220;packaging&#8221; or &#8220;selection&#8221;)
</li>
<li>Trees - hierarchical relationships between items (&#8220;hierarchy&#8221;
&#8220;dominance relationship&#8221; &#8220;ancestor/descendant relationship&#8221; or
&#8220;taxonomy&#8221;)
</li>
<li>Graphs - relationships between arbitrary pairs of objects (&#8220;network&#8221;
&#8220;circuit&#8221; &#8220;web&#8221; or &#8220;relationship&#8221;)
</li>
<li>Points - locations in some geometric space (&#8220;sites&#8221; &#8220;positions&#8221; or
&#8220;locations.)
</li>
<li>Polygons - regions in some geometric spaces (&#8220;shapes&#8221; &#8220;regions&#8221; or
&#8220;boundaries&#8221;)
</li>
<li>Strings - sequences of characters or patterns. (&#8220;text&#8221; &#8220;characters&#8221;
&#8220;patterns&#8221; or &#8220;labels&#8221;)
</li>
</ul>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Recursive Objects</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Big things that are made from smaller things of exactly the same type
as the big thing. A decomposition rule describes how to get smaller
things from big things.
</p>

<p>
As all combinatorial objects above are recursive objects here are a
few possible decompositon rules for them:
</p>

<ul class="org-ul">
<li>Permutations - Deleting the first/last element of a permutation
</li>
<li>Subsets - Deleting an element n if present
</li>
<li>Trees - Deleting the root (results in a set of subtrees), deleting a
leaf (a smaller tree)
</li>
<li>Graphs - Deleting a vertex, dividing vertices to groups
</li>
<li>Point - divide them to groups
</li>
<li>Polygons - Inserting any internal chord between two nonadjacent vertices
</li>
<li>Strings - Deleting a character (first or last)
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1-28.</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Write a function to perform integer division without using either
the / or * operators. Find a fast way to do it.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">DivideCore</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">quot</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">rem</span>) {
  rem = m;
  quot = 0;
  <span style="color: #00ffff;">while</span> (rem &gt;= n) {
    rem -= n;
    quot++;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Divide</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">quot</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">rem</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mult_n</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_n</span>;
  <span style="color: #00ffff;">while</span> (m % n == 0) {
    last_n = n;
    n = n + n;
    mult_n++;
  }
  DivideCore(m, n, quot, rem);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; mult_n; ++i) {
    quot = quot + quot;
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1-29.</h3>
<div class="outline-text-3" id="text-2-2">
<p>
There are 25 horses. At most, 5 horses can race together at a time.
You must determine the fastest, second fastest, and third fastest
horses. Find the minimum number of races in which this can be done.
</p>

<p>
7次。
</p>

<ol class="org-ol">
<li>5次：25匹分成5组，比赛5次，得到前5名。
</li>
<li>6次：前5名比赛一次。因为只要得到前3名，这里剔除5名中的2名，剩下的3
匹按比赛排名所在组为G1，G2，G3。
</li>
<li>7次：G3组只能去角逐第3名，派第一名G31,G2组只能去角逐第2,3名，派第一，二名，G21和G22。G1组G11已经是第一名，去角逐第2,3名，派G12,G13。最后
G12,G13，G21，G22和G31，得到第二，三名。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">1-30.</h3>
<div class="outline-text-3" id="text-2-3">
<p>
How many piano tuners are there in the entire world?
</p>

<p>
需要把问题分解：1.世界有多少架钢琴;2.每位钢琴调音师能调多少台钢琴。
</p>

<p>
估算世界有多少架钢琴，需要知道：
</p>
<ol class="org-ol">
<li>世界的人口。
</li>
<li>拥有钢琴的人口比例。
</li>
<li>拥有钢琴的学校，教堂等场所的数量。
</li>
</ol>

<p>
估算每位钢琴调音师能调多少台钢琴，需要知道：
</p>
<ol class="org-ol">
<li>每架钢琴平均多久需要调音一次。
</li>
<li>对钢琴调音需要多长时间。
</li>
<li>调音师的工作时间。
</li>

<li>世界人口70亿，70×10<sup>9</sup> 。
</li>
<li>人口中弹奏乐器的人约占10%（肯定大于1%,小于100%），其中最多10%的人弹奏钢琴，而其中拥有钢琴的比例为2%-3%，约人口总数2×10<sup>-3</sup> 。每
5000-10000个人有一座教堂，每座教堂有一架钢琴，每500-1000个学生有一所学校，每所学校有一架钢琴，每人大约拥有3×10<sup>-3</sup> 架钢琴，所以钢琴数
70×10<sup>9</sup> × 3×10<sup>-3</sup> = 2.1 * 10<sup>8</sup> 。
</li>
<li>钢琴调音的频率低于每月一次但多于10年一次，估计为一年一次。
</li>
<li>调音所需时间多余30分钟，少于1天，估计为2小时。或钢琴有88个键，如果每个键花1分钟，需要1.5小时，若需2分钟，则需要3小时。
</li>
<li>每天工作8小时，每周5天，每年工作50周，得出8×5×50=2000小时。2000小时能调音大学1000架钢琴。
</li>
<li>2.1 * 10<sup>8</sup> / 1000 = 2.1 × 10<sup>5</sup> 个调音师。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">1-31.</h3>
<div class="outline-text-3" id="text-2-4">
<p>
How many gas stations are there in the United States?
</p>

<p>
分解问题成：
</p>
<ol class="org-ol">
<li>每天大约有多少辆汽车去加油。
</li>
<li>每天一个加油站能给多少辆汽车加油。
</li>

<li>美国人口总数约300×10<sup>6</sup> , 一家平均有2辆车左右，所以一共有车辆
150×10<sup>6</sup> ，每辆汽车每5天加油一次，一天有30×10<sup>6</sup> 辆车去加油。
</li>
<li>一个加油站平均每小时最少为1辆，最多100多辆汽车加油，取平均20-30辆每小时，一个加油站工作时间大概14小时（7am-9am），每个加油站每天平均大约为280辆车加油。
</li>
<li>30×10<sup>6</sup> / 280 = 1.07 × 10<sup>5</sup> 个加油站。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">1-32.</h3>
<div class="outline-text-3" id="text-2-5">
<p>
How much does the ice in a hockey rink weigh?
</p>

<p>
分解成：
</p>
<ol class="org-ol">
<li>冰的体积。
</li>
<li>冰的密度。
</li>
</ol>

<p>
做如下估算：
1.冰场的长度：70m;
2.冰场的宽度：30m;
3.冰的厚度：10cm=0.1;
4.冰的密度与水相当，估算1000kg/m<sup>3</sup> .
</p>

<p>
V = 70 * 30 * 0.1 = 210 m<sup>3</sup>
W = 210 *1000 = 210，000kg
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">1-33.</h3>
<div class="outline-text-3" id="text-2-6">
<p>
How many miles of road are there in the United States?
</p>

<p>
美国近似是一个矩形，高1000mile和长3000mile。美国大部分地区是乡村，道路比较稀疏，平均下来可以把美国想成一个网状的道路结构，每隔1mile一条道路，最后如下网格，1000条3000mile和3000条1000mile的路，总的6,000,000mile的路。
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">1-34.</h3>
<div class="outline-text-3" id="text-2-7">
<p>
On average, how many times would you have to flip open the Manhattan
phone book at random in order to find a specific name?
</p>


<p>
假设电话本有1000页，也就是500个翻面。
</p>

<p>
简单答案：翻到正确页的概率是1/500。
</p>

<p>
复杂点答案：上面没有考虑不断翻页，会翻到相同的页面。翻到错误页面的概率是499/500，N次后的错误概率是（499/500）<sup>N</sup> ,所以N次后的正确页面概率是P=1-
（499/500）<sup>N</sup> 。
</p>

<p>
那么：
N=1  P = 0.002
N=2  P = 0.004
&#x2026;
N=1150 P = 0.89999
</p>

<p>
达到90%的概率，所以需要1150翻页。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls Overview]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/24/programming-pearls-overview/"/>
    <updated>2014-05-24T10:34:37+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/24/programming-pearls-overview</id>
    <content type="html"><![CDATA[<p>全书分为3部分：</p>

<ul>
  <li>预备知识：总的概括代码涉及的知识点，比如算法和数据结构的重要性和合理
性，如何写出正确的代码并证明，如何测试代码，性能评估代码，debug等。 </li>
  <li>性能：先是介绍一些估算的技巧，比如72法则，利特尔法则(Little’s law)
等，之后展开代码算法的性能，如何调试代码使得性能更好或更省空间。</li>
  <li>产品：讲解具体的算法，如排序，搜索等。</li>
</ul>

<p>书本和习题大部分代码<a href="https://github.com/shishougang/Programming-Pearls">实现</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column14-15]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/24/column14_15/"/>
    <updated>2014-05-24T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/24/column14_15</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Hash存储word次数</h3>
<div class="outline-text-3" id="text-1-1">
<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #98fb98;">Nodeptr</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #87cefa;">Node</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">inword</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">incount</span>, <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">innext</span>) {
    word = inword;
    count = incount;
    next = innext;
  }
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
  <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">next</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NHASH</span> 29989
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MULT</span> 31
<span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">bin</span>[NHASH];

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Hash</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">string</span>::<span style="color: #98fb98;">const_iterator</span> <span style="color: #eedd82;">it</span> = str.begin(); it != str.end(); ++it) {
    h = MULT * h + *it;
  }
  <span style="color: #00ffff;">return</span> h % NHASH;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">InWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">p</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span>;
  h = Hash(str);
  <span style="color: #00ffff;">for</span> (p = bin[h]; p != <span style="color: #7fffd4;">NULL</span>; p = p-&gt;next) {
    <span style="color: #00ffff;">if</span> (str.compare(p-&gt;word) == 0) {
      (p-&gt;count)++;
      <span style="color: #00ffff;">return</span>;
    }
  }
  p = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Node</span>(str, 1, bin[h]);
  bin[h] = p;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    bin[i] = <span style="color: #7fffd4;">NULL</span>;
  }
  <span style="color: #00ffff;">while</span> (cin &gt;&gt; str) {
    InWord(str);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">p</span> = bin[i]; p != <span style="color: #7fffd4;">NULL</span>; p = p-&gt;next) {
      cout &lt;&lt; p-&gt;word &lt;&lt; <span style="color: #ffa07a;">" "</span> &lt;&lt; p-&gt;count &lt;&lt; endl;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Markov产生随机词汇</h3>
<div class="outline-text-3" id="text-1-2">
<p>
利用指针指向不同单词的开头，并按照K个单词对比方式排序，利用二分搜索定位相同K长度的文本，并利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Reservoir%20Sampling.html">Reservoir sampling</a>在不知道长度的情况下，均等的随机选取一个。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXINPUT</span> 4000000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORDS</span> 800000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">K</span> 2
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">input_letters</span>[MAXINPUT];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>[MAXWORDS];

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">WordNcmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">while</span> (*p == *q) {
    <span style="color: #00ffff;">if</span> (*p == 0 &amp;&amp; --n == 0) {
      <span style="color: #00ffff;">return</span> 0;
    }
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> *p - *q;
}


<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">SortCmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">p</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>**)(a);
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">q</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>**)(b);
  <span style="color: #00ffff;">return</span> WordNcmp(*p, *q, K);
}

<span style="color: #98fb98;">char</span>* <span style="color: #87cefa;">SkipNword</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (; n &gt; 0; p++) {
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> p;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindPhrase</span>(<span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span> = -1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = n;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  <span style="color: #00ffff;">while</span> (l + 1 != u) {
    m = (l + u) / 2;
    <span style="color: #00ffff;">if</span> (WordNcmp(word[m], phrase, K) &lt; 0) {
      l = m;
    } <span style="color: #00ffff;">else</span> {
      u = m;
    }
  }
  <span style="color: #00ffff;">return</span> u;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span> = 0;
  word[0] = input_letters;
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%s"</span>, word[nword]) != EOF) {
    word[nword + 1] = word[nword] + strlen(word[nword]) + 1;
    nword++;
    <span style="color: #00ffff;">if</span> (nword == MAXWORDS) {
      <span style="color: #00ffff;">break</span>;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    word[nword][i] = 0;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    printf(<span style="color: #ffa07a;">"%s "</span>, word[i]);
  }
  qsort(word, nword, <span style="color: #00ffff;">sizeof</span>(word[0]), SortCmp);
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span> = input_letters;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">printlen</span> = 100;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">find_index</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (; printlen &gt; 0; --printlen) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">find_index</span> = FindPhrase(word, nword, phrase);
    <span style="color: #00ffff;">for</span> (i = 0; WordNcmp(phrase, word[find_index + i], K) == 0; ++i) {
      <span style="color: #00ffff;">if</span> ((rand() % (i + 1)) == 0) {
        p = word[find_index + i];
      }
    }
    phrase = SkipNword(p, 1);
    <span style="color: #00ffff;">if</span> (strlen(SkipNword(phrase, K - 1)) == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    printf(<span style="color: #ffa07a;">"%s "</span>, SkipNword(phrase, K - 1));
  }
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Markov利用Hash产生随机词汇</h3>
<div class="outline-text-3" id="text-1-3">
<p>
利用Hash表加快搜索相同K长度的文本。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXINPUT</span> 4000000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORDS</span> 800000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">K</span> 2
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">input_letters</span>[MAXINPUT];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>[MAXWORDS];

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">WordNcmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">while</span> (*p == *q) {
    <span style="color: #00ffff;">if</span> (*p == 0 &amp;&amp; --n == 0) {
      <span style="color: #00ffff;">return</span> 0;
    }
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> *p - *q;
}

<span style="color: #98fb98;">char</span>* <span style="color: #87cefa;">SkipNword</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (; n &gt; 0; p++) {
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> p;
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NHASH</span> 499979
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MULT</span> 31
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bin</span>[NHASH];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span>[MAXWORDS];

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Hash</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = 0;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span> = str;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = K; n &gt; 0; p++) {
    h = MULT * h + (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>)(*p);
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> h % NHASH;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">InitHash</span>(<span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    bin[i] = - 1;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; nword; ++i) {
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = Hash(word[i]);
    next[i] = bin[h];
    bin[h] = i;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span> = 0;
  word[0] = input_letters;
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%s"</span>, word[nword]) != EOF) {
    word[nword + 1] = word[nword] + strlen(word[nword]) + 1;
    nword++;
    <span style="color: #00ffff;">if</span> (nword == MAXWORDS) {
      <span style="color: #00ffff;">break</span>;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    word[nword][i] = 0;
  }
  InitHash(word, nword);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    printf(<span style="color: #ffa07a;">"%s "</span>, word[i]);
  }
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span> = input_letters;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">printlen</span> = 100;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (; printlen &gt; 0; --printlen) {
    i = 0;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = bin[Hash(phrase)]; j &gt;= 0; j = next[j]) {
      <span style="color: #00ffff;">if</span> (WordNcmp(word[j], phrase, K) == 0 &amp;&amp; (rand() % (++i) == 0)) {
        p = word[j];
      }
    }
    phrase = SkipNword(p, 1);
    <span style="color: #00ffff;">if</span> (strlen(SkipNword(phrase, K - 1)) == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    printf(<span style="color: #ffa07a;">"%s "</span>, SkipNword(phrase, K - 1));
  }
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Column14-2</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SiftDown</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">child</span>;
  <span style="color: #00ffff;">for</span> (;;) {
    child = i * 2;
    <span style="color: #00ffff;">if</span> (child &gt; u) {
      <span style="color: #00ffff;">break</span>;
    }
    <span style="color: #00ffff;">if</span> (child + 1 &lt;= u) {
      <span style="color: #00ffff;">if</span> (x[child + 1] &lt; x[child]) {
        child++;
      }
    }
    <span style="color: #00ffff;">if</span> (x[i] &lt;= x[child]) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(x[i], x[child]);
    i = child;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">HeapSort</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = n / 2; i &gt;= 1; --i) {
    SiftDown(x, i, n);
  }
  <span style="color: #00ffff;">for</span> (i = n; i &gt;= 2; --i) {
    swap(x[1], x[i]);
    SiftDown(x, 1, i - 1);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Column15-8</h3>
<div class="outline-text-3" id="text-2-2">
<p>
找出最长重复超过M次的字符串。
</p>

<p>
经过排序后，越是相邻的越是相同的多，至少重复M次，就是计算相邻M个位置的字符所重复的字符长度，即 <code>ComLen(pstr[i], pstr[i + kM])</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">CmpPstr</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">p</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **)a;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">q</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **)b;
  <span style="color: #00ffff;">return</span> strcmp(*p, *q);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ComLen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">while</span> (*p &amp;&amp; (*p == *q)) {
    ++i;
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> i;
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">kMaxN</span> 500000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">kM</span> 1
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[kMaxN];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pstr</span>[kMaxN];
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ch</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;
  <span style="color: #00ffff;">while</span> ((ch = getchar()) != EOF) {
    str[n] = ch;
    pstr[n] = &amp;str[n];
    ++n;
  }
  str[n] = 0;
  qsort(pstr, n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span> *), CmpPstr);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxlen</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxindex</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n - kM; ++i) {
    <span style="color: #00ffff;">if</span> (ComLen(pstr[i], pstr[i + kM]) &gt; maxlen) {
      maxlen = ComLen(pstr[i], pstr[i + kM]);
      maxindex = i;
    }
  }
  printf(<span style="color: #ffa07a;">"%.*s\n"</span>, maxlen, pstr[maxindex]);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Column15-9</h3>
<div class="outline-text-3" id="text-2-3">
<p>
找出两个文本中最长的共同字符串。
</p>

<p>
经典<a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem">Longest common substring problem</a>.
利用Dynamic Programming解决。复杂度O(mn).
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #87cefa;">LongestCommonString</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">s</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">t</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; <span style="color: #eedd82;">array</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len_s</span> = s.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len_t</span> = t.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  array.resize(len_s);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; len_s; ++i) {
    array[i].resize(len_t);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max_len</span> = 0;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">end_indexs</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; len_s; ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; len_t; ++j) {
      <span style="color: #00ffff;">if</span> (s[i] == t[j]) {
        <span style="color: #00ffff;">if</span> (i == 0 || j == 0) {
          array[i][j] = 1;
        } <span style="color: #00ffff;">else</span> {
          array[i][j] = array[i-1][j-1] + 1;
        }
        <span style="color: #00ffff;">if</span> (array[i][j] == max_len) {
          end_indexs.push_back(i);
        } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (array[i][j] &gt; max_len) {
          max_len = array[i][j];
          end_indexs.clear();
          end_indexs.push_back(i);
        }
      }
    }
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">res</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = end_indexs.begin(); it != end_indexs.end();
       ++it) {
    res.push_back(s.substr(*it - max_len + 1, max_len));
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Column15-11</h3>
<div class="outline-text-3" id="text-2-4">
<p>
产生单词层次的Markov文本。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMax</span> = 50000;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kK</span> = 5;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kPrintlen</span> = 1000;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[kMax];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">n</span>;
  n = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF) {
    str[n++] = c;
  }
  str[n] = 0;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">q</span>, *<span style="color: #eedd82;">next_p</span>;
  p = str;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">eq_sofar</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; kK; ++i) {
    printf(<span style="color: #ffa07a;">"%c"</span>, str[i]);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; kPrintlen; ++i) {
    eq_sofar = 0;
    <span style="color: #00ffff;">for</span> (q = str; q &lt; str + n - kK + 1; ++q) {
      <span style="color: #00ffff;">for</span> (j = 0; j &lt; kK &amp;&amp; *(p + j) == *(q + j); ++j) {
      }
      <span style="color: #00ffff;">if</span> (j == kK) {
        eq_sofar++;
        <span style="color: #00ffff;">if</span> (rand() % eq_sofar == 0) {
          next_p = q;
        }
      }
    }
    c = *(next_p + kK);
    <span style="color: #00ffff;">if</span> (c == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    putchar(c);
    p = next_p + 1;
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column11-12]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/18/column11_12/"/>
    <updated>2014-05-18T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/18/column11_12</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">QuickSort</h3>
<div class="outline-text-3" id="text-1-1">
<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = array[m];
  array[m] = array[n];
  array[n] = temp;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">isort</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">t</span>;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; n; ++i) {
    t = array[i];
    <span style="color: #00ffff;">for</span> (j = i; j &gt;= 0  &amp;&amp; array[j - 1] &lt; t; --j) {
      array[j] = array[j - 1];
    }
    array[j - 1] = t;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort1</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">use array[l] for the mid element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = l;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l + 1; i &lt;= u; ++i) {
    <span style="color: #00ffff;">if</span> (array[i] &lt; array[l]) {
      swap(array, ++m, i);
    }
  }
  swap(array, l, m);
  qsort1(array, l, m - 1);
  qsort1(array, m + 1, u);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort2</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">use array[l] for the mid element, from back to start,</span>
<span style="color: #ff7f24;">    always swap the first element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">m</span>;
  i = m = u + 1;
  <span style="color: #00ffff;">do</span> {
    <span style="color: #00ffff;">do</span> {
      --i;
    } <span style="color: #00ffff;">while</span> (array[i] &lt; array[l]);
    swap(array, --m, i);
  } <span style="color: #00ffff;">while</span> (i &gt; l);
  qsort2(array, l, m - 1);
  qsort2(array, m + 1, u);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort3</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">two-way partition, use array[l] for the mid element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span> , <span style="color: #eedd82;">j</span>;
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  qsort3(array, l, j - 1);
  qsort3(array, j + 1, u);
}

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kCutOff</span> = 50;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort4</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">qsort3 + randomization + isort small subarrays + swap inline */</span>
  <span style="color: #00ffff;">if</span> (u - l &lt; kCutOff) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span> , <span style="color: #eedd82;">j</span>;
  swap(array, l, randint(l, u));
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  qsort3(array, l, j - 1);
  qsort3(array, j + 1, u);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">生成随机数</h3>
<div class="outline-text-3" id="text-1-2">
<p>
从n中生成不重复的m个随机数。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">1</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenerateSortedRand</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">select</span> = m;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">remaining</span> = n;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n &amp;&amp; select &gt; 0; ++i) {
    <span style="color: #00ffff;">if</span> (rand() % remaining &lt; select) {
      cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" "</span>;
      --select;
    }
    --remaining;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">2</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenKnuth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n &amp;&amp; m &gt; 0; ++i) {
    <span style="color: #00ffff;">if</span> (rand() % (n - i) &lt; m) {
      cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" "</span>;
      --m;
    }
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">3</h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #00ffff;">while</span> (num_set.size() &lt; m) {
    num_set.insert(rand() % n);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end(); ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">4</h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(a) - *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(b));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenShuf</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    x[i] = i;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(i, n - 1);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = x[j];
    x[j] = x[i];
    x[i] = t;
  }
  qsort(x, m, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), compare);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    cout &lt;&lt; x[i] &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">delete</span> x;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">原则</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>理解问题。与用户讨论提出问题的有关场景。问题的陈述中往往包含问题的想法，和所有早期的想法一样，它们应该被考虑而不是与其他排斥。
</li>
<li>指出一个抽象问题。一个清晰，整洁的问题陈述不旦帮助我们解决这个问题，并且能体现如何把这个解答应用到其他的问题上。
</li>
<li>探索设计空间。不要急于立刻去解决问题，思考一分钟，花一天时间编程。应该思考一小时，编程一小时。使用通俗的上层语言帮助我们描述设计：伪代码描述控制六，抽象化表示关键数据结构的数据类型。
</li>
<li>实现一种解答。我们应该追求以直接清晰的代码来实现选择的设计，使用最强大的能用的操作。
</li>
<li>回顾。Polya的<a href="http://www.amazon.com/How-Solve-It-Mathematical-Princeton/dp/069111966X">How to Solve It</a>能帮助任何程序员成为更好的问题解决者。在
15页他说：”基本存在一些东西去做，随着足够的学习和突破，我们能改善每个解答，并且在任何情况下，我们都能经常改善我们对解答的理解。“
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Column11-9</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在数组n中以算法复杂度O(n)找出第k个小的元素。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = array[m];
  array[m] = array[n];
  array[n] = temp;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SelectK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  swap(array, l, randint(l, u));
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    SelectK(array, j + 1, u, k);
  }
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    SelectK(array, l, j - 1, k);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">bigrand</span>() {
  <span style="color: #00ffff;">return</span> RAND_MAX * rand() + rand();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">2</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenerateM</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">t</span>;
  i = randint(0, n - 1);
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; m; ++j) {
    t = i + j;
    <span style="color: #00ffff;">if</span> (t &gt;= n) {
      t -= n;
    }
    cout &lt;&lt; t &lt;&lt; <span style="color: #ffa07a;">" "</span> &lt;&lt; endl;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">8</h3>
<div class="outline-text-3" id="text-2-4">
<p>
0..n-1中生成m个随机数。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(a) - *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(b));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenShuf</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    x[i] = i;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(i, n - 1);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = x[j];
    x[j] = x[i];
    x[i] = t;
  }

  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    cout &lt;&lt; x[i] &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">delete</span> x;
}
</pre>
</div>

<p>
如果允许有重复的数，如何生成排序的m个随机数。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">multiset</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #00ffff;">while</span> (num_set.size() &lt; m) {
    num_set.insert(rand() % n);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">multiset</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end();
       ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>

<p>
如果可以重复并顺序随机。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenM</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; m; ++i) {
    cout &lt;&lt; randint(0, n - 1) &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">9</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = n - m ; i &lt; n; ++i) {
    t = randint(0, i);
    <span style="color: #00ffff;">if</span> (num_set.find(t) == num_set.end()) {
      num_set.insert(t);
    } <span style="color: #00ffff;">else</span> {
      num_set.insert(i);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end(); ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">10</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Select</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  res = object[i];
  ++i;
  <span style="color: #00ffff;">while</span> (IsEnd(object[i])) {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(0, i);
      <span style="color: #00ffff;">if</span> (j &lt; 1) {
        res = object[i];
      }
      ++i;
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>

<p>
More: <a href="http://wiki.dreamrunner.org/public_html/Algorithms/Random%20and%20Sampling.html#sec-2">选k个</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">12</h3>
<div class="outline-text-3" id="text-2-7">
<p>
生成N&gt;1e6组的m个随机数，计算生成每个随机数出现的概率，是不是符合预期，还是偏差很大而不是随机的。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column8]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/17/column8/"/>
    <updated>2014-05-17T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/17/column8</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">问题与算法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
给出数组中找出连续子数组最大和。
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">1</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
直接算每个子区间的和并比较得出最大值。算法复杂度 O(n<sup>3</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg1</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; num.size(); ++j) {
      sum = 0;
      <span style="color: #00ffff;">for</span> (k = i; k &lt;= j; k++) {
        sum += num[k];
        <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
          max_sofar = sum;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">2</h4>
<div class="outline-text-4" id="text-1-1-2">
</div><div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">2.1</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
因为x[i..j]直接的和可以基于x[i..j-1]的和算出，不用重头开始算。算法复杂度 O(n<sup>2</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    sum = 0;
    <span style="color: #00ffff;">for</span> (j = i; j &lt; num.size(); ++j) {
      sum += num[j];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2">2.2</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
先算出x[0..i]区间的和为 <code>cum_vector[i]</code> ，那么x[i..j]区间的和就是
<code>cum_vector[j] - cum-vector[i-1]</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2b</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; <span style="color: #eedd82;">cum_vector</span>(num.size() + 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  cum_vector[0] = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    cum_vector[i] = cum_vector[i - 1] + num[i];
  }
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = i; j &lt; cum_vector.size(); ++j) {
      sum = cum_vector[j] - cum_vector[i - 1];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">3</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Divide-and-Conquer算法。
</p>
<ol class="org-ol">
<li>求整个数组的子数组和，可以分成前面一半和后面一半
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/programmingpearls/column8_3_1.jpg" title="'column8_3_1'" />

<ol class="org-ol">
<li>求出前半部分的最大子数组和后半部分的最大子数组和
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/programmingpearls/column8_3_2.jpg" title="'column8_3_2'" />

<ol class="org-ol">
<li>求出两部分中间连着的子数组最大和
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/programmingpearls/column8_3_3.jpg" title="'column8_3_3'" />

<ol class="org-ol">
<li>最后比较这3部分和就能得出整个个数组的子数组最大和
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3Core</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #00ffff;">if</span> (l &gt; u) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">if</span> (l == u) {
    <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">max</span>&lt;<span style="color: #98fb98;">float</span>&gt;(num[l], 0);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = (l + u) / 2;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">lmax</span>, <span style="color: #eedd82;">rmax</span>, <span style="color: #eedd82;">sum</span>;
  lmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m; i &gt;= l; --i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; lmax) {
      lmax = sum;
    }
  }
  rmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m + 1; i &lt;= u; ++i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; rmax) {
      rmax = sum;
    }
  }
  <span style="color: #00ffff;">return</span> max(lmax + rmax, max(FindMaxSubvectorAlg3Core(num, l, m),
                              FindMaxSubvectorAlg3Core(num, m + 1, u)));
}

<span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #00ffff;">return</span> FindMaxSubvectorAlg3Core(num, 0, num.size() - 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">4</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
假定已经解决了x[0..i-1]的情况，那么如何扩展到x[0..i]的情况，只多了x[i]
元素？
</p>

<ol class="org-ol">
<li>解决了x[0..i-1]的情况，有这区间的最大子数组和 <code>max_sofar</code> ，和必须以
x[i-1]结尾的子数组最大和;
</li>
<li>到x[0..i]的情况，就要把必须以x[i-1]结尾的子数组最大和与x[i]相加，如果以x[i-1]结尾的子数组为负数的话，加了反而减少总和。所以此种情况以
x[i]的和就是x[i];
</li>
<li>最后把以x[i]与在区间x[0..i-1]的最大子数组和 <code>max_sofar</code> 比较，就能解决
x[0..i]的情况;
</li>
<li>如此一直扩展到x[0..n]算出整个数组的最大子数组和。
</li>
</ol>

<p>
只扫描一遍，算法复杂度O(n)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg4</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">max_sofar</span>, <span style="color: #eedd82;">max_ending_here</span>;
  max_sofar = max_ending_here = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num.size(); ++i) {
    max_ending_here += num[i];
    <span style="color: #00ffff;">if</span> (max_ending_here &lt; 0) {
      max_ending_here = 0;
    }
    <span style="color: #00ffff;">if</span> (max_ending_here &gt; max_sofar) {
      max_sofar = max_ending_here;
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">算法设计技巧</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>保存状态防止重复计算。
</li>
<li>预处理信息到适当的数据结构中来加快之后的计算。比如先建立堆，先排序等。
</li>
<li>分而治之，把大问题分成类似的小问题解决。
</li>
<li>扫描算法。比如解出了x[0..i-1]如何扩展到x[0..i].
</li>
<li>累积。
</li>
<li>确定问题的算法复杂度下界。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">10</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>初始化累积和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code> ， 那么要x[l..u]
区间的和为0的话，cum[l-1] = cum[u]
</li>
<li>排序cum数组;
</li>
<li>扫描排序好的数组cum，找出最相近的相邻数组元素即得到结果。
</li>
</ol>

<p>
算法复杂度 O(n) + O(nlogn) + O(n-1) = O(nlogn).
</p>

<p>
找出子数组和与一个特定值r最相近，算法类似，只是step3找出与r最相近的相邻数组元素。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">11</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>累积收费和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code>
</li>
<li>计算l和u关卡之间的收费 cum[u]-cum[l]
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column7]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/14/column7/"/>
    <updated>2014-05-14T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/14/column7</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一天中密西西比河的流量是多少？
</p>

<p>
作者估算：河口宽度大约1 mile，大约1/250英里深，他猜测流速是5mile每小时或
120mile每天。
</p>

<p>
1mile * 1/250mile * 120 miles/day = 1/2 mile<sup>3</sup>/day
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">基本技巧</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">两个答案好于一个</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
估算中密西西比河的流域是 1000 × 1000 miles， 一年雨量大约1英尺，（1/5000英里每年）。
1000miles * 1000miles * 1/5000 mile/year = 200 mile<sup>3</sup>/year
200mile<sup>3</sup>/year/400days/year = 1/2 mile<sup>3</sup>/day
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">快速检查</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>Rule1： 相加的单位与原来一样。
</li>
<li>Rule2： 相乘的单位是单位的相乘。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">经验法则</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
72法则。
</p>

<p>
假如一笔钱以年利率百分比r存y年。如果r×y=72,那么钱将成2倍。这个估算大体正确，存1000以6%的年利率存12年之后为2012.
</p>

<p>
72法则对估算指数增长非常实用。双倍对于程序员来说很熟悉：2<sup>10</sup>=1024，10
倍双倍就是1thousand，20个双倍就是1million。
</p>

<p>
假如一个指数型复杂度的程序花10秒解决一个n=40的问题，每把n增加1就增加
12%的运行时间。72法则告诉我们，运行时间成2倍当n增加6，也就是1000倍（2<sup>10）当n增加60</sup>(6*10)。所以当n=100时，程序花10,000秒，也就几小时。当n
增加到160,时间成为10<sup>7</sup> 秒,那这时间大约是多少呢？
</p>

<p>
很难记住一年的时间是3.155×10<sup>7</sup> 秒，另一方面，很难忘记Tom Duff的实用经验准则，1%多的误差：
</p>

<strong> $\pi$ 秒是1纳世纪。</strong> ($\pi$ seconds is a nanocentury.)
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">练习</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
不断练习提高自己的估算技巧。
</p>

<p>
书中估算密西西比河的流量并不是特别技巧好，比如直接估测出流速是5mile每小时，很难直观想出这个数字。
</p>

<p>
推荐<a href="http://book.douban.com/subject/4904724/">《这也能想到?——巧妙解答无厘头问题》</a> 这本书，全书都是估算题目，
</p>
<ol class="org-ol">
<li>明白估算的目标精确度只需要达到一个数量级，和真实数据不超过10倍就是比较好的估算。
</li>
<li>估算一个东西的范围的关键是几何平均数。比如这里流量最小1mile每小时，最大10mile每小时，那么估算它为3mile每小时（几何平均）。比如地球的密度，比水大，比铁小，取它们的几何平均。
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">利特尔法则(Little&#8217;s law)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个稳定系统中长期平均存在的用户数是平均用户离开系统的速率与用户平均在系统的时间的乘积。
</p>

<p>
例如：一个地方能容纳60个人，你准备呆在那大约3小时，所以人们进入这个地方的速率是20个每小时。现在队伍中有20个人，那么意味着你将等1小时左右。
</p>

<p>
或多用户系统的回复时间公式：假定用户连接到回复时间是r的系统中的平均思考时间是z，每个用户或思考或等待系统回复，系统中的任务数大约固定在n，可以测得系统的吞吐量是x（每时间单位的任务数），由Little&#8217;s law得，
n=x*(z+r)。可以算得r=n/x - z。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
密西西比河的流速大概是5mile每小时或120mile每天，Passaic River应该是
200miles每天。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
软盘有1.44Mbytes，
</p>

<p>
一秒中最少可以打1byte，最多10bytes，也就是每分钟最少60bytes和最多600bytes，它们的几何平均是200byte，认为大约每分钟打字200byte，
1.44*10<sup>6</sup>/200=7200 minutes。
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">5</h3>
<div class="outline-text-3" id="text-2-3">
<p>
证明72法则。
</p>

<p>
若（1+x%）<sup>N</sup> = 2，证明x*N约等于72
</p>

<p>
(1+x%)<sup>N</sup>=2 ==&gt; N*ln(1+x%)=ln2
</p>

<p>
对ln(1+x)泰勒展开是ln(1+x) = x-(x<sup>2</sup>)/2 + (x<sup>3</sup>)/3 + &#x2026;
</p>

<p>
N*ln(1+x%)=ln2 ==&gt; N*x = ln2 * 100 = 69.3
</p>

<p>
因为忽略了-(x<sup>2</sup>)/2这个项，所以N*x约等于72。
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">6</h3>
<div class="outline-text-3" id="text-2-4">
<p>
72/1.33=54, 所以到2052年人口是2倍，就是5.9×2=11.8 billion。那么2050年大约就是11.5 billion。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">10</h3>
<div class="outline-text-3" id="text-2-5">
<p>
估算城市的死亡率。
</p>

<p>
假定大家平均生命是70年，根据Little&#8217;s law，那么每年的死亡率就是1/70=1.4%的城市人口。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">11</h3>
<div class="outline-text-3" id="text-2-6">
<p>
证明利特尔法则(Little&#8217;s law)。
</p>

<img src="http://dreamrunner.org/images/blog/2014/programmingpearls/column7_11.jpg" title="'column7_11'" />

<p>
时间T进入个数为N(T)，那么到达速率 &lambda;(T) = N(T)/T;
</p>

<p>
时间T离开个数为C(T)，那么离开速率 X = C(T)/T;
</p>

<p>
系统中，时间T中堆积的个数平均为阴影部分A(T),那么平均等待的个数为L(T) =
A(T)/T;
</p>

<p>
时间T离开个数为C(T)，时间T中堆积的个数A(T)，那么每个的等待时间是
W(T)=A(T)/C(T)。
</p>

<p>
可以得到L(T)=C(T)W(T),均衡系统&lambda;(T)=C(T),即L(T)=&lambda;(T)W(T)。
</p>

<p>
完善的数学证明这里：
<a href="http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf">http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf</a>
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">12</h3>
<div class="outline-text-3" id="text-2-7">
<p>
美国报纸说25美分的硬币平均寿命是30年。你如何检测这个声明？
</p>

<p>
硬币制造厂每年平均最小为每个人制造1枚25美分的硬币，最多不会超过100枚，那么几何平均就是10枚，加入它的平均寿命是30年，那么平均每人就有300枚25
美分的硬币在手里，算上手头，家里抽屉，公司抽屉所有的25美分，应该不会超过300枚，所以这个声明的数字有点偏高。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column3]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/13/column3/"/>
    <updated>2014-05-13T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/13/column3</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
<p>
主旨是：don&#8217;t wirte a big program when a little one will do.
</p>

<!-- more -->

<p>
一些原则：
</p>
<ol class="org-ol">
<li>重构重复的代码到数组。
</li>
<li>封装复杂的结构。
</li>
<li>尽可能使用高级工具。
</li>
<li>让数据来构建程序。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>建立一张税收表格，包括1.这个一行数据范围的最低收入; 2.税收的基本费用; 和3.税收比率。
</li>
<li>用给定税收，二分搜索所处范围，也就是表格的哪一栏。用公式算出税收。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
编写标语函数，输入一个大写字母，输出一个字符数组，该字符数组用字符图形方式描绘该字母
</p>

<ol class="org-ol">
<li>用一个定义的模板语言为每个字母定义标语的格式，存入一个table中;
</li>
<li>写一个对这个自定义模板语言的解析程序，把它解析成打印标语;
</li>
<li>输入一个单词，直接读取table相应的模板格式，用解析程序解析。
</li>
</ol>

<p>
如字母I如下，可以把它编码成：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 lines 9 X
6 lines 3 blank 3 X 3 blank
3 lines 9 X
</pre>
</div>
<p>
或更简化：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 9 X
6 3 b 3 x 3 b
3 9 x
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">4</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Date</span> {
  <span style="color: #87cefa;">Date</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_in</span>) {
    year = year_in;
    month = month_in;
    day = day_in;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>;
};

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMonthDays</span>[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">KDaysOfWeek</span> = 7;
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">YearDays</span> {
  <span style="color: #eedd82;">kNormYearDays</span> = 365,
  <span style="color: #eedd82;">kLeapYearDays</span> = 366,
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsLeapYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">year</span>) {
  <span style="color: #00ffff;">if</span> ((year % 400 == 0) ||
      (((year % 4) == 0) &amp;&amp; (year % 100) != 0)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MonthDaysOfYear</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = kMonthDays[month];
  <span style="color: #00ffff;">if</span> (month == 2 &amp;&amp; IsLeapYear(year)) {
    days++;
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysOfYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  days += date.day;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; date.month; ++i) {
    days += MonthDaysOfYear(date.year, i);
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysBetween</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_pre</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_next</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_</span> = date_pre.year; year_ &lt; date_next.year; ++year_) {
    days += (IsLeapYear(year_) ? kLeapYearDays : kNormYearDays);
  }
  days += DaysOfYear(date_next);
  days -= DaysOfYear(date_pre);
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintCalendar</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">calendar</span>) {
  printf(<span style="color: #ffa07a;">"Sun Mon Tue Wed Thu Fri Sat\n"</span>);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; KDaysOfWeek - calendar[0].size(); ++i) {
    printf(<span style="color: #ffa07a;">"    "</span>);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; calendar.size(); ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; calendar[i].size(); ++j) {
      printf(<span style="color: #ffa07a;">"%-4d"</span>, calendar[i][j]);
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DayOfWeek</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">kFirstDate</span>(1900, 1, 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Mon</span>
  <span style="color: #00ffff;">return</span> (DaysBetween(kFirstDate, date) % 7 + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">CalendarOfMonth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">calendar</span>) {
  <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">first_of_month</span>(year, month, 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_of_week</span> = DayOfWeek(first_of_month);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; MonthDaysOfYear(year, month); ++i) {
    temp.push_back(i);
    <span style="color: #00ffff;">if</span> ((day_of_week + i) % KDaysOfWeek == 6) {
      calendar-&gt;push_back(temp);
      temp.clear();
    }
  }
  printf(<span style="color: #ffa07a;">"Year:%d Month:%d\n"</span>, year, month);
  PrintCalendar(*calendar);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
查找后缀连字符的连接。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">kHyphWords</span>[] = {<span style="color: #ffa07a;">"et-ic"</span>, <span style="color: #ffa07a;">"al-is-tic"</span>, <span style="color: #ffa07a;">"s-tic"</span>, <span style="color: #ffa07a;">"p-tic"</span>, <span style="color: #ffa07a;">"-lyt-ic"</span>,
                      <span style="color: #ffa07a;">"ot-ic"</span>, <span style="color: #ffa07a;">"an-tic"</span>, <span style="color: #ffa07a;">"n-tic"</span>, <span style="color: #ffa07a;">"c-tic"</span>, <span style="color: #ffa07a;">"at-ic"</span>,
                      <span style="color: #ffa07a;">"h-nic"</span>, <span style="color: #ffa07a;">"n-ic"</span>, <span style="color: #ffa07a;">"m-ic"</span>, <span style="color: #ffa07a;">"l-lic"</span>, <span style="color: #ffa07a;">"b-lic"</span>,
                      <span style="color: #ffa07a;">"-clic"</span>, <span style="color: #ffa07a;">"l-ic"</span>, <span style="color: #ffa07a;">"h-ic"</span>, <span style="color: #ffa07a;">"f-ic"</span>, <span style="color: #ffa07a;">"d-ic"</span>,
                      <span style="color: #ffa07a;">"-bic"</span>, <span style="color: #ffa07a;">"a-ic"</span>, <span style="color: #ffa07a;">"-mac"</span>, <span style="color: #ffa07a;">"i-ac"</span>};

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">reverse_hyphs</span> = <span style="color: #7fffd4;">NULL</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseHypenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">reverse_word</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">kHypen</span> = <span style="color: #ffa07a;">'-'</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = strlen(word) - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0, j = 0; i &lt;= len; ++i) {
    <span style="color: #00ffff;">if</span> (word[len - i] == kHypen)
      <span style="color: #00ffff;">continue</span>;
    reverse_word[j++] = word[len - i];
  }
  reverse_word[j] = <span style="color: #ffa07a;">'\0'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RerverseWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">string</span> *<span style="color: #eedd82;">reverse_word</span>) {
  *reverse_word = word;
  reverse(reverse_word-&gt;begin(), reverse_word-&gt;end());
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PreProcessHyphenation</span>() {
  <span style="color: #00ffff;">if</span> (reverse_hyphs != <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  } <span style="color: #00ffff;">else</span> {
    reverse_hyphs = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;string&gt;();
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(kHyphWords) / <span style="color: #00ffff;">sizeof</span>(kHyphWords[0]);
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMaxLen</span> = 10;
      <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">reverse_word</span>[kMaxLen];
      ReverseHypenation(kHyphWords[i], reverse_word);
      reverse_hyphs-&gt;push_back(<span style="color: #98fb98;">string</span>(<span style="color: #eedd82;">reverse_word</span>));
    }
  }
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsBeginWith</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">begin_letter</span>) {
  <span style="color: #00ffff;">if</span> (word.size() &lt; begin_letter.size()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; begin_letter.size(); ++i) {
    <span style="color: #00ffff;">if</span> (begin_letter[i] != word[i]) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">FindHyphenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  PreProcessHyphenation();
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">reverse_word</span>;
  RerverseWord(word, &amp;reverse_word);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; reverse_hyphs-&gt;size(); ++i) {
    <span style="color: #00ffff;">if</span> (IsBeginWith(reverse_word, reverse_hyphs-&gt;at(i))) {
      <span style="color: #00ffff;">return</span> string(kHyphWords[i]);
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress中添加目录]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/11/octopresszhong-tian-jia-mu-lu/"/>
    <updated>2014-05-11T17:01:34+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/11/octopresszhong-tian-jia-mu-lu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">目的</a></li>
  <li><a href="#section-1">生成文章目录</a>    <ul>
      <li><a href="#kramdown">使用Kramdown</a></li>
      <li><a href="#section-2">在博文中开头加入</a></li>
      <li><a href="#section-3">添加样式</a></li>
      <li><a href="#section-4">只在文章里显示</a></li>
      <li><a href="#section-5">效果</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">目的</h2>
<p>为Blog加入目录，方便读者快速浏览主题和选择主题。搜索发现
<a href="http://brizzled.clapper.org/blog/2012/02/04/generating-a-table-of-contents-in-octopress/">文章1</a>
使用jQuery来实现，比较复杂，和
<a href="http://blog.riemann.cc/2013/04/10/table-of-contents-in-octopress/#">文章2</a>
使用kramdown和Octoptress本身的样式来生成目录。</p>

<!-- more -->

<h2 id="section-1">生成文章目录</h2>

<h3 id="kramdown">使用Kramdown</h3>
<p>Kramdown能自动为文章生成目录<sup id="fnref:f1"><a href="#fn:f1" rel="footnote">1</a></sup>,所以使用Kramdown作为你的Octopress转
换程序，并且它支持Latex写公式，<a href="http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/">如何用krramdown替换rdiscount</a>。</p>

<h3 id="section-2">在博文中开头加入</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">* Will be replaced with the ToC, excluding the "Contents" header
</span><span class="line">{:toc}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-3">添加样式</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sass/custom/_styles.scss</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="scss"><span class="line"><span class="nn">#markdown-toc</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class="line">  <span class="na">content</span><span class="o">:</span> <span class="s2">&quot;Table of Contents&quot;</span><span class="p">;</span>
</span><span class="line">  <span class="na">font-weight</span><span class="o">:</span> <span class="no">bold</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nt">ul</span><span class="nn">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">  <span class="na">list-style</span><span class="o">:</span> <span class="no">none</span><span class="p">;</span>
</span><span class="line">  <span class="na">float</span><span class="o">:</span> <span class="no">right</span><span class="p">;</span>
</span><span class="line">  <span class="k">@include</span><span class="nd"> shadow-box</span><span class="p">;</span>
</span><span class="line">  <span class="na">background-color</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-4">只在文章里显示</h3>
<p>因为目录的链接只针对当前文章，如果使用<code>&lt;!-- more --&gt;</code>只显示部分文章在
主页上，那么点击目录链接就会有问题，所以在主页隐去目录。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sass/custom/_styles.scss</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scss"><span class="line"><span class="nc">.blog-index</span> <span class="nn">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">  <span class="na">display</span><span class="o">:</span> <span class="no">none</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">效果</h3>
<p>效果就如这篇文章。</p>

<div class="footnotes">
  <ol>
    <li id="fn:f1">
      <p>http://kramdown.gettalong.org/converter/html.html#toc<a href="#fnref:f1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column2]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/11/column2/"/>
    <updated>2014-05-11T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/11/column2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一个文件中有4十亿的32位整数，已随机排序，如何找如一个不在这个文件中的
32位数？有足够的内存如何解决？如果你可以用很多外部存储文件但是只有几百个字节的主内存，如何解决？
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">足够的内存</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
利用Column1的比特映射技能，
</p>
<ol class="org-ol">
<li>把所有的数一一映射到内存中的比特位;
</li>
<li>扫描比特位，是0的就是确实的数所在位置。
</li>
</ol>

两次扫描，复杂度 $\mathcal{O}(N)$。
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">有限的内存</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Ed Reingold 的方法：
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是0，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是1，Step 3选组组1;
若相等，随便选一组（两组中都有缺失数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>

<p>
这里以两组内存数组代表外部存储文件：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">find_missing</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nbits</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_zero</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_one</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = len;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 0;
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p_in</span> = array;

  <span style="color: #00ffff;">while</span> (nbits--) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_zero</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_one</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_bit</span> = 1 &lt;&lt; nbits;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">if</span> (p_in[i] &amp; leading_bit) {
        leading_one[count_leading_one++] = p_in[i];
      } <span style="color: #00ffff;">else</span> {
        leading_zero[count_leading_zero++] = p_in[i];
      }
    }
    <span style="color: #00ffff;">if</span> (count_leading_one &lt;= count_leading_zero) {
      res |= leading_bit;
      n = count_leading_one;
      p_in = leading_one;
    } <span style="color: #00ffff;">else</span> {
      n = count_leading_zero;
      p_in = leading_zero;
    }
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">B</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在第i个位置翻转一个n个元素的一维数组。比如n=8,i=3,数组abcdefgh翻转到
defghabc。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Juggling法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
是把前面的元素翻转到后面，逐个移位，翻转位为k：
</p>
<ol class="org-ol">
<li>t存储元素 <code>x[0]</code> ;
</li>
<li>移动 <code>x[k]</code> &#x2013;&gt; <code>x[0]</code>, <code>x[2k]</code> &#x2013;&gt; <code>x[k]</code>, 并偏移i×k是总数n的模;
</li>
<li>当 <code>(i*k)%n</code> 回到 Step 1中的起始元素时，用t赋值，并停止Step 2
</li>
<li>若所有元素都得到移动，结束整个算法，若有元素没有得到移动，选取Step 1中的下一个元素啊继续进行Step1-4.
</li>
</ol>

<p>
在Step4中判断所有元素是否得到移动，比较不易，那么如果知道一共要进行
Step1-4几次呢？
</p>

<p>
Step1的起始位i，Step2中移位位置 <code>(i+j*k)/n</code> ,什么时候等于i呢？
j*k第一次被k整除，也就是j*k是k与n的最小工倍数（lcm, least common
multiple), Step1-4运行一次移动 <code>lcm/k</code> 个元素，一共需要次数
<code>n/(lcm/k)=n*k/lcm</code> 也就是k与n的最大公约数。
</p>

<p>
Step1-4一共运行n和k的最大公约数次。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gcd</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">if</span> (m &lt; n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
    temp = m;
    m = n;
    n = m;
  }
  <span style="color: #00ffff;">while</span> (n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = n;
    n = m % n;
    m = temp;
  }
  <span style="color: #00ffff;">return</span> m;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_gcd</span> = gcd(n, k);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num_gcd; ++i) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">temp</span> = array[i];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span> = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span>;
    <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
      next = prev + k;
      <span style="color: #00ffff;">if</span> (next &gt;= n) {
        next -= n;
      }
      <span style="color: #00ffff;">if</span> (next == i) {
        <span style="color: #00ffff;">break</span>;
      }
      array[prev] = array[next];
      prev = next;
    }
    array[prev] = temp;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Block Swap法</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
翻转数组x，相当于翻转ab到ba，假如a的长度短于b，
</p>
<ol class="org-ol">
<li>把b分为ab<sub>l</sub> b<sub>r</sub> 并且 b<sub>r</sub> 长度与a相同
</li>
<li>交换a与b<sub>r</sub> 得到 b<sub>r</sub> b<sub>l</sub> a;
</li>
<li>a达到最终位置，继续处理 b<sub>r</sub> b<sub>l</sub> ，回到step 1.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">swap array[m..m+len], array[n..n+len]</span>
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; len; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[m + i];
    array[m + i] = array[n + i];
    array[n + i] = temp;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (k == 0 || k == n) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array[0..p-i-1]:final stage</span>
<span style="color: #ff7f24;">   * array[p-i..p-1]:the string a to be swaped</span>
<span style="color: #ff7f24;">   * array[p..p+j-1]:the string b to be swaped</span>
<span style="color: #ff7f24;">   * array[p+j..n-1]:final stage</span>
<span style="color: #ff7f24;">   */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = n - k;
  <span style="color: #00ffff;">while</span> (i != j) {
    <span style="color: #00ffff;">if</span> (i &lt; j) {
      swap(array, p - i, p + j - i, i);
      j -= i;
    } <span style="color: #00ffff;">else</span> {
      swap(array, p - i, p, j);
      i -= j;
    }
  }
  swap(array, p - i, p, i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Reversal法</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
翻转数组x，相当于翻转ab到ba
</p>
<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup>,
</li>
<li>整个翻转， ba
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reverse</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>) {
  <span style="color: #00ffff;">while</span> (s &lt; e) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[s];
    array[s] = array[e];
    array[e] = temp;
    s++;
    e--;
  }
}
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  reverse(array, 0, k - 1);
  reverse(array, k, n - 1);
  reverse(array, 0, n - 1);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">C</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个英文字典中，找出所有回文单词。
</p>

<ol class="org-ol">
<li>为每个单词生成相对应的特征码 pans &#x2013;&gt; anps pans;
</li>
<li>按照特征码排序;
</li>
<li>按照相同的特征码，提取相应回文单词组。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span> <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cin</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">string</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;map&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">multimap</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">sort</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">pair</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">classcomp</span> {
  <span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">rhs</span>) <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">if</span> (lhs.compare(rhs) &lt; 0) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">stringcomp</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> a &lt; b;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">signWord</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sign</span> = word;
  sort(sign.begin(), sign.end(), stringcomp);
  words_map-&gt;insert(pair&lt;string, string&gt;(sign, word));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">squash</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
            <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">old_sig</span>;
  old_sig = words_map-&gt;begin()-&gt;first;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">anagram_vector</span>;
  <span style="color: #00ffff;">for</span> (multimap&lt;string, string, classcomp&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = words_map-&gt;begin();
       it != words_map-&gt;end(); ++it) {
    <span style="color: #00ffff;">if</span> ((*it).first == old_sig) {
      anagram_vector.push_back((*it).second);
    } <span style="color: #00ffff;">else</span> {
      anagram_words-&gt;push_back(anagram_vector);
      old_sig = (*it).first;
      anagram_vector.clear();
      anagram_vector.push_back(old_sig);
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span> = <span style="color: #00ffff;">new</span>
      <span style="color: #98fb98;">multimap</span>&lt;string, <span style="color: #eedd82;">string</span>, <span style="color: #eedd82;">classcomp</span>&gt;();
  <span style="color: #00ffff;">while</span> (cin &gt;&gt; word) {
    signWord(words_map, word);
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;string&gt; &gt;();
  squash(words_map, anagram_words);

  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = anagram_words-&gt;begin();
       it != anagram_words-&gt;end(); ++it) {
    <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it_inter</span> = it-&gt;begin();
        it_inter != it-&gt;end(); ++it_inter) {
      cout &lt;&lt; *it_inter &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
    cout &lt;&lt; endl;
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
给一个单词，在字典中找出它的所有回文单词。
</p>

<ol class="org-ol">
<li>不能预处理词典。顺序的读取词典，算出每个单词的特征码，与给定单词的特征码比较
</li>
<li>可以预处理读取词典，算出每个单词的特征码，并按照特征码排序。二分搜索与给定单词特征码相等的回文单词。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
给定一个包含4300000000个32位整数的顺序文件，请问如何找到一个至少出现两次的整数？
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">内存足够</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
bitmap映射法：
</p>
<ol class="org-ol">
<li>申请足够的bit位，并初始化为0;
</li>
<li>把每个数一一映射到内存中相应bit位，若发现相应位置为0,则置为1,反之，找到重复元素。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">内存不够</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
4300000000大于2的32次方，同上面找缺失元素类似
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是1，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是0，Step 3选组组1;
若相等，随便选一组（两组中都有重复数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">若总数并不大于范围数</h4>
<div class="outline-text-4" id="text-2-2-3">
一个大小为n的数组，里面的数范围[0,n-1],有不确定的重复元素，找到至少一
个重复元素，要求 $\mathcal{O}(1)$ 空间和 $\mathcal{O}(N)$ 时间。

<p>
利用Radix排序的思想实现：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">FindErrors</span> {
  <span style="color: #eedd82;">kFind</span> = 0,
  <span style="color: #eedd82;">kNotFind</span>,
};

<span style="color: #98fb98;">FindErrors</span> <span style="color: #87cefa;">RadixFindDuplicate</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">dup_num</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">while</span> (i != array[i]) {
      <span style="color: #00ffff;">if</span> (array[i] == array[array[i]]) {
        *dup_num = array[i];
        <span style="color: #00ffff;">return</span> kFind;
      }
      swap(array[i], array[array[i]]);
    }
  }
  <span style="color: #00ffff;">return</span> kNotFind;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
参考如上问题A。
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
比较书中问题A的3个不同算法。
</p>

<p>
缓存机制影响。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
翻转abc数组到cba。
</p>

<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b c,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup> c,
</li>
<li>翻转c， a<sup>r</sup> b<sup>r</sup> c<sup>r</sup> ,
</li>
<li>整个翻转， cba.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
9键电话拨号，号码上有字母，拨一个号产生一个英文名字序列。现在给出一个名字的拨号序列，找出电话本冲突的名字？
</p>

<ol class="org-ol">
<li>算出所有电话本里名字对应的拨号序列。
</li>
<li>二分法：排序拨号序列，然后用给出的拨号序列二分搜索找出所有相同的序列所对应的人名。
Hash或数据库：把拨号需类hash化或存储在数据库中，然后用给定的拨号序列直接查找得到相应人名。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
转置矩阵。
</p>

<p>
为每条记录加上行号与列号。然后调用排序算法，先按列排序，然后按行排序。最后删除行号与列号得到转置矩阵。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MatrixElem</span> {
  <span style="color: #87cefa;">MatrixElem</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_data</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_row</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_col</span>) {
    data = i_data;
    row = i_row;
    col = i_col;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span>;
};

<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">bool RowComp(const MatrixElem &amp;lhs, const MatrixElem &amp;rhs) {</span>
<span style="color: #ff7f24;">  return lhs.row &lt; rhs.row;</span>
<span style="color: #ff7f24;">  }*/</span>

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">MatrixElemComp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">rhs</span>) {
  <span style="color: #00ffff;">if</span> (lhs.col == rhs.col) {
    <span style="color: #00ffff;">return</span> lhs.row &lt; rhs.row;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> lhs.col &lt; rhs.col;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TransposeMatrix</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">matrix</span>, 
                     <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">trans_matrix</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MatrixElem</span>&gt; <span style="color: #eedd82;">matrix_vector</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_col</span>;
  n_row = matrix.size();
  <span style="color: #00ffff;">if</span> (n_row &lt; 1) {
    <span style="color: #00ffff;">return</span>;
  }
  n_col = matrix[0].size();

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0; row &lt; n_row; ++row) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span> = 0; col &lt; n_col; ++col) {
      <span style="color: #98fb98;">MatrixElem</span> <span style="color: #eedd82;">elem</span> = MatrixElem(matrix[row][col], row, col);
      matrix_vector.push_back(elem);
    }
  }

  sort(matrix_vector.begin(), matrix_vector.end(), MatrixElemComp);

  trans_matrix-&gt;resize(n_row);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0;  row &lt; n_row; ++row) {
    (trans_matrix-&gt;at(row)).resize(n_col);
  }

  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; matrix_vector.size(); ++i) {
    (*trans_matrix)[i / n_row][i % n_row] = matrix_vector[i].data;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
给定n个实数，一个实数t，和整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。
</p>

<p>
也就是找出n个中的k个最小数问题。
</p>
</div>

<div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">堆</h4>
<div class="outline-text-4" id="text-2-8-1">
<ol class="org-ol">
<li>建立一个k大小的最大堆;
</li>
<li>遍历n个实数，与最大堆比较
</li>
<li>最大堆k个元素即k个最小值，相加所有与t比较。
</li>
</ol>

算法复杂度：  $\mathcal{O}(n*logk)$。
</div>
</div>

<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2">Random Selection</h4>
<div class="outline-text-4" id="text-2-8-2">
<ol class="org-ol">
<li>随机选定一个值作为pivot，然后通过swap，使得最终pivot左边的数都小于
pivot，pivot右边的数都大于pivot。
</li>
<li>如果返回pivot的index小于k，则在pivot的右半段递归查找。
</li>
<li>如果返回pivot的index大于k，则在pivot的做半段递归查找。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RandomSelectionK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  swap(array[l], array[randint(l, u)]);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pivot</span> = array[l];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = u + 1;
  <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; pivot);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; pivot);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array[i], array[j]);
  }
  swap(array[l], array[j]);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    RandomSelectionK(array, j + 1, u, k);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    RandomSelectionK(array, l, j - 1, k);
  }
}
</pre>
</div>
算法平均时间复杂度： $\mathcal{O}(n)$ 。
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column1]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/10/column1/"/>
    <updated>2014-05-10T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/10/column1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Bitmap Data Structure</h3>
<div class="outline-text-3" id="text-1-1">
<p>
这个数据结构用来表明在有限域中的一个密集集合，当集合中每个元素最多出现一次且没有其他数据与这些元素相关。即使这些情况得不到满足（比如，当有多个相同元素或其他附加数据），一个来自有限域的键能被在一个复杂数据表中用来做索引。
</p>

<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    clr_bit(i);
  }
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;i) != EOF) {
    set_bit(i);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    <span style="color: #00ffff;">if</span> (test_bit(i)) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, i);
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
如果内存足够大，如何用库实现排序算法。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">comp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(a) -
          *<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(b));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[10000];
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;array[n]) != EOF) {
    ++n;
  }
  qsort(array, n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), comp);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, array[i]);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如何使用bit操作来实现bit数组？
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 4</h3>
<div class="outline-text-3" id="text-2-3">
<p>
如何在0到n-1间随机生成k个唯一的随机整数？
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctime&gt;</span>

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">generate_unique_random</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">out</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; n; ++i) {
    num[i] = i;
  }
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; k; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = randint(i, n - 1);
    <span style="color: #7fffd4;">std</span>::swap(num[i], num[p]);
    out[i] = num[i];
  }
}
</pre>
</div>

<p>
类似于洗牌问题或不知道n时，选取随机数：
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Fisher%E2%80%93Yates%20shuffle.html">Fisher–Yates shuffle</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
使用两次传递算法，第一次排序0-4,999,999，第二次排序
5,000,000-9,999,999.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 6</h3>
<div class="outline-text-3" id="text-2-5">
<p>
每个整数最多出现10次，用4bit就可以表示，多需要空间n×4bit就来存储每个数的个数就可以。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 9</h3>
<div class="outline-text-3" id="text-2-6">
<p>
One problem with trading more space to use less time is that
initializing the space can itself take a great deal of time. Show how
to circumvent this problem by designing a technique to initialize an
entry of a vector to zero the first time it is accessed. Your scheme
should use constant time for initialization and for each vector
access, and use extra space proportional to the size of the vector.
</p>

<p>
data[0&#x2026;n-1]是这个未初始化的数组，每个元素都是个随机数，额外添加两个数组from[0..n-1]和to[0&#x2026;n]，和一个 <code>top</code> 变量。如果元素 <code>data[i]</code> 已经被访问过，那么 <code>from[i] &lt; top</code> 且 <code>to[from[i]] = i</code> 。访问过的如下图：
</p>

<img src="http://dreamrunner.org/images/blog/2014/programmingpearls/column1_9.jpg" title="'column1_9'" />
<p>
代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">if</span> (from[i] &lt; top &amp;&amp; to[from[i]] = i) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">has been accessed</span>
} <span style="color: #00ffff;">else</span> {
  from[i] = top;
  to[top] = i;
  data[i] = 0;
  top++;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 10</h3>
<div class="outline-text-3" id="text-2-7">
<p>
open hashing with collision resolution by sequential search.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 11</h3>
<div class="outline-text-3" id="text-2-8">
<p>
扫描图纸，通过信鸽载送35nm的影片到测试站，在那里图纸得到重新放大和打印。
</p>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> 12</h3>
<div class="outline-text-3" id="text-2-9">
<p>
用铅笔。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式基本原则]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/05/设计模式基本原则</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 封装那些改变的</h2>
<div class="outline-text-2" id="text-1">
<p>
识别出应用里改变的方面，然后把它们从不变部分里分离出来封装。这样变化的部分就不会影响到不变的部分。那么，之后代码改变的话，只需要修改封装好的变化部分，不引起无意的修改，并提供更好的扩展灵活性。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 面向接口编程，而不是实现</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>由接口定义要实现的每个行为；
</li>
<li>只要依照接口定义好的编程实现；
</li>
<li>我们只需要知道接口是如何，根本不需要实现的细节而去使用这个接口派生的对象；
</li>
<li>在运行时才赋值具体的实现对象。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 使用组合优于继承</h2>
<div class="outline-text-2" id="text-3">
<p>
使用组合创建系统提高灵活性。不单单可以使你把一族的算法封装成它们各自的类，同时让你在运行时可以改变算法行为。
</p>

<p>
而继承，子类直接实现好算法的具体行为，不能在运行时改变算法的行为，同时过多的继承加剧类图的复杂度。
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 追求交互对象间的松耦合</h2>
<div class="outline-text-2" id="text-4">
<p>
当两个对象松耦合时，它们能交互，但互相了解很少。松耦合让我们建立能适应变化的灵活系统，因为它们最小化对象间的内部依赖。
</p>

<p>
松耦合对象A和B：
</p>
<ol class="org-ol">
<li>A和B只要知道对方的接口，就可以互相调用对方;
</li>
<li>我们可以独立复用A或B;
</li>
<li>改变A或B不会影响对方。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 类需要对扩展开放，对修改闭合(The Open-Closed Principle)</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>开放：自由添加任何新的行为来扩展类。
</li>
<li>闭合：现有的代码经过长时间的测试和修正，不允许别人修改现有代码。
</li>
</ol>

<p>
目的是允许类能容易的被扩展新的行为而不用修改现有的代码。为了达到这个目的，模式设计需要能弹性改变并足够灵活来对变化需求的新功能做出反应。
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 依赖于抽象类，而不是依赖具体类（The Dependency Inversion Principle)</h2>
<div class="outline-text-2" id="text-6">
<p>
与“面向接口编程，而不是实现“原则类似，然而依赖反转原则对于抽象接口更严格：
</p>

<ol class="org-ol">
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 得墨忒耳定律(Law of Demeter or Principle of Least Knowledge)</h2>
<div class="outline-text-2" id="text-7">
<p>
得墨忒耳定律是松耦合的一种具体案例:
</p>
<ol class="org-ol">
<li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
</li>
<li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；
</li>
<li>只和自己直接的朋友交谈
</li>
</ol>

<p>
这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 好莱坞原则(Hollywood Principle)</h2>
<div class="outline-text-2" id="text-8">
<p>
总的概括就是：不要调用我们（高层次模块），我们会调用你（低层次模块）。
</p>

<p>
好莱坞原则提供一种防止依赖腐烂的方法。依赖腐烂发生当高层次模块依赖于低层次模块，低层次模块依赖于高层次模块，高层次模块又依赖于边际模块，边际模块依赖于低层次模块如此。当腐烂发生，没有人能轻易理解这个系统如何设计。
</p>

<p>
遵循好莱坞原则，允许低层次模块连入到系统中，但是由高层次模块决定什么时候它们被需要，和怎么使用它们。而不允许低层次的模块直接去调用一个高层次模块。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 单一功能原则（Single Responsibility Principle）</h2>
<div class="outline-text-2" id="text-9">
<p>
单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
</p>

<p>
也就是一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。
</p>

<p>
保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式附录一: 标识]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/05/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%99%84%E5%BD%95%E4%B8%80/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/05/浅谈设计模式附录一</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类图</h2>
<div class="outline-text-2" id="text-1">
<img src="http://dreamrunner.org/images/blog/2014/appendix/class_relationships.svg" />

<ol class="org-ol">
<li>实例化
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/appendix/instantiate.jpeg" />

<p>
CreateTool创建LineShape对象。
</p>

<!-- more -->

<ol class="org-ol">
<li>继承
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/appendix/subclass.jpeg" />

<p>
类LineShape是继承父类Shape.
</p>

<ol class="org-ol">
<li>委托
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/appendix/delegation.jpeg" />

<p>
委托是组合的一种方法，使组合具有继承的复用功能。LineShape保持Color对象的一个引用，当LineShape做一些Color的功能时，它不用从父类继承，它把功能委托给Color来完成。
</p>

<ol class="org-ol">
<li>聚合
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/appendix/aggregate.jpeg" />

<p>
聚合意味这一个对象拥有另一个对象或对对另一个对象负责。同时意味这一个聚合对象和它的拥有者具有相同的生命周期。
</p>

<ol class="org-ol">
<li>注释
</li>
</ol>
<img src="http://dreamrunner.org/images/blog/2014/appendix/annotation.svg" />

<p>
右边的框框表示对 <code>Draw()</code> 的注释。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十三: 访问者模式(Visitor)]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/04/浅谈设计模式23</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">实例</h2>
<div class="outline-text-2" id="text-1">
<p>
一辆汽车的结构是定的，但是对方不同部件的操作确实会时常变化，比如查看汽车各个部件，发动汽车对各个部件操作或修理部件等。那么如何在不改变汽车部件类的前提下，对其定义不同的操作呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">访问者模式(Visitor)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
表示在对象结构元素上进行的一个操作。访问者模式让你在不改变一个类的前提下，对这个类的元素定义新的操作。 
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
利用访问者设计模式，能很好的解决这个问题，一旦定义好汽车各个部件类，不用去修改它们，也能对它们定义新的操作。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/visitor">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">抽象元素类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
定义一个以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">汽车具体元素类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
这里仅仅定义了汽车部分结构类为例子，分别定义汽车的轮胎类，引擎类和车身类。都实现以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Wheel</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Wheel</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Wheel</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {<span style="color: #00ffff;">return</span> name_;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Engine</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Engine</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Body</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Body</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">对象结构</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
整辆车的组合，能枚举它的各个部件，用 <code>vector</code> 维护一个无序的汽车元素集合。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Car</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Car</span>();
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Car</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">CarElement</span> *&gt; <span style="color: #eedd82;">elements_array_</span>;
};

<span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">Car</span>() {
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front left"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front right"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Body</span>());
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Engine</span>());
}

<span style="color: #7fffd4;">Car</span>::~<span style="color: #87cefa;">Car</span>() {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    <span style="color: #00ffff;">delete</span> element;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  visit_elements(visitor);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    element-&gt;accept(visitor);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">抽象访问类</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
为结构中的具体元素类（ConcreteElement）类声明一个访问操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5">具体访问类1：访问汽车部件</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6">具体访问类2：启动汽车部件</h4>
<div class="outline-text-4" id="text-2-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Kicking my "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Starting my engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Moving my body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">访问者模式(Visitor)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://dreamrunner.org/images/blog/2014/visitor/visitor_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象访问类（Visitor）为结构中的具体元素类（ConcreteElement）类声明一个访问操作。这个操作的名字和签名标识了发送访问请求给访问类的类。以致能让访问者类决定正被访问元素的具体类。然后访问者类能直接通过它的特殊接口访问这个元素。
</li>
<li>具体访问类（ConcreteVisitor）实现抽象访问类声明的每个操作。每个操作实现部分的算法，而这些部分算法为相应的结构中对象类所定义。具体访问类（ConcreteVisitor）提供这算法的场景和存储它的本地状态。这一状态通常再遍历该结构的过程中积累结果。
</li>
<li>抽象元素类（Element）定义一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>具体元素类（ConcreteElement）实现一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>对象结构(ObjectStrucutre)
<ol class="org-ol">
<li>能枚举它的元素。
</li>
<li>可以提供允许访问类访问它的元素的上层接口。
</li>
<li>可以是一个组合或一个如列表或无序集合的集合。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象结构包含许多不同接口对象类，而且你想对这些对象进行一些依赖于它们具体类的操作。
</li>
<li>在一个对象结构中，需要对这些对象进行许多不相关不同的操作，而且你想避免以这些操作污染它们的类。访问者模式让你把相关的操作集中起来定义在一个类中。当这个对象结构被许多应用共享时，使用访问者模式让每个应用仅包含需要用到的操作。
</li>
<li>定义对象结构的类很少改变，但你时常想在这个结构上定义新的操作。改变对象结构类需要重定义对所有访问者类的结构，这潜在会是很大的开销。如果这些对象结构类经常改变，那么可能还是在这些类中定义这些操作。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>增加新的元素很困难。每增加一个新的元素将在抽象访问者类（Visitor)中增加一个新的抽象操作，并在每个具体访问类（ConcreteVisitor）中增加相应的操作。
</li>
<li>破坏封装性。访问者的方法假定具体元素类（ConcreteElement）接口足够强大让访问者对它元素进行操作。因而，这个模式强迫你提供能访问元素内部状态的公开操作，从而导致破坏了它的封装性。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
