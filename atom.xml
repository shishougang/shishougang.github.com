<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[(learn&think)]]></title>
  <link href="http://shishougang.github.com/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-05-13T23:04:38+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column3]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/13/column3/"/>
    <updated>2014-05-13T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/13/column3</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
<p>
主旨是：don&#8217;t wirte a big program when a little one will do.
</p>

<!-- more -->

<p>
一些原则：
</p>
<ol class="org-ol">
<li>重构重复的代码到数组。
</li>
<li>封装复杂的结构。
</li>
<li>尽可能使用高级工具。
</li>
<li>让数据来构建程序。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>建立一张税收表格，包括1.这个一行数据范围的最低收入; 2.税收的基本费用; 和3.税收比率。
</li>
<li>用给定税收，二分搜索所处范围，也就是表格的哪一栏。用公式算出税收。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
编写标语函数，输入一个大写字母，输出一个字符数组，该字符数组用字符图形方式描绘该字母
</p>

<ol class="org-ol">
<li>用一个定义的模板语言为每个字母定义标语的格式，存入一个table中;
</li>
<li>写一个对这个自定义模板语言的解析程序，把它解析成打印标语;
</li>
<li>输入一个单词，直接读取table相应的模板格式，用解析程序解析。
</li>
</ol>

<p>
如字母I如下，可以把它编码成：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 lines 9 X
6 lines 3 blank 3 X 3 blank
3 lines 9 X
</pre>
</div>
<p>
或更简化：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 9 X
6 3 b 3 x 3 b
3 9 x
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">4</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Date</span> {
  <span style="color: #87cefa;">Date</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_in</span>) {
    year = year_in;
    month = month_in;
    day = day_in;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>;
};

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMonthDays</span>[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">KDaysOfWeek</span> = 7;
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">YearDays</span> {
  <span style="color: #eedd82;">kNormYearDays</span> = 365,
  <span style="color: #eedd82;">kLeapYearDays</span> = 366,
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsLeapYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">year</span>) {
  <span style="color: #00ffff;">if</span> ((year % 400 == 0) ||
      (((year % 4) == 0) &amp;&amp; (year % 100) != 0)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MonthDaysOfYear</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = kMonthDays[month];
  <span style="color: #00ffff;">if</span> (month == 2 &amp;&amp; IsLeapYear(year)) {
    days++;
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysOfYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  days += date.day;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; date.month; ++i) {
    days += MonthDaysOfYear(date.year, i);
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysBetween</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_pre</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_next</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_</span> = date_pre.year; year_ &lt; date_next.year; ++year_) {
    days += (IsLeapYear(year_) ? kLeapYearDays : kNormYearDays);
  }
  days += DaysOfYear(date_next);
  days -= DaysOfYear(date_pre);
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintCalendar</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">calendar</span>) {
  printf(<span style="color: #ffa07a;">"Sun Mon Tue Wed Thu Fri Sat\n"</span>);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; KDaysOfWeek - calendar[0].size(); ++i) {
    printf(<span style="color: #ffa07a;">"    "</span>);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; calendar.size(); ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; calendar[i].size(); ++j) {
      printf(<span style="color: #ffa07a;">"%-4d"</span>, calendar[i][j]);
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DayOfWeek</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">kFirstDate</span>(1900, 1, 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Mon</span>
  <span style="color: #00ffff;">return</span> (DaysBetween(kFirstDate, date) % 7 + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">CalendarOfMonth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">calendar</span>) {
  <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">first_of_month</span>(year, month, 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_of_week</span> = DayOfWeek(first_of_month);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; MonthDaysOfYear(year, month); ++i) {
    temp.push_back(i);
    <span style="color: #00ffff;">if</span> ((day_of_week + i) % KDaysOfWeek == 6) {
      calendar-&gt;push_back(temp);
      temp.clear();
    }
  }
  printf(<span style="color: #ffa07a;">"Year:%d Month:%d\n"</span>, year, month);
  PrintCalendar(*calendar);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
查找后缀连字符的连接。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">kHyphWords</span>[] = {<span style="color: #ffa07a;">"et-ic"</span>, <span style="color: #ffa07a;">"al-is-tic"</span>, <span style="color: #ffa07a;">"s-tic"</span>, <span style="color: #ffa07a;">"p-tic"</span>, <span style="color: #ffa07a;">"-lyt-ic"</span>,
                      <span style="color: #ffa07a;">"ot-ic"</span>, <span style="color: #ffa07a;">"an-tic"</span>, <span style="color: #ffa07a;">"n-tic"</span>, <span style="color: #ffa07a;">"c-tic"</span>, <span style="color: #ffa07a;">"at-ic"</span>,
                      <span style="color: #ffa07a;">"h-nic"</span>, <span style="color: #ffa07a;">"n-ic"</span>, <span style="color: #ffa07a;">"m-ic"</span>, <span style="color: #ffa07a;">"l-lic"</span>, <span style="color: #ffa07a;">"b-lic"</span>,
                      <span style="color: #ffa07a;">"-clic"</span>, <span style="color: #ffa07a;">"l-ic"</span>, <span style="color: #ffa07a;">"h-ic"</span>, <span style="color: #ffa07a;">"f-ic"</span>, <span style="color: #ffa07a;">"d-ic"</span>,
                      <span style="color: #ffa07a;">"-bic"</span>, <span style="color: #ffa07a;">"a-ic"</span>, <span style="color: #ffa07a;">"-mac"</span>, <span style="color: #ffa07a;">"i-ac"</span>};

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">reverse_hyphs</span> = <span style="color: #7fffd4;">NULL</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseHypenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">reverse_word</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">kHypen</span> = <span style="color: #ffa07a;">'-'</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = strlen(word) - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0, j = 0; i &lt;= len; ++i) {
    <span style="color: #00ffff;">if</span> (word[len - i] == kHypen)
      <span style="color: #00ffff;">continue</span>;
    reverse_word[j++] = word[len - i];
  }
  reverse_word[j] = <span style="color: #ffa07a;">'\0'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RerverseWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">string</span> *<span style="color: #eedd82;">reverse_word</span>) {
  *reverse_word = word;
  reverse(reverse_word-&gt;begin(), reverse_word-&gt;end());
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PreProcessHyphenation</span>() {
  <span style="color: #00ffff;">if</span> (reverse_hyphs != <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  } <span style="color: #00ffff;">else</span> {
    reverse_hyphs = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;string&gt;();
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(kHyphWords) / <span style="color: #00ffff;">sizeof</span>(kHyphWords[0]);
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMaxLen</span> = 10;
      <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">reverse_word</span>[kMaxLen];
      ReverseHypenation(kHyphWords[i], reverse_word);
      reverse_hyphs-&gt;push_back(<span style="color: #98fb98;">string</span>(<span style="color: #eedd82;">reverse_word</span>));
    }
  }
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsBeginWith</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">begin_letter</span>) {
  <span style="color: #00ffff;">if</span> (word.size() &lt; begin_letter.size()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; begin_letter.size(); ++i) {
    <span style="color: #00ffff;">if</span> (begin_letter[i] != word[i]) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">FindHyphenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  PreProcessHyphenation();
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">reverse_word</span>;
  RerverseWord(word, &amp;reverse_word);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; reverse_hyphs-&gt;size(); ++i) {
    <span style="color: #00ffff;">if</span> (IsBeginWith(reverse_word, reverse_hyphs-&gt;at(i))) {
      <span style="color: #00ffff;">return</span> string(kHyphWords[i]);
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress中添加目录]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/11/octopresszhong-tian-jia-mu-lu/"/>
    <updated>2014-05-11T17:01:34+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/11/octopresszhong-tian-jia-mu-lu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">目的</a></li>
  <li><a href="#section-1">生成文章目录</a>    <ul>
      <li><a href="#kramdown">使用Kramdown</a></li>
      <li><a href="#section-2">在博文中开头加入</a></li>
      <li><a href="#section-3">添加样式</a></li>
      <li><a href="#section-4">只在文章里显示</a></li>
      <li><a href="#section-5">效果</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">目的</h2>
<p>为Blog加入目录，方便读者快速浏览主题和选择主题。搜索发现
<a href="http://brizzled.clapper.org/blog/2012/02/04/generating-a-table-of-contents-in-octopress/">文章1</a>
使用jQuery来实现，比较复杂，和
<a href="http://blog.riemann.cc/2013/04/10/table-of-contents-in-octopress/#">文章2</a>
使用kramdown和Octoptress本身的样式来生成目录。</p>

<!-- more -->

<h2 id="section-1">生成文章目录</h2>

<h3 id="kramdown">使用Kramdown</h3>
<p>Kramdown能自动为文章生成目录<sup id="fnref:f1"><a href="#fn:f1" rel="footnote">1</a></sup>,所以使用Kramdown作为你的Octopress转
换程序，并且它支持Latex写公式，<a href="http://dreamrunner.org/blog/2014/03/09/octopresszhong-shi-yong-latexxie-shu-xue-gong-shi/">如何用krramdown替换rdiscount</a>。</p>

<h3 id="section-2">在博文中开头加入</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">* Will be replaced with the ToC, excluding the "Contents" header
</span><span class="line">{:toc}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-3">添加样式</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sass/custom/_styles.scss</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="scss"><span class="line"><span class="nn">#markdown-toc</span><span class="nd">:before</span> <span class="p">{</span>
</span><span class="line">  <span class="na">content</span><span class="o">:</span> <span class="s2">&quot;Table of Contents&quot;</span><span class="p">;</span>
</span><span class="line">  <span class="na">font-weight</span><span class="o">:</span> <span class="no">bold</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nt">ul</span><span class="nn">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">  <span class="na">list-style</span><span class="o">:</span> <span class="no">none</span><span class="p">;</span>
</span><span class="line">  <span class="na">float</span><span class="o">:</span> <span class="no">right</span><span class="p">;</span>
</span><span class="line">  <span class="k">@include</span><span class="nd"> shadow-box</span><span class="p">;</span>
</span><span class="line">  <span class="na">background-color</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-4">只在文章里显示</h3>
<p>因为目录的链接只针对当前文章，如果使用<code>&lt;!-- more --&gt;</code>只显示部分文章在
主页上，那么点击目录链接就会有问题，所以在主页隐去目录。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>sass/custom/_styles.scss</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="scss"><span class="line"><span class="nc">.blog-index</span> <span class="nn">#markdown-toc</span> <span class="p">{</span>
</span><span class="line">  <span class="na">display</span><span class="o">:</span> <span class="no">none</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">效果</h3>
<p>效果就如这篇文章。</p>

<div class="footnotes">
  <ol>
    <li id="fn:f1">
      <p>http://kramdown.gettalong.org/converter/html.html#toc<a href="#fnref:f1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column2]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/11/column2/"/>
    <updated>2014-05-11T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/11/column2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一个文件中有4十亿的32位整数，已随机排序，如何找如一个不在这个文件中的
32位数？有足够的内存如何解决？如果你可以用很多外部存储文件但是只有几百个字节的主内存，如何解决？
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">足够的内存</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
利用Column1的比特映射技能，
</p>
<ol class="org-ol">
<li>把所有的数一一映射到内存中的比特位;
</li>
<li>扫描比特位，是0的就是确实的数所在位置。
</li>
</ol>

两次扫描，复杂度 $\mathcal{O}(N)$。
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">有限的内存</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Ed Reingold 的方法：
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是0，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是1，Step 3选组组1;
若相等，随便选一组（两组中都有缺失数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>

<p>
这里以两组内存数组代表外部存储文件：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">find_missing</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nbits</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_zero</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_one</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = len;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 0;
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p_in</span> = array;

  <span style="color: #00ffff;">while</span> (nbits--) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_zero</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_one</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_bit</span> = 1 &lt;&lt; nbits;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">if</span> (p_in[i] &amp; leading_bit) {
        leading_one[count_leading_one++] = p_in[i];
      } <span style="color: #00ffff;">else</span> {
        leading_zero[count_leading_zero++] = p_in[i];
      }
    }
    <span style="color: #00ffff;">if</span> (count_leading_one &lt;= count_leading_zero) {
      res |= leading_bit;
      n = count_leading_one;
      p_in = leading_one;
    } <span style="color: #00ffff;">else</span> {
      n = count_leading_zero;
      p_in = leading_zero;
    }
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">B</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在第i个位置翻转一个n个元素的一维数组。比如n=8,i=3,数组abcdefgh翻转到
defghabc。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Juggling法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
是把前面的元素翻转到后面，逐个移位，翻转位为k：
</p>
<ol class="org-ol">
<li>t存储元素 <code>x[0]</code> ;
</li>
<li>移动 <code>x[k]</code> &#x2013;&gt; <code>x[0]</code>, <code>x[2k]</code> &#x2013;&gt; <code>x[k]</code>, 并偏移i×k是总数n的模;
</li>
<li>当 <code>(i*k)%n</code> 回到 Step 1中的起始元素时，用t赋值，并停止Step 2
</li>
<li>若所有元素都得到移动，结束整个算法，若有元素没有得到移动，选取Step 1中的下一个元素啊继续进行Step1-4.
</li>
</ol>

<p>
在Step4中判断所有元素是否得到移动，比较不易，那么如果知道一共要进行
Step1-4几次呢？
</p>

<p>
Step1的起始位i，Step2中移位位置 <code>(i+j*k)/n</code> ,什么时候等于i呢？
j*k第一次被k整除，也就是j*k是k与n的最小工倍数（lcm, least common
multiple), Step1-4运行一次移动 <code>lcm/k</code> 个元素，一共需要次数
<code>n/(lcm/k)=n*k/lcm</code> 也就是k与n的最大公约数。
</p>

<p>
Step1-4一共运行n和k的最大公约数次。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gcd</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">if</span> (m &lt; n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
    temp = m;
    m = n;
    n = m;
  }
  <span style="color: #00ffff;">while</span> (n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = n;
    n = m % n;
    m = temp;
  }
  <span style="color: #00ffff;">return</span> m;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_gcd</span> = gcd(n, k);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num_gcd; ++i) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">temp</span> = array[i];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span> = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span>;
    <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
      next = prev + k;
      <span style="color: #00ffff;">if</span> (next &gt;= n) {
        next -= n;
      }
      <span style="color: #00ffff;">if</span> (next == i) {
        <span style="color: #00ffff;">break</span>;
      }
      array[prev] = array[next];
      prev = next;
    }
    array[prev] = temp;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Block Swap法</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
翻转数组x，相当于翻转ab到ba，假如a的长度短于b，
</p>
<ol class="org-ol">
<li>把b分为ab<sub>l</sub> b<sub>r</sub> 并且 b<sub>r</sub> 长度与a相同
</li>
<li>交换a与b<sub>r</sub> 得到 b<sub>r</sub> b<sub>l</sub> a;
</li>
<li>a达到最终位置，继续处理 b<sub>r</sub> b<sub>l</sub> ，回到step 1.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">swap array[m..m+len], array[n..n+len]</span>
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; len; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[m + i];
    array[m + i] = array[n + i];
    array[n + i] = temp;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (k == 0 || k == n) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array[0..p-i-1]:final stage</span>
<span style="color: #ff7f24;">   * array[p-i..p-1]:the string a to be swaped</span>
<span style="color: #ff7f24;">   * array[p..p+j-1]:the string b to be swaped</span>
<span style="color: #ff7f24;">   * array[p+j..n-1]:final stage</span>
<span style="color: #ff7f24;">   */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = n - k;
  <span style="color: #00ffff;">while</span> (i != j) {
    <span style="color: #00ffff;">if</span> (i &lt; j) {
      swap(array, p - i, p + j - i, i);
      j -= i;
    } <span style="color: #00ffff;">else</span> {
      swap(array, p - i, p, j);
      i -= j;
    }
  }
  swap(array, p - i, p, i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Reversal法</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
翻转数组x，相当于翻转ab到ba
</p>
<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup>,
</li>
<li>整个翻转， ba
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reverse</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>) {
  <span style="color: #00ffff;">while</span> (s &lt; e) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[s];
    array[s] = array[e];
    array[e] = temp;
    s++;
    e--;
  }
}
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  reverse(array, 0, k - 1);
  reverse(array, k, n - 1);
  reverse(array, 0, n - 1);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">C</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个英文字典中，找出所有回文单词。
</p>

<ol class="org-ol">
<li>为每个单词生成相对应的特征码 pans &#x2013;&gt; anps pans;
</li>
<li>按照特征码排序;
</li>
<li>按照相同的特征码，提取相应回文单词组。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span> <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cin</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">string</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;map&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">multimap</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">sort</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">pair</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">classcomp</span> {
  <span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">rhs</span>) <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">if</span> (lhs.compare(rhs) &lt; 0) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">stringcomp</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> a &lt; b;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">signWord</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sign</span> = word;
  sort(sign.begin(), sign.end(), stringcomp);
  words_map-&gt;insert(pair&lt;string, string&gt;(sign, word));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">squash</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
            <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">old_sig</span>;
  old_sig = words_map-&gt;begin()-&gt;first;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">anagram_vector</span>;
  <span style="color: #00ffff;">for</span> (multimap&lt;string, string, classcomp&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = words_map-&gt;begin();
       it != words_map-&gt;end(); ++it) {
    <span style="color: #00ffff;">if</span> ((*it).first == old_sig) {
      anagram_vector.push_back((*it).second);
    } <span style="color: #00ffff;">else</span> {
      anagram_words-&gt;push_back(anagram_vector);
      old_sig = (*it).first;
      anagram_vector.clear();
      anagram_vector.push_back(old_sig);
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span> = <span style="color: #00ffff;">new</span>
      <span style="color: #98fb98;">multimap</span>&lt;string, <span style="color: #eedd82;">string</span>, <span style="color: #eedd82;">classcomp</span>&gt;();
  <span style="color: #00ffff;">while</span> (cin &gt;&gt; word) {
    signWord(words_map, word);
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;string&gt; &gt;();
  squash(words_map, anagram_words);

  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = anagram_words-&gt;begin();
       it != anagram_words-&gt;end(); ++it) {
    <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it_inter</span> = it-&gt;begin();
        it_inter != it-&gt;end(); ++it_inter) {
      cout &lt;&lt; *it_inter &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
    cout &lt;&lt; endl;
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
给一个单词，在字典中找出它的所有回文单词。
</p>

<ol class="org-ol">
<li>不能预处理词典。顺序的读取词典，算出每个单词的特征码，与给定单词的特征码比较
</li>
<li>可以预处理读取词典，算出每个单词的特征码，并按照特征码排序。二分搜索与给定单词特征码相等的回文单词。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
给定一个包含4300000000个32位整数的顺序文件，请问如何找到一个至少出现两次的整数？
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">内存足够</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
bitmap映射法：
</p>
<ol class="org-ol">
<li>申请足够的bit位，并初始化为0;
</li>
<li>把每个数一一映射到内存中相应bit位，若发现相应位置为0,则置为1,反之，找到重复元素。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">内存不够</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
4300000000大于2的32次方，同上面找缺失元素类似
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是1，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是0，Step 3选组组1;
若相等，随便选一组（两组中都有重复数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">若总数并不大于范围数</h4>
<div class="outline-text-4" id="text-2-2-3">
一个大小为n的数组，里面的数范围[0,n-1],有不确定的重复元素，找到至少一
个重复元素，要求 $\mathcal{O}(1)$ 空间和 $\mathcal{O}(N)$ 时间。

<p>
利用Radix排序的思想实现：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">FindErrors</span> {
  <span style="color: #eedd82;">kFind</span> = 0,
  <span style="color: #eedd82;">kNotFind</span>,
};

<span style="color: #98fb98;">FindErrors</span> <span style="color: #87cefa;">RadixFindDuplicate</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">dup_num</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">while</span> (i != array[i]) {
      <span style="color: #00ffff;">if</span> (array[i] == array[array[i]]) {
        *dup_num = array[i];
        <span style="color: #00ffff;">return</span> kFind;
      }
      swap(array[i], array[array[i]]);
    }
  }
  <span style="color: #00ffff;">return</span> kNotFind;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
参考如上问题A。
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
比较书中问题A的3个不同算法。
</p>

<p>
缓存机制影响。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
翻转abc数组到cba。
</p>

<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b c,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup> c,
</li>
<li>翻转c， a<sup>r</sup> b<sup>r</sup> c<sup>r</sup> ,
</li>
<li>整个翻转， cba.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
9键电话拨号，号码上有字母，拨一个号产生一个英文名字序列。现在给出一个名字的拨号序列，找出电话本冲突的名字？
</p>

<ol class="org-ol">
<li>算出所有电话本里名字对应的拨号序列。
</li>
<li>二分法：排序拨号序列，然后用给出的拨号序列二分搜索找出所有相同的序列所对应的人名。
Hash或数据库：把拨号需类hash化或存储在数据库中，然后用给定的拨号序列直接查找得到相应人名。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
转置矩阵。
</p>

<p>
为每条记录加上行号与列号。然后调用排序算法，先按列排序，然后按行排序。最后删除行号与列号得到转置矩阵。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MatrixElem</span> {
  <span style="color: #87cefa;">MatrixElem</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_data</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_row</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_col</span>) {
    data = i_data;
    row = i_row;
    col = i_col;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span>;
};

<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">bool RowComp(const MatrixElem &amp;lhs, const MatrixElem &amp;rhs) {</span>
<span style="color: #ff7f24;">  return lhs.row &lt; rhs.row;</span>
<span style="color: #ff7f24;">  }*/</span>

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">MatrixElemComp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">rhs</span>) {
  <span style="color: #00ffff;">if</span> (lhs.col == rhs.col) {
    <span style="color: #00ffff;">return</span> lhs.row &lt; rhs.row;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> lhs.col &lt; rhs.col;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TransposeMatrix</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">matrix</span>, 
                     <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">trans_matrix</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MatrixElem</span>&gt; <span style="color: #eedd82;">matrix_vector</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_col</span>;
  n_row = matrix.size();
  <span style="color: #00ffff;">if</span> (n_row &lt; 1) {
    <span style="color: #00ffff;">return</span>;
  }
  n_col = matrix[0].size();

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0; row &lt; n_row; ++row) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span> = 0; col &lt; n_col; ++col) {
      <span style="color: #98fb98;">MatrixElem</span> <span style="color: #eedd82;">elem</span> = MatrixElem(matrix[row][col], row, col);
      matrix_vector.push_back(elem);
    }
  }

  sort(matrix_vector.begin(), matrix_vector.end(), MatrixElemComp);

  trans_matrix-&gt;resize(n_row);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0;  row &lt; n_row; ++row) {
    (trans_matrix-&gt;at(row)).resize(n_col);
  }

  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; matrix_vector.size(); ++i) {
    (*trans_matrix)[i / n_row][i % n_row] = matrix_vector[i].data;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
给定n个实数，一个实数t，和整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。
</p>

<p>
也就是找出n个中的k个最小数问题。
</p>
</div>

<div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">堆</h4>
<div class="outline-text-4" id="text-2-8-1">
<ol class="org-ol">
<li>建立一个k大小的最大堆;
</li>
<li>遍历n个实数，与最大堆比较
</li>
<li>最大堆k个元素即k个最小值，相加所有与t比较。
</li>
</ol>

算法复杂度：  $\mathcal{O}(n*logk)$。
</div>
</div>

<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2">Random Selection</h4>
<div class="outline-text-4" id="text-2-8-2">
<ol class="org-ol">
<li>随机选定一个值作为pivot，然后通过swap，使得最终pivot左边的数都小于
pivot，pivot右边的数都大于pivot。
</li>
<li>如果返回pivot的index小于k，则在pivot的右半段递归查找。
</li>
<li>如果返回pivot的index大于k，则在pivot的做半段递归查找。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RandomSelectionK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  swap(array[l], array[randint(l, u)]);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pivot</span> = array[l];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = u + 1;
  <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; pivot);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; pivot);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array[i], array[j]);
  }
  swap(array[l], array[j]);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    RandomSelectionK(array, j + 1, u, k);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    RandomSelectionK(array, l, j - 1, k);
  }
}
</pre>
</div>
算法平均时间复杂度： $\mathcal{O}(n)$ 。
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column1]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/10/column1/"/>
    <updated>2014-05-10T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/10/column1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Bitmap Data Structure</h3>
<div class="outline-text-3" id="text-1-1">
<p>
这个数据结构用来表明在有限域中的一个密集集合，当集合中每个元素最多出现一次且没有其他数据与这些元素相关。即使这些情况得不到满足（比如，当有多个相同元素或其他附加数据），一个来自有限域的键能被在一个复杂数据表中用来做索引。
</p>

<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    clr_bit(i);
  }
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;i) != EOF) {
    set_bit(i);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    <span style="color: #00ffff;">if</span> (test_bit(i)) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, i);
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
如果内存足够大，如何用库实现排序算法。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">comp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(a) -
          *<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(b));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[10000];
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;array[n]) != EOF) {
    ++n;
  }
  qsort(array, n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), comp);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, array[i]);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如何使用bit操作来实现bit数组？
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 4</h3>
<div class="outline-text-3" id="text-2-3">
<p>
如何在0到n-1间随机生成k个唯一的随机整数？
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctime&gt;</span>

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">generate_unique_random</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">out</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; n; ++i) {
    num[i] = i;
  }
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; k; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = randint(i, n - 1);
    <span style="color: #7fffd4;">std</span>::swap(num[i], num[p]);
    out[i] = num[i];
  }
}
</pre>
</div>

<p>
类似于洗牌问题或不知道n时，选取随机数：
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Fisher%E2%80%93Yates%20shuffle.html">Fisher–Yates shuffle</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
使用两次传递算法，第一次排序0-4,999,999，第二次排序
5,000,000-9,999,999.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 6</h3>
<div class="outline-text-3" id="text-2-5">
<p>
每个整数最多出现10次，用4bit就可以表示，多需要空间n×4bit就来存储每个数的个数就可以。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 9</h3>
<div class="outline-text-3" id="text-2-6">
<p>
One problem with trading more space to use less time is that
initializing the space can itself take a great deal of time. Show how
to circumvent this problem by designing a technique to initialize an
entry of a vector to zero the first time it is accessed. Your scheme
should use constant time for initialization and for each vector
access, and use extra space proportional to the size of the vector.
</p>

<p>
data[0&#x2026;n-1]是这个未初始化的数组，每个元素都是个随机数，额外添加两个数组from[0..n-1]和to[0&#x2026;n]，和一个 <code>top</code> 变量。如果元素 <code>data[i]</code> 已经被访问过，那么 <code>from[i] &lt; top</code> 且 <code>to[from[i]] = i</code> 。访问过的如下图：
</p>

<img src="http://shishougang.github.com/images/blog/2014/programmingpearls/column1_9.jpg" title="'column1_9'" />
<p>
代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">if</span> (from[i] &lt; top &amp;&amp; to[from[i]] = i) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">has been accessed</span>
} <span style="color: #00ffff;">else</span> {
  from[i] = top;
  to[top] = i;
  data[i] = 0;
  top++;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 10</h3>
<div class="outline-text-3" id="text-2-7">
<p>
open hashing with collision resolution by sequential search.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 11</h3>
<div class="outline-text-3" id="text-2-8">
<p>
扫描图纸，通过信鸽载送35nm的影片到测试站，在那里图纸得到重新放大和打印。
</p>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> 12</h3>
<div class="outline-text-3" id="text-2-9">
<p>
用铅笔。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式基本原则]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/05/设计模式基本原则</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 封装那些改变的</h2>
<div class="outline-text-2" id="text-1">
<p>
识别出应用里改变的方面，然后把它们从不变部分里分离出来封装。这样变化的部分就不会影响到不变的部分。那么，之后代码改变的话，只需要修改封装好的变化部分，不引起无意的修改，并提供更好的扩展灵活性。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 面向接口编程，而不是实现</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>由接口定义要实现的每个行为；
</li>
<li>只要依照接口定义好的编程实现；
</li>
<li>我们只需要知道接口是如何，根本不需要实现的细节而去使用这个接口派生的对象；
</li>
<li>在运行时才赋值具体的实现对象。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 使用组合优于继承</h2>
<div class="outline-text-2" id="text-3">
<p>
使用组合创建系统提高灵活性。不单单可以使你把一族的算法封装成它们各自的类，同时让你在运行时可以改变算法行为。
</p>

<p>
而继承，子类直接实现好算法的具体行为，不能在运行时改变算法的行为，同时过多的继承加剧类图的复杂度。
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 追求交互对象间的松耦合</h2>
<div class="outline-text-2" id="text-4">
<p>
当两个对象松耦合时，它们能交互，但互相了解很少。松耦合让我们建立能适应变化的灵活系统，因为它们最小化对象间的内部依赖。
</p>

<p>
松耦合对象A和B：
</p>
<ol class="org-ol">
<li>A和B只要知道对方的接口，就可以互相调用对方;
</li>
<li>我们可以独立复用A或B;
</li>
<li>改变A或B不会影响对方。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 类需要对扩展开放，对修改闭合(The Open-Closed Principle)</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>开放：自由添加任何新的行为来扩展类。
</li>
<li>闭合：现有的代码经过长时间的测试和修正，不允许别人修改现有代码。
</li>
</ol>

<p>
目的是允许类能容易的被扩展新的行为而不用修改现有的代码。为了达到这个目的，模式设计需要能弹性改变并足够灵活来对变化需求的新功能做出反应。
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 依赖于抽象类，而不是依赖具体类（The Dependency Inversion Principle)</h2>
<div class="outline-text-2" id="text-6">
<p>
与“面向接口编程，而不是实现“原则类似，然而依赖反转原则对于抽象接口更严格：
</p>

<ol class="org-ol">
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 得墨忒耳定律(Law of Demeter or Principle of Least Knowledge)</h2>
<div class="outline-text-2" id="text-7">
<p>
得墨忒耳定律是松耦合的一种具体案例:
</p>
<ol class="org-ol">
<li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
</li>
<li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；
</li>
<li>只和自己直接的朋友交谈
</li>
</ol>

<p>
这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 好莱坞原则(Hollywood Principle)</h2>
<div class="outline-text-2" id="text-8">
<p>
总的概括就是：不要调用我们（高层次模块），我们会调用你（低层次模块）。
</p>

<p>
好莱坞原则提供一种防止依赖腐烂的方法。依赖腐烂发生当高层次模块依赖于低层次模块，低层次模块依赖于高层次模块，高层次模块又依赖于边际模块，边际模块依赖于低层次模块如此。当腐烂发生，没有人能轻易理解这个系统如何设计。
</p>

<p>
遵循好莱坞原则，允许低层次模块连入到系统中，但是由高层次模块决定什么时候它们被需要，和怎么使用它们。而不允许低层次的模块直接去调用一个高层次模块。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 单一功能原则（Single Responsibility Principle）</h2>
<div class="outline-text-2" id="text-9">
<p>
单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
</p>

<p>
也就是一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。
</p>

<p>
保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式附录一: 标识]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/05/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%99%84%E5%BD%95%E4%B8%80/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/05/浅谈设计模式附录一</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类图</h2>
<div class="outline-text-2" id="text-1">
<img src="http://shishougang.github.com/images/blog/2014/appendix/class_relationships.svg" />

<ol class="org-ol">
<li>实例化
</li>
</ol>
<img src="http://shishougang.github.com/images/blog/2014/appendix/instantiate.jpeg" />

<p>
CreateTool创建LineShape对象。
</p>

<!-- more -->

<ol class="org-ol">
<li>继承
</li>
</ol>
<img src="http://shishougang.github.com/images/blog/2014/appendix/subclass.jpeg" />

<p>
类LineShape是继承父类Shape.
</p>

<ol class="org-ol">
<li>委托
</li>
</ol>
<img src="http://shishougang.github.com/images/blog/2014/appendix/delegation.jpeg" />

<p>
委托是组合的一种方法，使组合具有继承的复用功能。LineShape保持Color对象的一个引用，当LineShape做一些Color的功能时，它不用从父类继承，它把功能委托给Color来完成。
</p>

<ol class="org-ol">
<li>聚合
</li>
</ol>
<img src="http://shishougang.github.com/images/blog/2014/appendix/aggregate.jpeg" />

<p>
聚合意味这一个对象拥有另一个对象或对对另一个对象负责。同时意味这一个聚合对象和它的拥有者具有相同的生命周期。
</p>

<ol class="org-ol">
<li>注释
</li>
</ol>
<img src="http://shishougang.github.com/images/blog/2014/appendix/annotation.svg" />

<p>
右边的框框表示对 <code>Draw()</code> 的注释。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十三: 访问者模式(Visitor)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式23</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">实例</h2>
<div class="outline-text-2" id="text-1">
<p>
一辆汽车的结构是定的，但是对方不同部件的操作确实会时常变化，比如查看汽车各个部件，发动汽车对各个部件操作或修理部件等。那么如何在不改变汽车部件类的前提下，对其定义不同的操作呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">访问者模式(Visitor)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
表示在对象结构元素上进行的一个操作。访问者模式让你在不改变一个类的前提下，对这个类的元素定义新的操作。 
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
利用访问者设计模式，能很好的解决这个问题，一旦定义好汽车各个部件类，不用去修改它们，也能对它们定义新的操作。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/visitor">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">抽象元素类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
定义一个以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">汽车具体元素类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
这里仅仅定义了汽车部分结构类为例子，分别定义汽车的轮胎类，引擎类和车身类。都实现以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Wheel</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Wheel</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Wheel</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {<span style="color: #00ffff;">return</span> name_;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Engine</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Engine</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Body</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Body</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">对象结构</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
整辆车的组合，能枚举它的各个部件，用 <code>vector</code> 维护一个无序的汽车元素集合。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Car</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Car</span>();
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Car</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">CarElement</span> *&gt; <span style="color: #eedd82;">elements_array_</span>;
};

<span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">Car</span>() {
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front left"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front right"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Body</span>());
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Engine</span>());
}

<span style="color: #7fffd4;">Car</span>::~<span style="color: #87cefa;">Car</span>() {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    <span style="color: #00ffff;">delete</span> element;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  visit_elements(visitor);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    element-&gt;accept(visitor);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">抽象访问类</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
为结构中的具体元素类（ConcreteElement）类声明一个访问操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5">具体访问类1：访问汽车部件</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6">具体访问类2：启动汽车部件</h4>
<div class="outline-text-4" id="text-2-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Kicking my "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Starting my engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Moving my body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">访问者模式(Visitor)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/visitor/visitor_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象访问类（Visitor）为结构中的具体元素类（ConcreteElement）类声明一个访问操作。这个操作的名字和签名标识了发送访问请求给访问类的类。以致能让访问者类决定正被访问元素的具体类。然后访问者类能直接通过它的特殊接口访问这个元素。
</li>
<li>具体访问类（ConcreteVisitor）实现抽象访问类声明的每个操作。每个操作实现部分的算法，而这些部分算法为相应的结构中对象类所定义。具体访问类（ConcreteVisitor）提供这算法的场景和存储它的本地状态。这一状态通常再遍历该结构的过程中积累结果。
</li>
<li>抽象元素类（Element）定义一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>具体元素类（ConcreteElement）实现一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>对象结构(ObjectStrucutre)
<ol class="org-ol">
<li>能枚举它的元素。
</li>
<li>可以提供允许访问类访问它的元素的上层接口。
</li>
<li>可以是一个组合或一个如列表或无序集合的集合。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象结构包含许多不同接口对象类，而且你想对这些对象进行一些依赖于它们具体类的操作。
</li>
<li>在一个对象结构中，需要对这些对象进行许多不相关不同的操作，而且你想避免以这些操作污染它们的类。访问者模式让你把相关的操作集中起来定义在一个类中。当这个对象结构被许多应用共享时，使用访问者模式让每个应用仅包含需要用到的操作。
</li>
<li>定义对象结构的类很少改变，但你时常想在这个结构上定义新的操作。改变对象结构类需要重定义对所有访问者类的结构，这潜在会是很大的开销。如果这些对象结构类经常改变，那么可能还是在这些类中定义这些操作。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>增加新的元素很困难。每增加一个新的元素将在抽象访问者类（Visitor)中增加一个新的抽象操作，并在每个具体访问类（ConcreteVisitor）中增加相应的操作。
</li>
<li>破坏封装性。访问者的方法假定具体元素类（ConcreteElement）接口足够强大让访问者对它元素进行操作。因而，这个模式强迫你提供能访问元素内部状态的公开操作，从而导致破坏了它的封装性。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十二: 备忘录模式(Memento)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式22</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
一个对象的状态必须被存储下来以便它之后能恢复到那个状态，并且一个直接获取状态的接口将暴露实现的细节并破坏对象的封装。 那么如何不用直接获取状态的情况下，实现状态的存储和恢复呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 备忘录模式(Memento)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
不破坏封装的前提下，采集和外部化对象的内部状态，以便这个对象能被恢复到这状态之后。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
只有一个状态标识需要保存和恢复的简单发起类演示备忘录模式。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/memento">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 需要保存和恢复状态的发起类</h4>
<div class="outline-text-4" id="text-2-2-1">
<ol class="org-ol">
<li><code>CreateMemento</code> ：创建一个包含它当前内部状态快照的备忘录类。
</li>
<li><code>SetMemento</code> ：使用备忘录类恢复它的内部状态。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">T</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Originator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Originator</span>() {}
  <span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt;* <span style="color: #87cefa;">CreateMemento</span>() {
    <span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt; *<span style="color: #eedd82;">m</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Memento</span>&lt;T&gt;();
    m-&gt;set_state(state_);
    <span style="color: #00ffff;">return</span> m;
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SetMemento</span>(<span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt; *<span style="color: #eedd82;">m</span>) {
    state_ = m-&gt;state();
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_state</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">T</span> &amp;<span style="color: #eedd82;">state</span>) {state_ = state;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ShowState</span>() <span style="color: #00ffff;">const</span> {
    cout &lt;&lt; state_ &lt;&lt; endl;
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 备忘录类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
保存和返回状态。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">T</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Memento</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Memento</span>() {}
  <span style="color: #98fb98;">T</span> <span style="color: #87cefa;">state</span>() <span style="color: #00ffff;">const</span> {<span style="color: #00ffff;">return</span> state_;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_state</span>(<span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state</span>) {state_ = state;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 管理者</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
负责备忘录的保护。用 <code>vector</code> 存储备忘录类以便发起者恢复状态。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Caretaker</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Caretaker</span>() {}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SaveState</span>(<span style="color: #98fb98;">Originator</span>&lt;T&gt; *<span style="color: #eedd82;">orig</span>) {
    memento_array_.push_back(orig-&gt;CreateMemento());
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RestoreState</span>(<span style="color: #98fb98;">Originator</span>&lt;T&gt; *<span style="color: #eedd82;">orig</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state_number</span>) {
    orig-&gt;SetMemento(<span style="color: #98fb98;">memento_array_</span>[state_number]);
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">Memento</span>&lt;T&gt; *&gt; <span style="color: #eedd82;">memento_array_</span>;
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 备忘录模式(Memento)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/memento/memento_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>备忘录类（Memento）
<ol class="org-ol">
<li>存储发起者（Originator）对象的内部状态。根据它的发起者的判定，备忘录存储尽量多或尽量少的发起者的内部状态。
</li>
<li>防止发起者以外的对象访问。备忘录类实际有两个接口。管理者（Caretaker）拥有备忘录的窄接口——它只能把备忘录类传递给其他对象。发起者（Originator）相反拥有宽接口，让它访问所有必须的数据来自我恢复到之前状态。理想情况下，只有创建备忘录类的那个发起者才允许访问备忘录类的内部状态。
</li>
</ol>
</li>
<li>发起者（Originator）
<ol class="org-ol">
<li>创建一个包含它当前内部状态快照的备忘录类。
</li>
<li>使用备忘录类恢复它的内部状态。
</li>
</ol>
</li>
<li>管理者（Caretaker）
<ol class="org-ol">
<li>负责备忘录的保护。
</li>
<li>从不操作或检查备忘录类的内容。
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象的（或部分）状态快照必须被存储下来以便它之后能恢复到那个状态，并且
</li>
<li>一个直接获取状态的接口将暴露实现的细节并且破坏对象的封装。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>使用备忘录模式可能会开销很大。备忘录模式会导致很大的开销如果发起类必须在备忘录类你拷贝很大量的信息来恢复或如果客户过多的创建和返回备忘录给创建者。除非封装和恢复发起类状态的开销比较小，否则这个模式可能并不适合。
</li>
<li>定义窄和宽接口。在一些编程语言里确保只有发起类能访问备忘录类的状态可能比较困难。
</li>
<li>管理备忘录类的隐藏开销。一个管理者（caretaker）负责删除它管理的备忘录类。然而，这个管理者不清楚到底有多少的状态存储在备忘录里。因此一个轻量级管理者反而会引起大的存储开销当它存储备忘录时。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十一: 中介者模式(Mediator)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F21/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式21</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
在公司里，有不同的职位，比如销售人员，开发人员，系统维护人员，主管等等，经常不同的人会发出不同广播消息，比如主管通知大家会议室在何时被占用，系统维护人员通知大家系统将升级win7,因为xp将不再得到维护。并且公司内有不同类型的广播消息，比如公司销售会议只应该通知主管级别的人物。
</p>

<p>
有不同类型的广播消息，不同职位接收和发送不同类型的消息给相应职位的人，整个公司的交互相对复杂，如何做到以下呢？
</p>
<ol class="org-ol">
<li>理清和维护好现有的人员交互;
</li>
<li>灵活的扩展不同类型广播和不同消息群组。
</li>
</ol>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 中介者模式(Mediator)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
定义一个对象来封装一组对象如何交互。中介者模式使各个对象不显示的互相引用，并让你独立的改变它们的交互，从而达到提高松耦合的效果。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
引入中介者模式集中式控制。由中介者模式来减少交互的复杂度，由它集中理清交互的关系。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/mediator">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 中介者类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
中介者类实现同事间的消息广播：
</p>
<ol class="org-ol">
<li>模板类提供不同类型消息的复用;
</li>
<li>提供同事的注册和脱离不同消息的广播群组： <code>RegisterColleague</code> 和
   <code>UnregisterColleague</code> ;
</li>
<li>发送消息广播事件： <code>FireEvent</code> ;
</li>
<li>用 <code>vector</code> 维护一个同事消息队列来对注册入队列的同事发生广播事件。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">EventArgType</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mediator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;* &gt; <span style="color: #98fb98;">EventList</span>;
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Mediator</span>() {}

 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">EventList</span> <span style="color: #eedd82;">colleagues</span>;
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt; *<span style="color: #eedd82;">instance</span>;
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;&amp; <span style="color: #87cefa;">GetInstance</span>() {
    <span style="color: #00ffff;">if</span> (!instance) {
      instance = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Mediator</span>();
    }
    <span style="color: #00ffff;">return</span> *instance;
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RegisterColleague</span>(<span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt; *<span style="color: #eedd82;">col_event</span>) {
    colleagues.push_back(col_event);
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">FireEvent</span>(<span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt; *<span style="color: #eedd82;">source</span>, <span style="color: #98fb98;">EventArgType</span> <span style="color: #eedd82;">event_arg</span>) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; colleagues.size(); ++i) {
      <span style="color: #00ffff;">if</span> (colleagues[i] != source) {
        colleagues[i]-&gt;handlerProc(source-&gt;event_context, event_arg,
                                   <span style="color: #98fb98;">colleagues</span>[i]-&gt;event_context);
      }
    }
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">UnregisterColleague</span>(<span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt; *<span style="color: #eedd82;">col_event</span>) {
    <span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">EventList</span>::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = find(colleagues.begin(), colleagues.end(),
                                  col_event);
    <span style="color: #00ffff;">if</span> (it != colleagues.end()) {
      colleagues.erase(it);
    }
  }
  <span style="color: #00ffff;">friend</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 同事消息事件类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
同事消息事件类封装消息事件：
</p>
<ol class="org-ol">
<li>模板类提供不同类型消息的复用;
</li>
<li>消息的注册同事;
</li>
<li>消息的处理函数，不同同事实现各自的处理函数，当由消息到来时，中介者类调用各个同事的消息处理函数来操作;
</li>
<li>用中介者类注册和脱离消息群组;
</li>
<li>用中介着类出发消息事件;
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">EventArgType</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ColleagueEvent</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">void</span> (*<span style="color: #98fb98;">ColleagueEventHandler</span>) (<span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">source</span>,
                                         <span style="color: #98fb98;">EventArgType</span> <span style="color: #eedd82;">event_arg</span>,
                                         <span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">context</span>);
  <span style="color: #87cefa;">ColleagueEvent</span>(<span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">source</span>, <span style="color: #98fb98;">ColleagueEventHandler</span> <span style="color: #eedd82;">event_proc</span>)
      : event_context(source), <span style="color: #98fb98;">handlerProc</span>(<span style="color: #eedd82;">event_proc</span>) {
    <span style="color: #7fffd4;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;::GetInstance().RegisterColleague(<span style="color: #00ffff;">this</span>);
  }
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">ColleagueEvent</span>() {
    <span style="color: #7fffd4;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;::GetInstance().UnregisterColleague(<span style="color: #00ffff;">this</span>);
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">FireEvent</span>(<span style="color: #98fb98;">EventArgType</span> <span style="color: #eedd82;">event_arg</span>) {
    <span style="color: #7fffd4;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;::GetInstance().FireEvent(<span style="color: #00ffff;">this</span>, event_arg);
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">event_context</span>;
  <span style="color: #98fb98;">ColleagueEventHandler</span> <span style="color: #eedd82;">handlerProc</span>;
  <span style="color: #00ffff;">friend</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mediator</span>&lt;<span style="color: #98fb98;">EventArgType</span>&gt;;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 公司人员抽象类</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
为同事定义接口。暂时是空的。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Colleague</span> {
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #87cefa;">Colleague</span>() {}
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Colleague</span>() {}
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 普通员工消息类型类</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
消息有很多不同类型，如普通员工消息类型，主管级消息等等，这里以普通员工消息为例。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StaffMsg</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">StaffMsg</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">data</span>) : msg_name_(name), <span style="color: #98fb98;">msg_data_</span>(<span style="color: #eedd82;">data</span>) {
  }
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">StaffMsg</span>() {}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">msg_name</span>() {<span style="color: #00ffff;">return</span> msg_name_;}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">msg_data</span>() {<span style="color: #00ffff;">return</span> msg_data_;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">msg_name_</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">msg_data_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> 雇员基类</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
有雇主和雇员之分，这里以雇员为例。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Employee</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Colleague</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Employee</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">title</span>, <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>) : title_(title), name_(name) {
  }
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Employee</span>() {}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">title</span>() {<span style="color: #00ffff;">return</span> title_;}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() {<span style="color: #00ffff;">return</span> name_;}
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">title_</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> 普通员工类</h4>
<div class="outline-text-4" id="text-2-2-6">
<p>
普通员工基于雇员类。维护普通员工消息事件实例，负责把自己注册到相应的中介者消息队列，实现普通员工如何处理接收到的消息。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">GeneralStaff</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Employee</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">GeneralStaff</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">title</span>, <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">GeneralStaff</span>();
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">OnColleagueEvent</span>(<span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">source</span>, <span style="color: #98fb98;">StaffMsg</span> <span style="color: #eedd82;">data</span>,
                               <span style="color: #98fb98;">Colleague</span>* <span style="color: #eedd82;">context</span>);
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">ColleagueEvent</span>&lt;<span style="color: #98fb98;">StaffMsg</span>&gt; <span style="color: #eedd82;">general_staff_event_</span>;
};

<span style="color: #7fffd4;">GeneralStaff</span>::<span style="color: #87cefa;">GeneralStaff</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">title</span>, <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>)
    : Employee(title, name), general_staff_event_(<span style="color: #00ffff;">this</span>, OnColleagueEvent) {
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GeneralStaff</span>::<span style="color: #87cefa;">OnColleagueEvent</span>(<span style="color: #98fb98;">Colleague</span> *<span style="color: #eedd82;">source</span>, <span style="color: #98fb98;">StaffMsg</span> <span style="color: #eedd82;">data</span>,
                                           <span style="color: #98fb98;">Colleague</span>* <span style="color: #eedd82;">context</span>) {
  <span style="color: #98fb98;">Employee</span> *<span style="color: #eedd82;">src_colleague</span> = <span style="color: #00ffff;">static_cast</span>&lt;Employee *&gt; (source);
  <span style="color: #98fb98;">Employee</span> *<span style="color: #eedd82;">ctx_colleague</span> = <span style="color: #00ffff;">static_cast</span>&lt;Employee *&gt; (context);
  cout &lt;&lt; endl &lt;&lt; ctx_colleague-&gt;title()
       &lt;&lt; <span style="color: #ffa07a;">" - "</span> &lt;&lt; ctx_colleague-&gt;name()
       &lt;&lt; <span style="color: #ffa07a;">" is notified by "</span>
       &lt;&lt; src_colleague-&gt;title() &lt;&lt; <span style="color: #ffa07a;">" - "</span>
       &lt;&lt; src_colleague-&gt;name()
       &lt;&lt; <span style="color: #ffa07a;">" of STAFF Event "</span> &lt;&lt; data.msg_name()
       &lt;&lt; <span style="color: #ffa07a;">" with "</span> &lt;&lt; data.msg_data();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> 销售人员类</h4>
<div class="outline-text-4" id="text-2-2-7">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">SalesMen</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">GeneralStaff</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">SalesMen</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>) :
      GeneralStaff(<span style="color: #ffa07a;">"Sales Man"</span>, name) {
  }
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">SalesMen</span>() {}
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-8" class="outline-4">
<h4 id="sec-2-2-8"><span class="section-number-4">2.2.8</span> 系统维护人员类</h4>
<div class="outline-text-4" id="text-2-2-8">
<p>
系统维护人员类注册普通员工消息队列，并有发起软件升级通知的权利。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">SysAdmin</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">GeneralStaff</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">SysAdmin</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">SysAdmin</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">AdviceForSoftwareUpdate</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sw_name</span>);
};

<span style="color: #7fffd4;">SysAdmin</span>::<span style="color: #87cefa;">SysAdmin</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>) : GeneralStaff(<span style="color: #ffa07a;">"Sys Admin"</span>, name) {
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">SysAdmin</span>::<span style="color: #87cefa;">AdviceForSoftwareUpdate</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sw_name</span>) {
  general_staff_event_.FireEvent(StaffMsg(<span style="color: #ffa07a;">"Software Update Advice"</span>, sw_name));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-9" class="outline-4">
<h4 id="sec-2-2-9"><span class="section-number-4">2.2.9</span> 主管人员类</h4>
<div class="outline-text-4" id="text-2-2-9">
<p>
系统维护人员类注册普通员工消息队列，并有发起预订会议室通知的权利。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Manager</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">GeneralStaff</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Manager</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Manager</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">BookMeetingRoom</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">meeting_room_name</span>);
};

<span style="color: #7fffd4;">Manager</span>::<span style="color: #87cefa;">Manager</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>) : GeneralStaff(<span style="color: #ffa07a;">"Manager"</span>, name) {
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Manager</span>::<span style="color: #87cefa;">BookMeetingRoom</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">meeting_room_name</span>) {
  general_staff_event_.FireEvent(StaffMsg(<span style="color: #ffa07a;">"Meeting Room Booking"</span>,
                                          meeting_room_name));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-10" class="outline-4">
<h4 id="sec-2-2-10"><span class="section-number-4">2.2.10</span> 总的测试</h4>
<div class="outline-text-4" id="text-2-2-10">
<ol class="org-ol">
<li>建立各个员工;
</li>
<li>发起不同类型消息测试。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">Manager</span> <span style="color: #eedd82;">mng1</span>(<span style="color: #ffa07a;">"Vivek"</span>), <span style="color: #eedd82;">mng2</span>(<span style="color: #ffa07a;">"Pradeep"</span>);
  <span style="color: #98fb98;">SysAdmin</span> <span style="color: #eedd82;">sys_admin</span>(<span style="color: #ffa07a;">"Sony"</span>);
  <span style="color: #98fb98;">SalesMen</span> <span style="color: #eedd82;">sl1</span>(<span style="color: #ffa07a;">"Dave"</span>), <span style="color: #eedd82;">s12</span>(<span style="color: #ffa07a;">"Mike"</span>), <span style="color: #eedd82;">s13</span>(<span style="color: #ffa07a;">"Allen"</span>);

  mng1.BookMeetingRoom(<span style="color: #ffa07a;">"Big Room"</span>);
  cout &lt;&lt; endl;
  sys_admin.AdviceForSoftwareUpdate(<span style="color: #ffa07a;">"Win7"</span>);
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<div class="org-src-container">

<pre class="src src-c++">Manager - Pradeep is notified by Manager - Vivek of STAFF Event Meeting Room Booking with Big Room
Sys Admin - Sony is notified by Manager - Vivek of STAFF Event Meeting Room Booking with Big Room
Sales Man - Dave is notified by Manager - Vivek of STAFF Event Meeting Room Booking with Big Room
Sales Man - Mike is notified by Manager - Vivek of STAFF Event Meeting Room Booking with Big Room
Sales Man - Allen is notified by Manager - Vivek of STAFF Event Meeting Room Booking with Big Room

Manager - Vivek is notified by Sys Admin - Sony of STAFF Event Software Update Advice with Win7
Manager - Pradeep is notified by Sys Admin - Sony of STAFF Event Software Update Advice with Win7
Sales Man - Dave is notified by Sys Admin - Sony of STAFF Event Software Update Advice with Win7
Sales Man - Mike is notified by Sys Admin - Sony of STAFF Event Software Update Advice with Win7
Sales Man - Allen is notified by Sys Admin - Sony of STAFF Event Software Update Advice with Win7
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 中介者模式(Mediator)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/mediator/mediator_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象中介者（Mediator）为与同事（Colleague）对象交流定义一个接口。
</li>
<li>具体中介者（ConcreteMediator）
<ol class="org-ol">
<li>实现与同事（Colleague）对象协作的合作行为。
</li>
<li>知道和维护它的同事类。
</li>
</ol>
</li>
<li>同事类（Colleague classes）
<ol class="org-ol">
<li>每个同事类知道它的中介者对象。
</li>
<li>每个同事类任何它应该时与它的中介者交流，否则就与其他同事类交流。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一组对象交流在很好定义的却复杂的方式上。导致的互相依赖性并没有好的组织而且难理解时。
</li>
<li>复用一个对象是困难的，因为它引用并交流与许多其他对象。
</li>
<li>分布在很多类中的一个行为需要被定制但不能进行太多子类化。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
中介者模式集中式控制。中介者模式以减少交互的复杂度而增加中介者的复杂度。因为一个中介者类封装了协议，它会变得比任何同事类都复杂。这会导致中介者类自身是个难维护的庞然大物。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十: 解释器模式(Interpreter)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F20/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式20</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
以简单计算器为实例,计算器做加减乘除有一套自己的语言(堆栈形式),可以直接计算,那么用语法树来解释并计算计算器语言如何设计呢?
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 解释器模式(Interpreter)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
给予一种编程语言，为它的语法定义一种表现形式并包括一个解释器使用这个形式来解释语言中的语句。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这里只以加法和减法为实例,实现简单的解释器模式来解释计算器的堆栈语言来计算结果。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/interpreter">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 抽象表达式类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
声明一个抽象解释器操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Expression</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Expression</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Interpret</span>() = 0;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 末端表达式类：数字表达式</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #7fffd4;">NumberExpression</span>::<span style="color: #87cefa;">Interpret</span>() {
  <span style="color: #00ffff;">return</span> number_;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 非末端表达式：加法表达式</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
实现加法运算的解释器操作，若被解释的对象是非末端表达式，继续递归调用非末端表达式解释器操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">AddExpression</span>::<span style="color: #87cefa;">AddExpression</span>(<span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">right</span>) :
    left_expression_(left), right_expression_(right) {
}

<span style="color: #98fb98;">int</span> <span style="color: #7fffd4;">AddExpression</span>::<span style="color: #87cefa;">Interpret</span>() {
  <span style="color: #00ffff;">return</span> left_expression_-&gt;Interpret() + right_expression_-&gt;Interpret();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 非末端表达式：减法表达式</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
同加法表达式一样，实现减法运算的解释器操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">SubtractExpression</span>::<span style="color: #87cefa;">SubtractExpression</span>(<span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">right</span>) :
    left_expression_(left), right_expression_(right) {
}

<span style="color: #98fb98;">int</span> <span style="color: #7fffd4;">SubtractExpression</span>::<span style="color: #87cefa;">Interpret</span>() {
  <span style="color: #00ffff;">return</span> left_expression_-&gt;Interpret() - right_expression_-&gt;Interpret();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> 表达式阅读器</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
包含解释器的全局信息，读取用户表达式，使用解释器解释整个用户表达式语言。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">Expression</span>* <span style="color: #7fffd4;">TokenReader</span>::<span style="color: #87cefa;">ReadToken</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">token_vector</span>) {
  <span style="color: #00ffff;">return</span> ReadNextToken(token_vector);
}

<span style="color: #98fb98;">Expression</span>* <span style="color: #7fffd4;">TokenReader</span>::<span style="color: #87cefa;">ReadNextToken</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">token_vector</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">token</span> = token_vector-&gt;at(0);
  <span style="color: #00ffff;">if</span> (token == <span style="color: #ffa07a;">"+"</span> || token == <span style="color: #ffa07a;">"-"</span>){
    <span style="color: #00ffff;">return</span> ReadNonTerminal(token_vector);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">number</span> = atoi(token.c_str());
    token_vector-&gt;erase(token_vector-&gt;begin());
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NumberExpression</span>(number);
  }
}

<span style="color: #98fb98;">Expression</span>* <span style="color: #7fffd4;">TokenReader</span>::<span style="color: #87cefa;">ReadNonTerminal</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">token_vector</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">token</span> = token_vector-&gt;at(0);
  token_vector-&gt;erase(token_vector-&gt;begin());
  <span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">left</span> = ReadNextToken(token_vector);
  <span style="color: #98fb98;">Expression</span> *<span style="color: #eedd82;">right</span> = ReadNextToken(token_vector);
  <span style="color: #00ffff;">if</span> (token == <span style="color: #ffa07a;">"+"</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">AddExpression</span>(left, right);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (token == <span style="color: #ffa07a;">"-"</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SubtractExpression</span>(left, right);
  }
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NullExpression</span>();
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 解释器模式(Interpreter)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/interpreter/interpreter_structure.jpeg" />
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象表达式类（AbstractExpression）声明一个抽象解释器操作，它并在抽象语法书中被所有节点所共有。
</li>
<li>末端表达式类（TerminalExpression）
<ol class="org-ol">
<li>实现与在语法中与末端符号相关的解释操作。
</li>
<li>在语句中每个末端符号都需要个实例。
</li>
</ol>
</li>
<li>非末端表达式（NonterminalExpression）
<ol class="org-ol">
<li>在语法中每条规则 \(R ::= R_1R_2 .. R_n\) 都需要一个这样的类。
</li>
<li>从 \(R_1\) 到 \(R_n\) 到的每个符号都维护抽象表达式（AbstractExpression）类型的实力变量。
</li>
<li>实现在语法中非末端表达式的解释操作。解释器通常在 \(R_1\) 到 \(R_n\) 表示的变量中递归的自我调用。
</li>
</ol>
</li>
<li>场景类（Context）包含解释器的全局信息。
</li>
<li>客户（Client）
<ol class="org-ol">
<li>建立（或被给予）表示语法定义的语言中特殊语句的抽象语法树。这个抽象语法书由非末端表示式类（NonterminalExpression）和末端表示式（TerminalExpression)类装配而成。
</li>
<li>调用解释器操作。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<p>
当一种语言需要解释并且你能把语言内语句表示成一颗抽象的语法树时，使用解释器模式。解释器模式最好应用在当：
</p>
<ul class="org-ul">
<li>语法是简单的。对于复杂的语法，组成语法的类层次变得庞大而不可控。在这种情况下，如分析程序生成器之类的工具会是更好的选择。它们能不建立抽象语法树来分析表达式，从而节省空间和可能的时间。
</li>
<li>效率不是关键的考虑因素。最高效的解释器往往不以直接解释解析树来实现，而是先把它们转换成另外种形式。比如，正则表达式通常被转换成状态机。但即使如此，这个转换器也可以由解析起模式来实现，所以这个模式还是比较实用的。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
复杂的语法很难维护。解释器模式为语法中的每条规则定义至少一个类（以BNF
定义的语法规则可能需要多个类）。因此包含许多规则的语法很难管理和维护。其他设计模式可以应用来消除这个问题（参考Implementation）。但是当语法非常复杂时，比如解析器或编译生成起之类的其他技术更适合。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十九: 责任链模式(Chain of Responsibility)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式19</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
学校里，教师，主管，主任都有不同的职责，现在家长有不同的请求，比如他们小孩的日常表现或付学费等，但家长并不清楚学校内部的职责归属，哪个请求该去找那个人处理，家长一般直接与孩子的老师交流，那么如何满足家长不同的请求呢?
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 责任链模式(Chain of Responsibility)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
避免请求的发送者通过给予多个对象机会去处理这个请求的方式到它的接收者的耦合。把接收对象组成一条链路，并把这个请求沿着这条链路传送直到一个对象处理它。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
利用责任链模式把处理者串起来,如果这个具体处理者能处理这个请求，它就处理它，否则它传递这个请求给它的后继对象。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/chain_of_responsibility">代码实例在这里</a>。
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 抽象处理者类</h3>
<div class="outline-text-3" id="text-2-3">
<ol class="org-ol">
<li>为处理请求定义一个接口。
</li>
<li>维护后继者的引用
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Staff</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Staff</span>() {}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_name</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>) {name_ = name;}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() {<span style="color: #00ffff;">return</span> name_;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_boss</span>(<span style="color: #98fb98;">Staff</span> *<span style="color: #eedd82;">boss</span>) {boss_ = boss;}
  <span style="color: #98fb98;">Staff</span>* <span style="color: #87cefa;">boss</span>() {<span style="color: #00ffff;">return</span> boss_;}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ProcessRequest</span>(<span style="color: #98fb98;">Request</span> *<span style="color: #eedd82;">a_request</span>) = 0;
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
  <span style="color: #98fb98;">Staff</span> *<span style="color: #eedd82;">boss_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 请求类</h3>
<div class="outline-text-3" id="text-2-4">
<p>
请求分为不同的等级,来被不同职位的人处理.这里分为低,中和高三个等级,分别被老师,主管和主任处理.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">ResponsiableLevel</span> {
  <span style="color: #eedd82;">kLow</span>,
  <span style="color: #eedd82;">kMedium</span>,
  <span style="color: #eedd82;">kHigh</span>
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Request</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Request</span>() {}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_level</span>(<span style="color: #98fb98;">ResponsiableLevel</span> <span style="color: #eedd82;">level</span>) {level_ = level;}
  <span style="color: #98fb98;">ResponsiableLevel</span> <span style="color: #87cefa;">level</span>() {<span style="color: #00ffff;">return</span> level_;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_description</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">description</span>) {description_ = description;}
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">description</span>() {<span style="color: #00ffff;">return</span> description_;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">description_</span>;
  <span style="color: #98fb98;">ResponsiableLevel</span> <span style="color: #eedd82;">level_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 具体处理类</h3>
<div class="outline-text-3" id="text-2-5">
<p>
这里分为老师,主管和主任.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Teacher</span>::<span style="color: #87cefa;">ProcessRequest</span>(<span style="color: #98fb98;">Request</span> *<span style="color: #eedd82;">a_request</span>) {
  <span style="color: #00ffff;">if</span> (a_request-&gt;level() == kLow) {
    cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a teacher of this daycare. "</span> &lt;&lt;
        <span style="color: #ffa07a;">"Your request has been approved!"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">if</span> (boss_ != <span style="color: #7fffd4;">NULL</span>) {
      cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a teacher of this daycare. "</span> &lt;&lt;
          <span style="color: #ffa07a;">" I am not able to process your request. "</span> &lt;&lt; <span style="color: #ffa07a;">"My boss "</span> &lt;&lt;
          boss_-&gt;name() &lt;&lt; <span style="color: #ffa07a;">"will review your request"</span> &lt;&lt; endl;
      boss_-&gt;ProcessRequest(a_request);
    } <span style="color: #00ffff;">else</span> {
      cout &lt;&lt; <span style="color: #ffa07a;">"No boss assigned"</span> &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Manager</span>::<span style="color: #87cefa;">ProcessRequest</span>(<span style="color: #98fb98;">Request</span> *<span style="color: #eedd82;">a_request</span>) {
  <span style="color: #00ffff;">if</span> (a_request-&gt;level() == kMedium) {
    cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a manager of this daycare. "</span> &lt;&lt;
        <span style="color: #ffa07a;">"Your request has been approved!"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">if</span> (boss_ != <span style="color: #7fffd4;">NULL</span>) {
      cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a manager of this daycare. "</span> &lt;&lt;
          <span style="color: #ffa07a;">" I am not able to process your request. "</span> &lt;&lt; <span style="color: #ffa07a;">"My boss "</span> &lt;&lt;
          boss_-&gt;name() &lt;&lt; <span style="color: #ffa07a;">"will review your request"</span> &lt;&lt; endl;
      boss_-&gt;ProcessRequest(a_request);
    } <span style="color: #00ffff;">else</span> {
      cout &lt;&lt; <span style="color: #ffa07a;">"No boss assigned"</span> &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Director</span>::<span style="color: #87cefa;">ProcessRequest</span>(<span style="color: #98fb98;">Request</span> *<span style="color: #eedd82;">a_request</span>) {
  <span style="color: #00ffff;">if</span> (a_request-&gt;level() == kHigh) {
    cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a director of this daycare. "</span> &lt;&lt;
        <span style="color: #ffa07a;">"Your request has been approved!"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">if</span> (boss_ != <span style="color: #7fffd4;">NULL</span>) {
      cout &lt;&lt; <span style="color: #ffa07a;">"This is "</span> &lt;&lt; name_ &lt;&lt; <span style="color: #ffa07a;">". I am a director of this daycare. "</span> &lt;&lt;
          <span style="color: #ffa07a;">" I am not able to process your request. "</span> &lt;&lt; <span style="color: #ffa07a;">"My boss "</span> &lt;&lt;
          boss_-&gt;name() &lt;&lt; <span style="color: #ffa07a;">"will review your request"</span> &lt;&lt; endl;
      boss_-&gt;ProcessRequest(a_request);
    } <span style="color: #00ffff;">else</span> {
      cout &lt;&lt; <span style="color: #ffa07a;">"No boss assigned"</span> &lt;&lt; endl;
    }
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 责任链模式(Chain of Responsibility)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/chainofresponsibility/chain_of_responsibility_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>处理者（Handler）
<ol class="org-ol">
<li>为处理请求定义一个接口。
</li>
<li>（可选）实现后继链接。
</li>
</ol>
</li>
<li>具体处理者（ConcreteHandler）
<ol class="org-ol">
<li>处理它负责的请求。
</li>
<li>能访问它的后继对象。
</li>
<li>如果这个具体处理者能处理这个请求，它就处理它，否则它传递这个请求给它的后继对象。
</li>
</ol>
</li>
<li>对象（Client）初始给链路中的具体处理者一个请求。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>多余一个对象要处理一个请求，并且处理者不是先验的。处理者需要自动被弹探知。
</li>
<li>你想促发促一个请求给许多个对象之一并且不想明确指定哪个接收者时。
</li>
<li>处理请求的一组对象需要被动态指定。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
收到不能被保证。因为一个请求没有明确的接收者，所以不能保证它将被处理——请求也能落到链路的末端而未曾被处理。一个请求也能不被处理当链路没有被合理的配置。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十八: 享元模式(Flyweight)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式18</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
绘画培训班内，一次绘图课上，每个学员要练习大量不同颜色的圆形，那么如果为每个学员都实例和维护不同颜色圆的实例话，将产生很多重复颜色的圆，占用很多存储开销，那么如何大家共享这些圆的实例呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 享元模式(Flyweight)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
使用共享机制来有效支持大量细粒度的对象。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这里圆形作为享元类，可以被大家所共享，并建立相应的享元工厂类来创建和管理享元对象。并确保合理的共享享元类。当一个客户请求一个享元类时，享元工厂对象提供一个已存在的实例或如果不存在就创建一个。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/flyweight">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 享元类： <code>CIrcle</code></h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
颜色作为它的一个状态。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Circle</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Shape</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Circle</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">color</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Circle</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_x</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>) {x_ = x;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_y</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>) {y_ = y;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_radius</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">radius</span>) {radius_ = radius;}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">draw</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">color_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">radius_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 享元工厂类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
利用 <code>map</code> 把颜色作为标识来存储享元类。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ShapeFactory</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">ShapeFactory</span>();
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Shape</span>* <span style="color: #87cefa;">getCircle</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">color</span>);
 <span style="color: #00ffff;">private</span>:
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">map</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">Shape</span>*&gt; *<span style="color: #eedd82;">map_</span>;
};

<span style="color: #98fb98;">Shape</span>* <span style="color: #7fffd4;">ShapeFactory</span>::<span style="color: #87cefa;">getCircle</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">color</span>) {
  <span style="color: #7fffd4;">map</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">Shape</span>*&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span>;
  it = map_-&gt;find(color);
  <span style="color: #00ffff;">if</span> (it != map_-&gt;end()) {
    <span style="color: #00ffff;">return</span> it-&gt;second;
  }
  <span style="color: #98fb98;">Circle</span> *<span style="color: #eedd82;">circle</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Circle</span>(color);
  map_-&gt;insert(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">pair</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">Shape</span>*&gt;(color, circle));
  cout &lt;&lt; <span style="color: #ffa07a;">"Creating circle of color:"</span> &lt;&lt; color &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> circle;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 学员共享图形实例</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">colors</span>;
  colors.push_back(<span style="color: #ffa07a;">"Red"</span>);
  colors.push_back(<span style="color: #ffa07a;">"Green"</span>);
  colors.push_back(<span style="color: #ffa07a;">"Blue"</span>);
  colors.push_back(<span style="color: #ffa07a;">"White"</span>);
  colors.push_back(<span style="color: #ffa07a;">"Black"</span>);

  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 20; ++i) {
    <span style="color: #98fb98;">Circle</span> *<span style="color: #eedd82;">circle</span> = <span style="color: #00ffff;">dynamic_cast</span>&lt;Circle *&gt;(<span style="color: #7fffd4;">ShapeFactory</span>::getCircle(
        getRandomColor(colors)));
    circle-&gt;set_x(getRandomX());
    circle-&gt;set_y(getRandomY());
    circle-&gt;set_radius(100);
    circle-&gt;draw();
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 享元模式(Flyweight)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/flyweight/flyweight_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象享元类（Flyweight）声明一个接口，通过这个接口享元类（Flyweight）可以接收和作用于外部状态。
</li>
<li>具体享元类（ConcreteFlyweight）实现抽象享元类的接口并为内部状态增加存储空间。具体享元类（ConcreteFlyweight）必须是可共享的。它存储的任何状态必须是内部的，也就是说它必须独立于具体享元类（ConcreteFlyweight）所处的场景。
</li>
<li>非共享的具体享元类（UnsharedConcreteFlyweight）不是所有的享元子类必须可共享的。享元类接口使得共享成为可能，但并不强制要求它。通常在享元对象结构的某些层次上，非共享的具体享元素（UnsharedConcreteFlyweight）对象把具体享元素（ConcreteFlyweight）对象作为子节点。
</li>
<li>享元工厂类（FlyweightFactory）
<ol class="org-ol">
<li>创建和管理享元对象。
</li>
<li>确保合理的共享享元类。当一个客户请求一个享元类时，享元工厂对象提供一个已存在的实例或如果不存在就创建一个。
</li>
</ol>
</li>
<li>客户
<ol class="org-ol">
<li>维护享元类的引用。
</li>
<li>计算或存储享元类的外部状态。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<p>
享元模式的有效性严重依赖于如何和在哪被使用。应用享元模式当 <b>以下条件都相符</b> 时：
</p>
<ul class="org-ul">
<li>一个应用使用大量的对象。
</li>
<li>因为大量的对象，从而造成很大的存储开销。
</li>
<li>大多数对象状态可以外部化。
</li>
<li>一旦消除外部状态后，许多组的对象能被相对较少的共享对象所替换。
</li>
<li>应用不依赖于对象的标识。因为享元对象可以被共享，那么对于概念上有别的对象，标识测试也会返回真值。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
共享模式会引入运行时间开销伴随着传送，找寻，或计算外部状态，特别是如果它之前内部存储。但是如此的开销被空间节省抵消，越是更多的享元类被共享越是增加节省的空间。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十七: 桥接模式(Bridge)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式17</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
画圆可以顺时针或逆时针，但只能使用一种方法，不能同时既顺时针又逆时针。比较直观的做法就是定义两种不同的圆，但同时继承于圆的基本特性基类。但如果不采用继承并在运行时选取画圆的方法呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 桥接模式(Bridge)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
从对象的具体实现中解藕出抽象部分，使它们可以各自独立的变化。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
把顺时针和逆时针的画法抽取出来成为独立的实现者类，由圆运行时可以选取自己的画法。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/bridge">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义实现者抽象接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Drawing</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Drawing</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">drawCircle</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>) = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 顺时针实现类</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DrawingClockwise</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Drawing</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">DrawingClockwise</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">drawCircle</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>) {
    printf(<span style="color: #ffa07a;">"draw the circle at %f,%f, radius %f by clockwise\n"</span>, x, y, radius);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 逆时针实现类</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DrawingCounterClockwise</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Drawing</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">DrawingCounterClockwise</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">drawCircle</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>) {
    printf(<span style="color: #ffa07a;">"draw the circle at %f,%f, radius %f by counter clockwise\n"</span>,
           x, y, radius);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 圆类</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
维护一个实现者的实例并使用它完成相应的行为。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CircleShape</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Shape</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CircleShape</span>();
  <span style="color: #87cefa;">CircleShape</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius</span>, <span style="color: #98fb98;">Drawing</span> *<span style="color: #eedd82;">drawing</span>);
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">draw</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">resizeByPercentage</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">pct</span>);
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x_</span>;
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y_</span>;
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radius_</span>;
  <span style="color: #98fb98;">Drawing</span> *<span style="color: #eedd82;">drawing_</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CircleShape</span>::<span style="color: #87cefa;">draw</span>() {
    drawing_-&gt;drawCircle(x_, y_, radius_);
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 桥接模式(Bridge)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/bridge/bridge_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象类（Abstraction）
<ol class="org-ol">
<li>定义抽象的接口。
</li>
<li>维护一个指向实现类（Implementor）类型的对象的引用。
</li>
</ol>
</li>
<li>精炼抽象类（Refined Abstraction）扩展抽象类定义的接口。
</li>
<li>抽象实现者（Implementor）为实现类定义接口。这个接口没有必要和抽象类（Abstraction）的接口相一致。实际上这两个接口可以很不同。典型的抽象实现类接口只提供原始操作，然而抽象类基于这些原始操作定义上层操作。
</li>
<li>具体实现类（ConcreteImplementor）实现抽象实现类（Implementor）接口。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>当你想避免抽象部分和它的实现部分永久的绑定时。例如，可能这样的情况，当实现部分必须在运行时被选取或换出。
</li>
<li>抽象部分和它们的实现部分都需要能被子类扩展时。在这种情况，桥接模式让你组合不同的抽象部分和实现部分并可独立扩展它们。
</li>
<li>当改变抽象的实现部分对客户没有任何影响时，也就是，客户的代码不需要重新编译。
</li>
<li>（C++）你想从客户那完全隐藏抽象的实现部分.在C++中，类的表现在类的接口里可以看到。
</li>
<li>你有一堆激增的类时。如此类的层次表明需要把对象分离成两部分。
</li>
<li>当你想在多个对象见共享一个实现部分（可能使用引用计数），并想把这个事实从客户那隐藏掉时。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十六: 原型模式(Prototype)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式16</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
有一个系统中有很多系统配置和用户简况：
</p>
<ol class="org-ol">
<li>初始读取配置或用户简况需要花一些时间（比如用一些系统调用或读取数据库等），但并非实时数据，只需初始化读一编;
</li>
<li>因为众多系统配置和用户简况需要初始化，每次手动初始化比较繁琐，希望能一个类其中管理并快速创建实例
</li>
</ol>

<p>
那么如何能不每次手动初始化对象，并能克隆初始化的数据到新的实例呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 原型模式(Prototype)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
使用一个原型的实例来创建一些特定的对象，然后当创建这些新的对象时通过拷贝这个原型。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
使用原型模式：
</p>
<ol class="org-ol">
<li>第一次花一段时间初始化系统配置和用户简况的数据，存入相应的变量内;
</li>
<li>原型管理类其中管理需要克隆的类，直接克隆初始化好的实例的数据变量值，不再需要去或系统调用或读取来初始化数据。
</li>
<li>客户直接使用原型管理类获取实例，不再需要手动实例化它们。
</li>
</ol>
<p>
<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/prototype">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义原型抽象接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
为克隆声明一个接口。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Prototype</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Prototype</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Prototype</span>* <span style="color: #87cefa;">Clone</span>() = 0;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 系统配置类继承原型基类</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Configuration</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Prototype</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Configuration</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GetFileInformation</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Prototype</span>* <span style="color: #87cefa;">Clone</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ShowInformation</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">file_information_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 用户简况类继承原型基类</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">UserProfile</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Prototype</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">UserProfile</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GetDatabaseInformation</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Prototype</span>* <span style="color: #87cefa;">Clone</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ShowInformation</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">database_information_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 原型管理类管理原型克隆</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
<code>AddPrototype</code> 添加原型实例， <code>GetPrototype</code> 克隆原型实例返回新的实例。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">PrototypeManager</span>::<span style="color: #87cefa;">AddPrototype</span>(<span style="color: #98fb98;">Prototype</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>) {
  (*prototype_map_)[index] = p;
}


<span style="color: #98fb98;">Prototype</span>* <span style="color: #7fffd4;">PrototypeManager</span>::<span style="color: #87cefa;">GetPrototype</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>) {
  <span style="color: #00ffff;">return</span> prototype_map_-&gt;at(index)-&gt;Clone();
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 原型模式(Prototype)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/prototype/prototype_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象原型类（Prototype）为克隆声明一个接口。
</li>
<li>具体原型类（ConcretePrototype）实现自我克隆的操作。
</li>
<li>客户类（Client）通过要求原型类克隆自己来创建新的对象。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用原型模式当一个系统需要独立与它的产品如何创建，组成和表示，而且
</p>
<ul class="org-ul">
<li>当这些类在运行时被指定初始化，比如，通过动态加载，或
</li>
<li>为了避免创建一个与产品类层次相平行的工厂类层次时，或
</li>
<li>当一个类的实例能有许多不同状态组合中之一时，创建相应数目的原型并克隆它们比手动实例化它们更方便些。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
原型模式的主要缺点是每个原型类的子类必须实现 <code>Clone</code> 操作，这可能很困难。例如，新增 <code>Clone</code> 操作是困难的当所考虑的类已经存在。实现 <code>Clone</code>
操作可以很困难当内部包含不支持拷贝或有循环引用的对象时。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十五: 生成器模式(Builder)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式15</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
批萨店有不同种类的批萨，每种批萨的制作流程类似，如果每个批萨都创建一个类，并且在各自类中完成各自的制作，那么制作流程的代码就会重复，并且制作过程与对象本身融合在一起，那么如何把所有批萨类似的制作流程分离出来，并消除代码冗余呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 生成器模式(Builder)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
把复杂对象的建造过程从它的表示中分离出来，使得同样的创建过程能创建不同表现的对象。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
利用生成器模式，把批萨制作流程分离出来，从而不同批萨能使用同样的制作流程。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/builder">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 批萨的基类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
批萨的基类定义生成器可以配置不同的参数，从而达到同样的流程创建不同的对象。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Pizza</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Pizza</span>() {}
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Pizza</span>() {}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_dough</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">dough</span>) { dough_ = dough; }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_sauce</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sauce</span>) { sauce_ = sauce; }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_topping</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">topping</span>) { topping_ = topping; }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 生成器抽象类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
维护一个批萨的实例，并声明生成器制作接口。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PizzaBuilder</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">PizzaBuilder</span>() {}
  <span style="color: #98fb98;">Pizza</span>* <span style="color: #87cefa;">get_pizza</span>() { <span style="color: #00ffff;">return</span> pizza_; }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">createPizza</span>() { pizza_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Pizza</span>(); }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildDough</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildSauce</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildTopping</span>() = 0;
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">Pizza</span> *<span style="color: #eedd82;">pizza_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Clam批萨的生成器</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ClamPizzaBuilder</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">PizzaBuilder</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">ClamPizzaBuilder</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildDough</span>() { pizza_-&gt;set_dough(<span style="color: #ffa07a;">"thinCrust"</span>); }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildSauce</span>() { pizza_-&gt;set_sauce(<span style="color: #ffa07a;">"marinaSauce"</span>); }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildTopping</span>() { pizza_-&gt;set_topping(<span style="color: #ffa07a;">"pepperoni"</span>); }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> Cheese批萨的生成器</h4>
<div class="outline-text-4" id="text-2-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CheesePizzaBuilder</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">PizzaBuilder</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CheesePizzaBuilder</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildDough</span>() { pizza_-&gt;set_dough(<span style="color: #ffa07a;">"thickCrust"</span>); }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildSauce</span>() { pizza_-&gt;set_sauce(<span style="color: #ffa07a;">"plumTomato"</span>); }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">buildTopping</span>() { pizza_-&gt;set_topping(<span style="color: #ffa07a;">"pineapple"</span>); }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> <code>Waiter</code> 制作批萨</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
维护一个不同批萨生成器的实例，通过不同生成器和同样的流程制作批萨，达到制作和产品本身的分离。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Waiter</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Waiter</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_pizza_builder</span>(<span style="color: #98fb98;">PizzaBuilder</span> *<span style="color: #eedd82;">pizza_builder</span>) {
    pizza_builder_ = pizza_builder;
  }
  <span style="color: #98fb98;">Pizza</span>* <span style="color: #87cefa;">get_pizza</span>() { <span style="color: #00ffff;">return</span> pizza_builder_-&gt;get_pizza(); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">constructPizza</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">PizzaBuilder</span> *<span style="color: #eedd82;">pizza_builder_</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Waiter</span>::<span style="color: #87cefa;">constructPizza</span>() {
  pizza_builder_-&gt;createPizza();
  pizza_builder_-&gt;buildDough();
  pizza_builder_-&gt;buildSauce();
  pizza_builder_-&gt;buildTopping();
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 生成器模式(Builder)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/builder/builder_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>生成器（Builder）为创建产品（Product）对象的部分指定一个抽象接口。
</li>
<li>具体生成器（ConcreteBuilder）
<ol class="org-ol">
<li>实现生成器（Builder)的接口以构造和装配该产品(Product)的各个部件。
</li>
<li>定义并明确它所创建的表示。
</li>
<li>提供一个检索产品的接口
</li>
</ol>
</li>
<li>管理者（Director）构造一个使用Builder接口的对象
</li>
<li>产品类（Product）
<ol class="org-ol">
<li>表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。
</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；
</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十四: 代理模式(Proxy)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式14</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
在酒吧，有不同的酒和喝酒者对象，一开始，喝酒者都能喝酒，没有任何限制。之后，规定年纪小于16岁的不应该喝酒。那么如何在不改动众多的酒类的情况下，限制喝酒的年纪呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 代理模式(Proxy)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
为其他的对象提供一个代理来控制访问某个对象。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这里仅仅是保护代理的一个例子，保护代理控制对原对象的访问。
</p>

<p>
为酒类添加个代理类，有代理类控制喝酒的年纪，喝酒者如同使用实际酒类一样，使用代理酒类，因为代理酒类和实际酒类拥有共同的基类接口。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/proxy">代码实例在这里</a>。
</p>

<ol class="org-ol">
<li><code>ProxyBear</code> 与 <code>Bear</code> 都继承于 <code>Wine</code>;
</li>
<li><code>ProxyBear</code> 维护一个实际 <code>Bear</code> 的实例，由它代理访问实际对象;
</li>
<li>在 <code>ProxyBear</code> 的 <code>drink</code> 函数中，添加年纪控制。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ProxyBear</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Wine</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">ProxyBear</span>(<span style="color: #98fb98;">Drinker</span> *<span style="color: #eedd82;">drinker</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">ProxyBear</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">drink</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">Wine</span> *<span style="color: #eedd82;">real_bear_</span>;
  <span style="color: #98fb98;">Drinker</span> *<span style="color: #eedd82;">drinker_</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">kDrinkAge</span> 16
<span style="color: #7fffd4;">ProxyBear</span>::<span style="color: #87cefa;">ProxyBear</span>(<span style="color: #98fb98;">Drinker</span> *<span style="color: #eedd82;">drinker</span>) : drinker_(drinker) {
  real_bear_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Bear</span>();
}

<span style="color: #7fffd4;">ProxyBear</span>::~<span style="color: #87cefa;">ProxyBear</span>() {
  <span style="color: #00ffff;">delete</span> real_bear_;
  <span style="color: #00ffff;">delete</span> drinker_;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">ProxyBear</span>::<span style="color: #87cefa;">drink</span>() {
  <span style="color: #00ffff;">if</span> (drinker_-&gt;age() &lt; kDrinkAge) {
    cout &lt;&lt; <span style="color: #ffa07a;">"Sorry the drinker is too young to drink"</span> &lt;&lt; endl;
  } <span style="color: #00ffff;">else</span> {
    real_bear_-&gt;drink();
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 代理模式(Proxy)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/proxy/proxy_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>代理类（Proxy）
<ol class="org-ol">
<li>保存一个实际主体的引用让代理可以访问它。代理也可以引用主体（Subject）如果实际主体（RealSubject）和主体（Subject）的接口是一样的。
</li>
<li>提供一个与主体（Subjuect）一致的接口，那么代理类就能替代成实际主体。
</li>
<li>控制对实际主体的访问，并且可以负责实际主体的创建或删除。
</li>
<li>其他职责依赖于代理的类型：
<ul class="org-ul">
<li>远程代理（remote proxies）负责加密一个请求和它的参数，并把它发送给在不同地址空间的实际主体。
</li>
<li>虚拟代理（virtual proxies）可以缓存实际主体的附加信息，以便延迟对它的访问。
</li>
<li>保护代理（protection proxies）检查调用者是否有访问权限来进行一个请求。
</li>
</ul>
</li>
</ol>
</li>
<li>主体（Subject）为实际主体（RealSubject）和代理（Proxy）定义共同的接口，这样一个代理能被用在任何实际主体希望被使用的地方。
</li>
<li>实际主体（RealSubject）定义代理表示的实际对象。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<p>
代理非常适用，当需要相较于简单指针更通用或更复杂的对一个对象的引用时。下面是一些代理模式适用的常见情况：
</p>
<ol class="org-ol">
<li>一个远程代理为一个在不同地址空间的对象提供本地的表示。
</li>
<li>一个虚拟代理按需创建一个开销大的对象。
</li>
<li>一个保护代理控制对原对象的访问。保护代理非常实用当对象需要不同的访问权限。
</li>
<li>智能指引（smart reference）用来取代简单的指针指引，并执行附加操作当访问时。
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十三：状态模式(State)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式13</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<img src="http://shishougang.github.com/images/blog/2014/state/machine_state_diagram.jpeg" />

<p>
实现如上运行的糖果机，基本的做法就是定义好每个状态，然后把每个状态转换的行为定义为一个函数方法来实现状态间的转换。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">GumballMachine</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">GumballMachine</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cout</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">insertQuarter</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ejectQuarter</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">turnCrank</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dispense</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">SOLD_OUT</span> = 0;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">NO_QUARTER</span> = 1;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">HAS_QUARTER</span> = 2;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">SOLD</span> = 3;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
};
</pre>
</div>

<p>
现在糖果机生产商想新添加一个幸运机制，添加一个 <code>winner</code> 状态，有1/10的概率成为Winner，免费获得一个糖果，状态机图如下：
</p>

<img src="http://shishougang.github.com/images/blog/2014/state/machine_winner_state_diagram.jpeg" />

<p>
在原有的代码上新添加这个状态，需要在每个转换函数里修改，以致很多处修改，容易产生错误。分析这个设计的缺陷：
</p>
<ul class="org-ul">
<li>状态转换不明显，一堆判断语句在每个转换函数里;
</li>
<li>没有封装好变化部分和不变化部分，使得两者纠缠在一起;
</li>
<li>进一步添加与修改容易产生bugs。
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 状态模式(State)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
允许一个对象当它的内部状态改变时改变它的行为。这个对象看起来改变了它的类。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
按照状态模式：
</p>
<ol class="org-ol">
<li>定义抽象状态接口，包含糖果机每个状态转换行为的方法;
</li>
<li>根据接口为糖果机每个状态独立实现状态类；
</li>
<li>糖果机摆脱大量的判断语句，把状态如何转换的功能由各个状态类独立实现。
</li>
</ol>

<p>
如此把整个复杂的状态机整理的比较清晰，最后状态类图如下,<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/state">代码实例在这里</a>。
</p>
<img src="http://shishougang.github.com/images/blog/2014/state/machine_class.jpeg" />
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义抽象状态接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">State</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">State</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">insertQuarter</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ejectQuarter</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">turnCrank</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dispense</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">toString</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 实现状态类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
为糖果机每个状态独立实现状态类，这里 <code>NoQuarterState</code> 类为例如下，
<code>NoQuarterState</code> 类保存 <code>GumballMachine</code> 的实例，来实现设置糖果机状态的改变。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">NoQuarterState</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">State</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">NoQuarterState</span>(<span style="color: #98fb98;">GumballMachine</span> *<span style="color: #eedd82;">gumball_machine</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">NoQuarterState</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">insertQuarter</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ejectQuarter</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">turnCrank</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dispense</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">toString</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">GumballMachine</span> *<span style="color: #eedd82;">gumball_machine_</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">NoQuarterState</span>::<span style="color: #87cefa;">insertQuarter</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"You inserted a quarter"</span> &lt;&lt; endl;
  gumball_machine_-&gt;setState(gumball_machine_-&gt;has_quarter_state());
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">NoQuarterState</span>::<span style="color: #87cefa;">ejectQuarter</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"You haven't inserted a quarter"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">NoQuarterState</span>::<span style="color: #87cefa;">turnCrank</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"You turned, but there's no quarter"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">NoQuarterState</span>::<span style="color: #87cefa;">dispense</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"You need to pay first"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">string</span> <span style="color: #7fffd4;">NoQuarterState</span>::<span style="color: #87cefa;">toString</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">"waiting for quarter"</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 重作 <code>GumballMachine</code> 类</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
糖果机摆脱大量的判断语句，把状态如何转换的功能由各个状态类独立实现，整个类显得很清晰：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">GumballMachine</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">number_gumballs</span>) :
    count_(number_gumballs), state_(sold_out_state_) {
  sold_out_state_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SoldOutState</span>(<span style="color: #00ffff;">this</span>);
  no_quarter_state_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NoQuarterState</span>(<span style="color: #00ffff;">this</span>);
  has_quarter_state_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">HasQuarterState</span>(<span style="color: #00ffff;">this</span>);
  sold_state_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SoldState</span>(<span style="color: #00ffff;">this</span>);
  <span style="color: #00ffff;">if</span> (count_ &gt; 0) {
    state_ = no_quarter_state_;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">insertQuarter</span>() {
  state_-&gt;insertQuarter();
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">ejectQuarter</span>() {
  state_-&gt;ejectQuarter();
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">turnCrank</span>() {
  state_-&gt;turnCrank();
  state_-&gt;dispense();
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">releaseBall</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"A gumball comes rolling out the slot..."</span> &lt;&lt; endl;
  <span style="color: #00ffff;">if</span> (count_ != 0) {
    count_--;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">GumballMachine</span>::<span style="color: #87cefa;">refill</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>) {
  count_ = count;
  state_ = no_quarter_state_;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 状态模式(State)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/state/state_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>场景类（Context）
<ol class="org-ol">
<li>定义用户感兴趣的接口。
</li>
<li>保存一个定义当前状态的具体状态（ConcreteState）子类的实例。
</li>
</ol>
</li>
<li>抽象状态类(State)
定义接口来封装与场景类（Context）的每个特殊状态相关的行为。
</li>
<li>具体状态子类（ConcreteState subclasses）每个子类实现与场景类（Context）每个状态相关的行为。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象的行为依赖于它的状态，并且再运行时它必须依赖于这个状态来改变它的行为。
</li>
<li>代码操作中拥有大量的依赖于对象状态的条件语句。这个状态通常被一个多多个枚举定值表示。时常，许多操作包含这同样的条件分支结构。状态模式将每个分支放入一个独立的类中。这让你可以把对象的状态当成每个自己负责的对象，而且这些对象能互相独立。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十二: 组合模式(Composite)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式12</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
上节使用迭代器模式可以很方便访问各个菜单目录下的菜单，易易于菜单目录的扩展。但现在菜单目录下新增加了子菜单，比如 <code>DinerMenu</code> 下有
<code>DessertMenu</code> 的子菜单，那么如何更进一步改进我们的设计，新设计至少需要：
</p>

<ul class="org-ul">
<li>一种树状结构来包含菜单目录，子目录和菜单项。
</li>
<li>遍历菜单目录里的每个菜单项如何迭代器一样方便。
</li>
<li>遍历菜单更灵活。比如，只遍历Diner的desssert菜单，或遍历整个Diner菜单，包括dessert菜单。
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 组合模式(Composite)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
把对象组合成树状结构来表示部分-整体的层次结构。组合模式让用户能一致的对待单个对象和组合对象。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
组合模式能以树状的形式建立对象的结构，并同时包换对象的组合和单个对象作为树的节点。使用一个组合的结构，能对组合和单个对象使用同样的操作。也就是说，大多数情况下，我们能忽略对象组合和单个对象的区别。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/composite">代码实例在这里</a>
。基本的组合树状结构如下：
</p>
<img src="http://shishougang.github.com/images/blog/2014/composite/composite_tree.jpeg" />

<p>
按照下面组合模式的结构图具体实现。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义构件接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
定义 <code>MenuComponent</code> 构件类，为页节点（ <code>MenuItem</code> ）和组合节点（ <code>Menu</code> ）声明接口，并为它们实现默认的操作。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">MenuComponent</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">MenuComponent</span>() { }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">menu_component</span>) {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove</span>(<span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">menu_component</span>) {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">MenuComponent</span>* <span style="color: #87cefa;">getChid</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">description</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">price</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">isVegetarian</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Iterator</span>* <span style="color: #87cefa;">createIterator</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">print</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">throw</span> runtime_error(<span style="color: #ffa07a;">"Unsupported Operation!"</span>);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 实现 <code>MenuItem</code> （页节点）</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>菜单项直接打印自己的菜单项;
</li>
<li>菜单项只有本身，不用遍历，返回空的迭代器实例。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">MenuItem</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">MenuComponent</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">MenuItem</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">name</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">description</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">vegetarian</span>,
           <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">price</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">MenuItem</span>();
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> name_;
  }
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">description</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> description_;
  }
  <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">price</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> price_;
  }
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">isVegetarian</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> vegetarian_;
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">print</span>() <span style="color: #00ffff;">const</span>;
  Iterator* createIterator();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">description_</span>;
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">vegetarian_</span>;
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">price_</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">MenuItem</span>::<span style="color: #87cefa;">print</span>() <span style="color: #00ffff;">const</span> {
  cout &lt;&lt; <span style="color: #ffa07a;">"  "</span> &lt;&lt; name();
  <span style="color: #00ffff;">if</span> (isVegetarian()) {
    cout &lt;&lt; <span style="color: #ffa07a;">"(v)"</span>;
  }
  cout &lt;&lt; <span style="color: #ffa07a;">", "</span> &lt;&lt; price() &lt;&lt; endl;
  cout &lt;&lt; <span style="color: #ffa07a;">"    -- "</span> &lt;&lt; description() &lt;&lt; endl;
}

<span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">MenuItem</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NullIterator</span>();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 实现 <code>Menu</code> （组合节点）</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
<code>Menu</code> 类和 <code>MenuItem</code> 类都继承于构件接口类，大部分相同，但
</p>
<ul class="org-ul">
<li><code>Menu</code> 有子节点，实现 <code>getChild</code> 功能;
</li>
<li><code>Menu</code> 需要遍历所有它的子节点，实现创建组合迭代器;
</li>
<li><code>Menu</code> 打印所有它节点下的菜单项，包括自身的和所有子节点的。
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Menu</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">MenuComponent</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Menu</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">name</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">description</span>);
  ~<span style="color: #87cefa;">Menu</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add</span>(<span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">menu_component</span>);
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove</span>(<span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">menu_component</span>);
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">MenuComponent</span>* <span style="color: #87cefa;">getChild</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) <span style="color: #00ffff;">const</span>;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> name_;
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">description</span>() <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">return</span> description_;
  }
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Iterator</span>* <span style="color: #87cefa;">createIterator</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">print</span>() <span style="color: #00ffff;">const</span>;
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">description_</span>;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuComponent</span>*&gt; *<span style="color: #eedd82;">menu_components_</span>;
};

<span style="color: #98fb98;">MenuComponent</span>* <span style="color: #7fffd4;">Menu</span>::<span style="color: #87cefa;">getChild</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) <span style="color: #00ffff;">const</span> {
  <span style="color: #00ffff;">if</span> (i &lt; 0 || i &gt;= menu_components_-&gt;size()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  }
  <span style="color: #00ffff;">return</span> menu_components_-&gt;at(i);
}

<span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">Menu</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Composite</span> Iterator(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">MenuIterator</span>(menu_components_));
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Menu</span>::<span style="color: #87cefa;">print</span>() <span style="color: #00ffff;">const</span> {
  cout &lt;&lt; endl &lt;&lt; name();
  cout &lt;&lt; <span style="color: #ffa07a;">", "</span> &lt;&lt; description() &lt;&lt; endl;
  cout &lt;&lt; <span style="color: #ffa07a;">"---------------------"</span> &lt;&lt; endl;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; menu_components_-&gt;size(); ++i) {
    <span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">item</span> = menu_components_-&gt;at(i);
    item-&gt;print();
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 实现组合迭代器</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
组合迭代器 <code>CompositeIterator</code> 继承于迭代器接口 <code>Iterator</code> 。组合迭起器实现起来更复杂，需要考虑树状结构的遍历，这里利用堆栈来保存组合节点，实现深度优先的遍历。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CompositeIterator</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">CompositeIterator</span>(<span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">iterator</span>);
  ~<span style="color: #87cefa;">CompositeIterator</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">Iterator</span>*&gt; *<span style="color: #eedd82;">stack_</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #7fffd4;">CompositeIterator</span>::<span style="color: #87cefa;">hasNext</span>() {
  <span style="color: #00ffff;">if</span> (stack_-&gt;empty()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">iterator</span> = stack_-&gt;top();
    <span style="color: #00ffff;">if</span> (!iterator-&gt;hasNext()) {
      stack_-&gt;pop();
      <span style="color: #00ffff;">delete</span> iterator;
      <span style="color: #00ffff;">return</span> hasNext();
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    }
  }
}

<span style="color: #98fb98;">void</span>* <span style="color: #7fffd4;">CompositeIterator</span>::<span style="color: #87cefa;">next</span>() {
  <span style="color: #00ffff;">if</span> (hasNext()) {
    <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">iterator</span> = stack_-&gt;top();
    <span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">component</span> =
        <span style="color: #00ffff;">reinterpret_cast</span>&lt;MenuComponent*&gt;(iterator-&gt;next());
    <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">typeid</span>(*component) == <span style="color: #00ffff;">typeid</span>(Menu)) {
      stack_-&gt;push(component-&gt;createIterator());
    }
    <span style="color: #00ffff;">return</span> component;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> <code>Waitress</code> 访问菜单</h4>
<div class="outline-text-4" id="text-2-2-5">
<ul class="org-ul">
<li><code>Waitress</code> 打印菜单直接调用构件的打印功能;
</li>
<li>打印蔬菜菜单，利用组合迭代器遍历并判断蔬菜菜单
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Waitress</span>::<span style="color: #87cefa;">printMenu</span>() {
  all_menus_-&gt;print();
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Waitress</span>::<span style="color: #87cefa;">printVegetarianMenu</span>() {
  <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">iterator</span> = all_menus_-&gt;createIterator();
  cout &lt;&lt; <span style="color: #ffa07a;">"\nVEGETARIAN MENU\n----"</span> &lt;&lt; endl;
  <span style="color: #00ffff;">while</span> (iterator-&gt;hasNext()) {
    <span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">menu_component</span> = <span style="color: #00ffff;">reinterpret_cast</span>&lt;MenuComponent *&gt;
        (iterator-&gt;next());
    <span style="color: #00ffff;">try</span> {
      <span style="color: #00ffff;">if</span> (menu_component-&gt;isVegetarian()) {
        menu_component-&gt;print();
      }
    } <span style="color: #00ffff;">catch</span> (exception &amp;ex) {
    }
  }
  <span style="color: #00ffff;">delete</span> iterator;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> 组合菜单</h4>
<div class="outline-text-4" id="text-2-2-6">
<p>
用 <code>MenuItem</code> 创建各个菜单项，把各个菜单目录组合只需用构件的 <code>add</code> 函数来完成，如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">cafe_menu</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Menu</span>(<span style="color: #ffa07a;">"CAFE MENU"</span>, <span style="color: #ffa07a;">"Dinner"</span>);
<span style="color: #98fb98;">MenuComponent</span> *<span style="color: #eedd82;">coffee_menu</span> =
      <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Menu</span>(<span style="color: #ffa07a;">"COFFEE MENU"</span>, <span style="color: #ffa07a;">"Stuff to go with your afternoon coffee"</span>);

cafe_menu-&gt;add(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">MenuItem</span>(
      <span style="color: #ffa07a;">"Burrito"</span>,
      <span style="color: #ffa07a;">"A large burrito, with whole pinto beans, salsa, guacamole"</span>,
      <span style="color: #7fffd4;">true</span>, 
      4.29));

cafe_menu-&gt;add(coffee_menu);

coffee_menu-&gt;add(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">MenuItem</span>(
    <span style="color: #ffa07a;">"Coffee Cake"</span>,
    <span style="color: #ffa07a;">"Crumbly cake topped with cinnamon and walnuts"</span>,
    <span style="color: #7fffd4;">true</span>,
    1.59));
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> 总的设计框架</h4>
<div class="outline-text-4" id="text-2-2-7">
<img src="http://shishougang.github.com/images/blog/2014/composite/menu_structure.jpeg" />
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 组合模式(Composite)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/composite/composite_structure.jpeg" />

<p>
一个典型组合对象结构类似如下图：
</p>
<img src="http://shishougang.github.com/images/blog/2014/composite/composite_object_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>构件类（Component）
<ol class="org-ol">
<li>为组合模式中的对象声明接口。
</li>
<li>适当的为所有类共有接口实现默认的行为。
</li>
<li>声明一个接口来访问和管理它的子节点。
</li>
<li>（可选的）定义一个接口来访问一个构件在递归结构下的父元件，如果适当的话，并实现这个接口
</li>
</ol>
</li>
<li>树叶类（Leaf）
<ol class="org-ol">
<li>在组合模式中表示树叶类。一个树叶类没有子节点。
</li>
<li>在组合模式中为基础对象定义行为。
</li>
</ol>
</li>
<li>客户（Client)
通过元件接口来操作组合模式中的对象。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>你想表示对象的部分-整体层次结构。
</li>
<li>你想客户能够忽略对象组合和单个对象的区别。客户能一致的对待组合结构中的所有对象。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<p>
组合模式其中一个特性是：使得你的设计更具一般性。添加新构件很容易的缺点就是使得很难限制组合模式中的构件。有时你想要一个组合只有某些特性的元件，但是，使用组合模式，你不能依靠类型系统来实施这些限制，你不得不使用运行时检查。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十一: 迭代器模式(Iterator)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式11</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
为了提高市场竞争力，早餐店(Pancake House)和午餐店（Diner）合并了。如下整合他们的菜单让服务员使用。
</p>

<p>
<code>PancakeHouseMenu</code> 类使用 <code>vector</code> 来维护它的菜单，它认为使用 <code>vector</code>
可以很容易的扩展自己的菜单。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PancakeHouseMenu</span> {
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">menu_items_</span>;
};
</pre>
</div>

<p>
<code>DinerMenu</code> 类使用数组来维护它的菜单，它认为使用数组能控制菜单数目和更快速的添加菜单。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DinerMenu</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kMaxItems</span> = 6 };
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">number_of_items_</span>;
  MenuItem *menu_items_[kMaxItems];
};
</pre>
</div>

<p>
那么 <code>Waitress</code> 类需要使用两个循环分别访问它们的菜单来打印整个菜单。但问题是：
</p>
<ul class="org-ul">
<li>面向菜单的具体实现来编码而不是接口。
</li>
<li>如果增加一个新的餐厅类，就需要另外一个循环，代码冗余，不易扩展。
</li>
<li><code>Waitress</code> 需要知道每个餐厅类是如何内部表示它的菜单，破坏了它们的封装。
</li>
<li>如果餐厅类改变存储菜单的方式，比如由数组变成Hashtable，那么
  <code>Waitress</code> 需要很大的改动。
</li>
</ul>

<p>
如何设计使得避免这些问题呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 迭代器模式(Iterator)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
提供一种方法来序列访问一个聚合对象的元素，而不暴露它底层的实现。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
使用迭代起模式，分别创建餐厅类的迭代器类实现迭代起的抽象统一接口，餐厅类利用这个各自的迭代器类创建它的迭代器实例让调用者使用，调用者只需要这个迭代器实例就可以访问它的所有菜单。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/iterator">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义迭代器抽象接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Iterator</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 实现 <code>DinerMenu</code> 的迭代器类 <code>DinerMenuIterator</code></h4>
<div class="outline-text-4" id="text-2-2-2">
<img src="http://shishougang.github.com/images/blog/2014/iterator/dinermenu_iterator.jpeg" />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DinerMenuIterator</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kMaxItems</span> = 6 };
  <span style="color: #87cefa;">DinerMenuIterator</span>(<span style="color: #98fb98;">MenuItem</span> **<span style="color: #eedd82;">items</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">DinerMenuIterator</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">MenuItem</span> **<span style="color: #eedd82;">items_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">position_</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #7fffd4;">DinerMenuIterator</span>::<span style="color: #87cefa;">hasNext</span>() {
  <span style="color: #00ffff;">if</span> (position_ &gt;= kMaxItems || items_[position_] == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">void</span>* <span style="color: #7fffd4;">DinerMenuIterator</span>::<span style="color: #87cefa;">next</span>() {
  <span style="color: #98fb98;">MenuItem</span>* <span style="color: #eedd82;">menu_item</span> = items_[position_];
  position_++;
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #98fb98;">void</span>*&gt;(menu_item);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 实现 <code>PancakeHouseMenu</code> 的迭代器类 <code>PancakeHouseMenuIterator</code></h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PancakeHouseMenuIterator</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">PancakeHouseMenuIterator</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">items</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">PancakeHouseMenuIterator</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>();
  <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">items_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">position_</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #7fffd4;">PancakeHouseMenuIterator</span>::<span style="color: #87cefa;">hasNext</span>() {
  <span style="color: #00ffff;">if</span> (position_ &gt;= items_-&gt;size() || items_-&gt;at(position_) == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">void</span>* <span style="color: #7fffd4;">PancakeHouseMenuIterator</span>::<span style="color: #87cefa;">next</span>() {
  <span style="color: #98fb98;">MenuItem</span> *<span style="color: #eedd82;">menu_item</span> = items_-&gt;at(position_);
  position_++;
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #98fb98;">void</span>*&gt;(menu_item);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 定义餐厅类抽象接口</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
每个餐厅都要完成创建自己的迭代器实例。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Menu</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Menu</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Iterator</span>* <span style="color: #87cefa;">createIterator</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> <code>DinerMenu</code> 实现创建迭代器实例</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">DinerMenu</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">DinerMenuIterator</span>(menu_items_);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> <code>PancakeHouseMenu</code> 实现创建迭代器实例</h4>
<div class="outline-text-4" id="text-2-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">PancakeHouseMenu</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PancakeHouseMenuIterator</span>(menu_items_);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> <code>Waitress</code> 使用迭代器打印菜单</h4>
<div class="outline-text-4" id="text-2-2-7">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Waitress</span>::<span style="color: #87cefa;">printMenu</span>() <span style="color: #00ffff;">const</span> {
  <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">pancake_iterator</span> = pancake_house_menu_-&gt;createIterator();
  <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">diner_iterator</span> = diner_menu_-&gt;createIterator();

  cout &lt;&lt; <span style="color: #ffa07a;">"MENU\n----\nBREAKFAST"</span> &lt;&lt; endl;
  printMenu(pancake_iterator);
  cout &lt;&lt; <span style="color: #ffa07a;">"\nLUNCH"</span> &lt;&lt; endl;
  printMenu(diner_iterator);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-8" class="outline-4">
<h4 id="sec-2-2-8"><span class="section-number-4">2.2.8</span> 总的设计框架</h4>
<div class="outline-text-4" id="text-2-2-8">
<img src="http://shishougang.github.com/images/blog/2014/iterator/menu_structure.jpeg" />
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 迭代器模式(Iterator)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/iterator/iterator_structure.jpeg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>迭代器类（Iterator）定义一个接口来访问和遍历元素。
</li>
<li>具体迭代器类（ConcreteIterator）
<ol class="org-ol">
<li>实现迭代器接口。
</li>
<li>保存遍历聚合元素的当前位置
</li>
</ol>
</li>
<li>聚合类（Aggregate）定义一个接口来创建迭代器对象。
</li>
<li>具体聚合类（ConcreteAggregate）实现迭代器创建接口来返回相应具体迭代器的一个实例。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>访问一个聚合对象的内容，但却不想暴露它的内部实现。
</li>
<li>为聚合对象支持所有遍历方法。
</li>
<li>为遍历不同的聚合结构提供一种统一的接口（即，支持多态迭代化）。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十: 模板方法模式(Template Method)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式10</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
有些人喜欢喝茶，有些人喜欢喝咖啡，所以现在有咖啡和茶两个类，基本代码如下：
</p>

<p>
<code>Coffee</code> 类：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Coffee</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Coffee</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">prepareRecipe</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">boilWater</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">brewCoffeeGrinds</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pourInCup</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addSugarAndMilk</span>();
};
</pre>
</div>

<p>
<code>Tea</code> 类：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Tea</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Tea</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">prepareRecipe</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">boilWater</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">steepTeaBag</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pourInCup</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addLemon</span>();
};
</pre>
</div>

<p>
我们发现代码有重复： <code>void boilWater()</code> 和 <code>void pourInCup()</code> 。那么如何整合代码消除重复代码呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 模板方法模式(Template method)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
为操作中的算法定义一个构架，把一些步骤延迟到子类来完成。模板方法让子类能不改变算法框架的前提下重定义这算法的一些步骤。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/templatemethod">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 提取不变，抽象变化</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
提取出不变的地方，在基类类定义并实现，然子类共同拥有，抽象变化地方为抽象接口，延迟到让子类来实现。
</p>

<img src="http://shishougang.github.com/images/blog/2014/templatemethod/compare_class.jpeg" />

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CaffeineBeverage</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CaffeineBeverage</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">prepareRecipe</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">boilWater</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pourInCup</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">brew</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addCondiments</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> <code>Coffee</code> 类实现自己功能</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
<code>Coffee</code> 类继承基类 <code>CaffeineBeverage</code> ，并实现抽象接口来完成自己的算法功能。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Coffee</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CaffeineBeverage</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Coffee</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">brew</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addCondiments</span>();
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Coffee</span>::<span style="color: #87cefa;">brew</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"Dripping Coffee through filter"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Coffee</span>::<span style="color: #87cefa;">addCondiments</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"Adding Sugar and Milk"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> <code>Tea</code> 类实现自己功能</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
<code>Tea</code> 类继承基类 <code>CaffeineBeverage</code> ，并实现抽象接口来完成自己的算法功能。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Tea</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CaffeineBeverage</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Tea</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">brew</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">addCondiments</span>();
};

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Tea</span>::<span style="color: #87cefa;">brew</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"Steeping the tea"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Tea</span>::<span style="color: #87cefa;">addCondiments</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"Adding Lemon"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 总的模式设计</h4>
<div class="outline-text-4" id="text-2-2-4">
<img src="http://shishougang.github.com/images/blog/2014/templatemethod/template_whole.jpeg" />
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 模板方法模式(Template method)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="http://shishougang.github.com/images/blog/2014/templatemethod/template_method_structure.jpg" />
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象类（AbstractClass）
<ol class="org-ol">
<li>定义抽象的原语操作，具体子类将重定义它们来实现算法的步骤。
</li>
<li>实现一个模板方法定义一个算法的构架。模板方法调用原语操作和抽象类或其他对象定义的操作。
</li>
</ol>
</li>
<li>具体类（ConcreteClass）实现原语操作来执行算法中子类特有的步骤。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一次性实现一个算法的不变部分，把变化部分留给子类去实现。
</li>
<li>各子类间的共同行为需要被提取并集中到一个共同的类中来避免代码的重复。你首先识别出这些现有代码的不同之处，然后把这些不同之处分离到新的操作中。最后，你用一个模板方法调用这些新操作之一来替代原有那些不同的代码。
</li>
<li>控制子类扩展。你能定义一个只在特定点调用 <code>hook</code> 操作的模板方法，以此只允许子类在这些点扩展。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
