---
layout: post
title: "Programming Pearls: Column8"
date: 2014-05-17
comments: true
categories: [Programming Pearls]
tags: [Programming Pearls]
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">问题与算法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
给出数组中找出连续子数组最大和。
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">1</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
直接算每个子区间的和并比较得出最大值。算法复杂度 O(n<sup>3</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg1</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; num.size(); ++j) {
      sum = 0;
      <span style="color: #00ffff;">for</span> (k = i; k &lt;= j; k++) {
        sum += num[k];
        <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
          max_sofar = sum;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">2</h4>
<div class="outline-text-4" id="text-1-1-2">
</div><div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">2.1</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
因为x[i..j]直接的和可以基于x[i..j-1]的和算出，不用重头开始算。算法复杂度 O(n<sup>2</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    sum = 0;
    <span style="color: #00ffff;">for</span> (j = i; j &lt; num.size(); ++j) {
      sum += num[j];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2">2.2</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
先算出x[0..i]区间的和为 <code>cum_vector[i]</code> ，那么x[i..j]区间的和就是
<code>cum_vector[j] - cum-vector[i-1]</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2b</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; <span style="color: #eedd82;">cum_vector</span>(num.size() + 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  cum_vector[0] = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    cum_vector[i] = cum_vector[i - 1] + num[i];
  }
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = i; j &lt; cum_vector.size(); ++j) {
      sum = cum_vector[j] - cum_vector[i - 1];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">3</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Divide-and-Conquer算法。
</p>
<ol class="org-ol">
<li>求整个数组的子数组和，可以分成前面一半和后面一半
</li>
</ol>
{% img /images/blog/2014/programmingpearls/column8_3_1.jpg  'column8_3_1' %}

<ol class="org-ol">
<li>求出前半部分的最大子数组和后半部分的最大子数组和
</li>
</ol>
{% img /images/blog/2014/programmingpearls/column8_3_2.jpg  'column8_3_2' %}

<ol class="org-ol">
<li>求出两部分中间连着的子数组最大和
</li>
</ol>
{% img /images/blog/2014/programmingpearls/column8_3_3.jpg  'column8_3_3' %}

<ol class="org-ol">
<li>最后比较这3部分和就能得出整个个数组的子数组最大和
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3Core</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #00ffff;">if</span> (l &gt; u) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">if</span> (l == u) {
    <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">max</span>&lt;<span style="color: #98fb98;">float</span>&gt;(num[l], 0);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = (l + u) / 2;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">lmax</span>, <span style="color: #eedd82;">rmax</span>, <span style="color: #eedd82;">sum</span>;
  lmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m; i &gt;= l; --i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; lmax) {
      lmax = sum;
    }
  }
  rmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m + 1; i &lt;= u; ++i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; rmax) {
      rmax = sum;
    }
  }
  <span style="color: #00ffff;">return</span> max(lmax + rmax, max(FindMaxSubvectorAlg3Core(num, l, m),
                              FindMaxSubvectorAlg3Core(num, m + 1, u)));
}

<span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #00ffff;">return</span> FindMaxSubvectorAlg3Core(num, 0, num.size() - 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">4</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
假定已经解决了x[0..i-1]的情况，那么如何扩展到x[0..i]的情况，只多了x[i]
元素？
</p>

<ol class="org-ol">
<li>解决了x[0..i-1]的情况，有这区间的最大子数组和 <code>max_sofar</code> ，和必须以
x[i-1]结尾的子数组最大和;
</li>
<li>到x[0..i]的情况，就要把必须以x[i-1]结尾的子数组最大和与x[i]相加，如果以x[i-1]结尾的子数组为负数的话，加了反而减少总和。所以此种情况以
x[i]的和就是x[i];
</li>
<li>最后把以x[i]与在区间x[0..i-1]的最大子数组和 <code>max_sofar</code> 比较，就能解决
x[0..i]的情况;
</li>
<li>如此一直扩展到x[0..n]算出整个数组的最大子数组和。
</li>
</ol>

<p>
只扫描一遍，算法复杂度O(n)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg4</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">max_sofar</span>, <span style="color: #eedd82;">max_ending_here</span>;
  max_sofar = max_ending_here = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num.size(); ++i) {
    max_ending_here += num[i];
    <span style="color: #00ffff;">if</span> (max_ending_here &lt; 0) {
      max_ending_here = 0;
    }
    <span style="color: #00ffff;">if</span> (max_ending_here &gt; max_sofar) {
      max_sofar = max_ending_here;
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">算法设计技巧</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>保存状态防止重复计算。
</li>
<li>预处理信息到适当的数据结构中来加快之后的计算。比如先建立堆，先排序等。
</li>
<li>分而治之，把大问题分成类似的小问题解决。
</li>
<li>扫描算法。比如解出了x[0..i-1]如何扩展到x[0..i].
</li>
<li>累积。
</li>
<li>确定问题的算法复杂度下界。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">10</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>初始化累积和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code> ， 那么要x[l..u]
区间的和为0的话，cum[l-1] = cum[u]
</li>
<li>排序cum数组;
</li>
<li>扫描排序好的数组cum，找出最相近的相邻数组元素即得到结果。
</li>
</ol>

<p>
算法复杂度 O(n) + O(nlogn) + O(n-1) = O(nlogn).
</p>

<p>
找出子数组和与一个特定值r最相近，算法类似，只是step3找出与r最相近的相邻数组元素。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">11</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>累积收费和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code>
</li>
<li>计算l和u关卡之间的收费 cum[u]-cum[l]
</li>
</ol>
</div>
</div>
</div>
