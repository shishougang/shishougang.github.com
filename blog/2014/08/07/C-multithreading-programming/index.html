
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>浅谈C++ Multithreading Programming - (learn&think)</title>
  <meta name="author" content="DreamRunner">


<meta name="description" content="浅谈C++ multithreading programming, 包括Pthread和Boost thread">
<meta name="keywords" content="Multithreading, C++, Pthread, Boost thread, process, thread, mutex, condition">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="(learn&think)" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
  TeX: { extensions: ["color.js"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>


  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32977383-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">(learn&think)</a></h1>
  
    <h2>不浮躁，不自傲，学习，思考，总结</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:dreamrunner.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/tag-cloud">Tag Cloud</a></li>
  <li><a href="/my-wiki">My Wiki</a></li>
  <li><a href="/friends-links">Friends' Links</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">浅谈C++ Multithreading Programming</h1>
    
    
      <p class="meta">
        











<time datetime="2014-08-07T00:00:00+08:00"  class="updated" >Aug 7<span>th</span>, 2014</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://dreamrunner.org">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
随着多核 CPU 随处可见,多线程(multithreading)可以被用来实现并行,提高 CPU 的利用率和性能显著的提高.掌握多线程编程也成为现代实现软件的基本要求技能之一.<a href="https://computing.llnl.gov/tutorials/parallel_comp/">Introduction to Parallel Computing</a>详细的介绍了 Parallel Computing;
为什么使用它;Parallel Computing 的分类;Parallel Computing 的 limits 和
costs; Parallel Computing 的程序模型;如何设计 Parallel 程序等.
</p>

<p>
这里先介绍多线程的概念,多线程中涉及的基本概念,然后用实例介绍 Pthread 库的使用,并介绍 Google Code 中如何把它封装成 C++类,最后介绍可移植并大量使用的
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread 库</a>.
</p>

<p>
还有一些其他的 Thread 库:
</p>
<ul class="org-ul">
<li><a href="http://openmp.org/wp/">OpenMP</a> 是一个可移植的接口,在共享内存的多处理器上实现 fork-join 并行.
OpenMP 的 tutorial:<a href="https://computing.llnl.gov/tutorials/openMP/">这里</a> 和 <a href="http://vergil.chemistry.gatech.edu/resources/programming/OpenMP.pdf">这里</a>,
</li>
<li><a href="http://omniorb.sourceforge.net/omni42/omnithread.html">OMNI Thread</a>为 C++提供 Thread 操作的.
</li>
<li><a href="http://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries">其他 multithreading libraries</a>.
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Thread</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">定义</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A <b>thread</b> is defined as an independent stream of instructions that can
be scheduled to run as such by the operating system.所以它是在程序中独立于其他代码可由操作系统调度的一段指令.
</p>

<p>
那么是操作系统是如何具体实现这一独立性呢?
</p>

<p>
要理解 thread,必须先明白 process.进程由操作系统创建来运行相应的程序,进程包含程序资源和程序执行状态的信息.以 Linux 的进程为例包含:
</p>
<ul class="org-ul">
<li>Process ID, process group ID, user ID, and group ID
</li>
<li>Environment
</li>
<li>Working directory
</li>
<li>Program instructions
</li>
<li>Registers
</li>
<li>Stack
</li>
<li>Heap
</li>
<li>File descriptors
</li>
<li>Signal actions
</li>
<li>Shared libraries
</li>
<li>Inter-process communication tools (such as message queues, pipes,
semaphores, or shared memory).
</li>
</ul>

<img class="center" src="/images/blog/2014/c++_multithreaing/process_thread.png" />

<p>
Thread 使用 Process 的资源,并且能成为独立的元件被操作系统调度,是因为它仅重复那些使得它们能成为独立运行代码的必要资源.Thread 维护它自己如下的信息:
</p>
<ul class="org-ul">
<li>Stack pointer
</li>
<li>Registers
</li>
<li>Scheduling properties (such as policy or priority)
</li>
<li>Set of pending and blocked signals
</li>
<li>Thread specific data.
</li>
</ul>

<p>
与 Process 比较,Thread 可以总结如下:
</p>
<ul class="org-ul">
<li>Thread 相当于一个 lightweight 的 Process,拥有如 ID,properties 等相似信息,
但仅仅包含能使得它独立运行的信息即可.
</li>
<li>信息包含的不同,与需要复制大量信息来创建 Process 比,Thread 的创建比较快捷.
</li>
<li>独立的 Processes 不共享任何信息.每个 Process 运行在独立的地址空间.Threads 共享所在 Process 的资源,全局变量和文件描述符.
</li>
<li>Threads 可以直接与所在同一 Process 的 Threads 通信.而 Processes 必须使用
inter-process communication(IPC)来通信.
</li>
<li>因为 Threads 的资源共享性,增加并行操作资源的难度,需要引入 Thread 同步机制来达到资源并行性.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">一些术语</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Posix Thread 基本模型如下图,一些有关其中 Thread 的术语:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/threads_model.png" />

<ul class="org-ul">
<li><b>Lightweight Process(LWP)</b> 可以被认为虚拟的 CPU,在系统中通常 LWP 的个数大于实际 CPU 个数.Thread 库通过与 LWP 沟通来调度 thread.LWP 也通常被称为
kernel threads.
</li>
<li><b><a href="http://en.wikipedia.org/wiki/System_Contention_Scope">Contention Scope</a></b> 是如何决定哪个线程得到调度.
</li>
<li><b>Bound threads</b> 拥有系统级别的 Contention Scope,也就是,它们与其他进程一同竞争.
</li>
<li><b>Unbound threads</b> 拥有进程级别的 Contention Scope.
</li>
<li><b>Thread-safe</b> 意味共享数据被得到保护,可以同时被多个 thread 调用而安全.
</li>
<li><b>Reentrant code</b> 意味程序可以被多个 thread 并行运行.
</li>
<li><b><a href="https://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions">asynchronous-safe function</a></b> 在 signal handler 下被安全调用并没有任何副作用.
</li>
<li><b>Concurrency vs. Parallelism</b> 并不一样.Parallelism 意味同时运行代码.而
Concurrency 意味许多任务可以以任何顺序执行或可以是并行运行.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Amdahl 法则和 Pareto 原则</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Threads 能提供益处 <i>对于相适</i> 的应用.所以 thread 的并行性对于应用来说也有它的限制.
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Amdahl 法则</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
<a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl 法则</a> 陈述到潜在的程序加速由能被并行的代码率 P 定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{1-P}
\end{align}
$$

<ul class="org-ul">
<li>如果代码中没有能并行的部分,P=0,那么 speedup=1.
</li>
<li>如果所有代码都能并行,P=1,那么 speedup 能达到无限(理论上).
</li>
<li>如果 50%的代码能并行,那么最大的 speedup=2,也就是最多 2 倍的加速.
</li>
</ul>

<p>
引入能并行的处理器个数,那么进一步可以定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{\dfrac{P}{N} + (1-P)}
其中 P 并行率,N 处理器个数
\end{align}
$$

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl1.gif" />

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl2.gif" />
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Pareto 原则</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
<a href="http://en.wikipedia.org/wiki/Pareto_principle">Pareto 原则</a> 陈述到 80%的处理器时间花在 20%的代码中.所以仔细分析代码,不要把时间花在并行/优化那部分不重要的代码.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Thread 设计模式<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-3">
<p>
在程序中有不同的方法使用线程,这里讨论 3 种线程设计模式,没有哪一种模式最好,每种模式都有相应适合的应用场合.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Boss/worker(Thread pool)</h3>
<div class="outline-text-3" id="text-3-1">
<img class="center" src="/images/blog/2014/c++_multithreaing/boss_workers_pattern.gif" />

<p>
如上图,一个 Boss 线程创建其他 Worker 线程,并给它们分配任务,必要的话,并等待其他线程运行结束.通常 Boss 线程会在初始建立 Thread Pool 来为之后分配.尽管线程是轻量级的,但是创建它们仍是有开销的.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Peer(Workcrew)</h3>
<div class="outline-text-3" id="text-3-2">
<img class="center" src="/images/blog/2014/c++_multithreaing/peer_pattern.gif" />

<p>
Peer 模式又叫做 workcrew 模式,一个 thread 创建其他 peer threads 当程序开始,但是如上图,与 Boss/worker 模式不同,这个 thread 之后也变成 peer thread 去处理自己的任务.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Pipeline</h3>
<div class="outline-text-3" id="text-3-3">
<img class="center" src="/images/blog/2014/c++_multithreaing/pipeline_pattern.gif" />

<p>
Pipeline 模式假定:
</p>
<ul class="org-ul">
<li>一串连续长输入.
</li>
<li>每个输入经过一连串的子操作(熟知为 stages 或 fliers).
</li>
<li>每个处理 stage 能一次处理个不同的输入.
</li>
</ul>

<p>
如上图, Pipeline 就像流水线一般,每个 thread 是一个长链中的一部分.每个
thread 处理由之前 thread 过的数据.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">线程同步原语</h2>
<div class="outline-text-2" id="text-4">
<p>
如上线程中的定义,线程们共享进程中的全局变量或资源,它们可以并行同时对这些数据和资源操作,如果没有一定的机制协调它们,那么数据或资源将处于一个不安全状态,引起诸如如下的一些问题:
</p>

<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Race_condition#Software">Race condition</a>发生于不能决定行为的结果因为线程们操作共享数据或资源没有遵循一定的同步规则.
</li>
<li><a href="http://en.wikipedia.org/wiki/ABA_problem">ABA problem</a>发生于一个地方被读取两次,都读到相同的值,&#8217;值是相同的&#8217;被用来说明&#8217;没有东西被改变&#8217;.但是,另外一个线程能在这两次读取中间执行操作并修改这个位置的值,然后做一些其他操作,最后把这个值改回去,以致愚弄第一个线程让它认为&#8217;没有东西被改变&#8217;,即使第二个线程的操作已经破坏了这个假设.
</li>
</ul>

<p>
所以我们需要如下的一些线程同步原语满足不同的线程间同步需求.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Mutex</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29">Mutex</a> 又被称为 Lock,所以它就像一把 Lock,一个线程 Lock 住一段资源,那么其他线程就不能去访问那段资源,只有等到第一个线程 Unlock 那么资源,它才能访问.
</p>

<p>
在 Lock 和 Unlock 之间的代码,一般被称为 <b>critical section</b>.
</p>

<p>
Mutex 也包含一些复杂的类型,如下:
</p>
<ul class="org-ul">
<li>Recursive: 允许占有锁的那一个线程再次获取同样的锁,对递归算法是必要的.
</li>
<li>Queuing: 使得 <b>公平</b> 的获取锁,通过 FIFO 排序锁的请求.
</li>
<li>Reader/Writer(rwlock): 允许多个 reader 同时获取锁,如果有 reader 占用锁,writer 只有等到 reader 释放锁.
</li>
<li>Scoped: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> 类型定义的锁获取和解锁.
</li>
</ul>

<p>
但 Mutex 也会引入其他一些问题,如<a href="http://en.wikipedia.org/wiki/Deadlock">deadlock</a> 和 <a href="http://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>.
</p>

<p>
在 Blog 中之前<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/">浅谈 Mutex (Lock)</a>中可以看到更多有关 Mutex 的性能和开销分析,并如何实现一个轻量级的 Mutex.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Join</h3>
<div class="outline-text-3" id="text-4-2">
<p>
线程 join 机制能让一个线程 join 到另外一个线程中.比如一个子线程 join 回主线程,那么主线程就会等待子线程运行结束.从而达到线程间等待的同步机制.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Condition Variable</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Condition variable 允许线程同步到某个共享资源的某个值.
</p>

<p>
比如,程序有一个计数器,当计数器达到某一个值时去激活某个线程运行.把计数器当成一个 Condition variable.这个线程可以等待这个 Condition variable,其他 active 线程操作完这个 Condition variable,可以通过 signal/broadcast 去唤醒那些等待这个 Condition variable 睡眠的线程.
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Barrier</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Barrier 是一种能让一系列线程在某个点得到同步的方法,通过让参与 barrier 的线程等待直到所有参与线程都调用了这个 barrier 函数.本质上就是,阻塞所有参与 barrier 的线程直到最慢的那个参与线程调用 barrier.
</p>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Spinlock</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Spinlock 与 mutex 类似,是种锁,但当获取锁失败时,spinlock 不会让线程进入睡眠,而是不断 poll 去获取这个锁直到获取成功.更多<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/#mutex-vs-spinlock">Mutex 与 Spinlock 的区别</a>.
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Semaphore</h3>
<div class="outline-text-3" id="text-4-6">
<p>
当某些资源具有多个时,简单的 Mutex 不能满足,引入 Semphore,Semphore 可以根据资源个数初始化为任意值.当线程们占有所有资源,使得 Semphore 为 0,那么其他线程再获取资源只有等待.当 Semphore 值只能是 1 或 0 时,它相当于简单的 Mutex.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Pthread</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Overview</h3>
<div class="outline-text-3" id="text-5-1">
<p>
原始的 Pthread API 由 ANSI/IEEE POSIX 1003.1 - 1995 standard 定义.POSIX 标准也随着时间不断改进.
</p>

<p>
接下来主要把 Pthread API 分成如下主要 5 部分:
</p>
<ol class="org-ol">
<li>Thread Management
</li>
<li>Mutex Variables
</li>
<li>Condition Variables
</li>
<li>Synchronization
</li>
<li>Miscellaneous
</li>
</ol>

<p>
如果想把 Pthread 封装成类对象或 Scoped Lock,可以参考之后
<a href="#google-wrap">Google wrap the Pthread</a>,或直接使用之后介绍的<a href="#boost-thread">Boost thread library</a>.
</p>

<p>
如果更全面的 API 参考文章最后的<a href="#pthread-library">Pthread Library Routines Reference</a>.更多有关资料参考文章后的<i>其他资料</i>.
</p>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">编译 Pthread 程序</h4>
<div class="outline-text-4" id="text-5-1-1">
</div><div id="outline-container-sec-5-1-1-1" class="outline-5">
<h5 id="sec-5-1-1-1">include</h5>
<div class="outline-text-5" id="text-5-1-1-1">
<p>
对于 POSIX 系统,包含头文件 <code>pthread.h</code>. 如果使用 <code>semaphore</code>, 包含
<code>semaphore.h</code>.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;semaphore.h&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-1-2" class="outline-5">
<h5 id="sec-5-1-1-2">compile</h5>
<div class="outline-text-5" id="text-5-1-1-2">
<p>
对于 Gcc 编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">gcc Program.o -o Program -lpthread
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Thread Management</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Creating and Terminating Threads</h4>
<div class="outline-text-4" id="text-5-2-1">
</div><div id="outline-container-sec-5-2-1-1" class="outline-5">
<h5 id="sec-5-2-1-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_create</span>(<span style="color: #98fb98;">pthread_t</span> *<span style="color: #eedd82;">thread</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> *(*<span style="color: #eedd82;">start_routine</span>)(<span style="color: #98fb98;">void</span>*), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pthread_exit</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cancel</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_init</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_destroy</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-2" class="outline-5">
<h5 id="sec-5-2-1-2">Creating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-2">
<p>
<code>pthread_create</code> 创建一个新的线程并运行它.它能在代码的任何处被多次调用.
</p>

<p>
<code>pthread_create</code> 的参数:
</p>
<ul class="org-ul">
<li><code>thread</code>:返回新 thread 程的唯一标识.
</li>
<li><code>attr</code>:设置 thread 的性质.NULL 为默认性质.
</li>
<li><code>start_routine</code>: 新 thread 运行的函数指针.
</li>
<li><code>arg</code>:传给 <code>start_routine</code> 的参数,必须强制转换成 <code>void *</code>.NULL 为没有参数传入.
</li>
</ul>

<p>
Process 能创建的最大 thread 个数由系统配置决定.如下 Ubuntu 打印出的结果:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       8MB
coredumpsize    0kB
memoryuse       unlimited
maxproc         62694
descriptors     1024
memorylocked    64kB
addressspace    unlimited
maxfilelocks    unlimited
sigpending      62694
msgqueue        819200
nice            0
rt_priority     0
rt_time         unlimited
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-3" class="outline-5">
<h5 id="sec-5-2-1-3">Thread Attributes</h5>
<div class="outline-text-5" id="text-5-2-1-3">
<p>
<code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 被用来初始化/销毁 thread
性质对象.
</p>

<p>
性质包括:
</p>
<ul class="org-ul">
<li>Detached or joinable state
</li>
<li>Scheduling inheritance
</li>
<li>Scheduling policy
</li>
<li>Scheduling parameters
</li>
<li>Scheduling contention scope
</li>
<li>Stack size
</li>
<li>Stack address
</li>
<li>Stack guard (overflow) size
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-1-4" class="outline-5">
<h5 id="sec-5-2-1-4">Thread Binding</h5>
<div class="outline-text-5" id="text-5-2-1-4">
<p>
Pthread APIs 并没有提供 binding threads 到特定 cpus/cores 的接口.但不同系统可能包含这功能,比如提供非标准的<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt"><code>pthread_setaffinity_np</code> </a> 接口.
</p>

<p>
比如设置两个线程都在 core0 上运行,如下设置:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">cpu_set_t</span> <span style="color: #eedd82;">cpus</span>;
CPU_ZERO(&amp;cpus);
CPU_SET(0, &amp;cpus);
pthread_setaffinity_np(thread[0], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
pthread_setaffinity_np(thread[1], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-5" class="outline-5">
<h5 id="sec-5-2-1-5">Terminating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-5">
<p>
一个线程有很多种方法终止:
</p>
<ul class="org-ul">
<li>线程从它的运行中正常放回.它的工作完成.
</li>
<li>线程调用 <code>pthread_exit</code> 无论它的工作完成否.
</li>
<li>线程被另外一个线程调用 <code>pthread_cancel</code> 来取消.
</li>
<li>整个线程终止因为调用 <code>exec()</code> 或 <code>exit()</code>.
</li>
<li><code>main()</code> 函数先完成,没有调用 <code>pthread_exit</code>.
</li>
</ul>

<p>
<code>pthread_exit()</code> 允许指定一个可选的终止 <code>status parameter</code>.这个可选参数一般返回给线程&#8221;joining&#8221;到这个终止线程.
</p>

<p>
<code>pthread_exit()</code> 不关闭文件,在线程打开的任何文件将继续打开在线程终止后.
</p>

<p>
在 <code>main()</code> 调用 <code>pthread_exit()</code> :
</p>
<ul class="org-ul">
<li>如果 <code>main()</code> 在它创建的 threads 之前终止,并没有显示的调用
<code>pthread_exit()</code>,这将是个问题.所有创建的线程将终止因为 main()结束,不再存在支持这些线程.
</li>
<li>通过 main()在最后调用 <code>pthread_exit()</code>, main()将阻塞并保持存活来支持它创建的线程运行直到它们完成.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-1-6" class="outline-5">
<h5 id="sec-5-2-1-6">Example: Pthread Creation and Termination</h5>
<div class="outline-text-5" id="text-5-2-1-6">
<p>
如果注释掉 main()中最后的 <code>pthread_exit(NULL);</code> ,那么它创建的线程将会完成不了所有的打印而被强制退出.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], <span style="color: #7fffd4;">NULL</span>, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Joining and Detaching Threads</h4>
<div class="outline-text-4" id="text-5-2-2">
</div><div id="outline-container-sec-5-2-2-1" class="outline-5">
<h5 id="sec-5-2-2-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_join</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>, <span style="color: #98fb98;">void</span> **<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_detach</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setdetachstate</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">detachstate</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getdetachstate</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">detachstate</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-2-2" class="outline-5">
<h5 id="sec-5-2-2-2">Joining</h5>
<div class="outline-text-5" id="text-5-2-2-2">
<p>
Joining 是同步不同线程的方法之一,原理如下图:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/join.png" />

<ul class="org-ul">
<li><code>pthread_join()</code> 阻塞调用它的线程直到指定的 <code>threadid</code> 的线程终止.
</li>
<li>调用的线程能获取目标线程终止返回的 <code>status</code> 只要目标线程调用
  <code>pthread_exit()</code>.
</li>
<li>当一个线程被创建,它的属性之一是它是否可以 join.只有创建的能被 join 的线程才能被 join.如果线程线程以 detached 创建,它永远都不能被 join.
</li>
<li>显示的创建一个线程可 join 或 detached,使用在 <code>pthread_create()</code> 中的 <code>attr</code>
参数.典型的步骤是:
<ol class="org-ol">
<li>定义 <code>pthread_attr_t</code> 类型的 pthread 属性;
</li>
<li>用 <code>pthread_attr_init()</code> 初始化属性变量;
</li>
<li>用 <code>pthread_attr_setdetachstate()</code> 设置 detached 属性;
</li>
<li>用 <code>pthread_attr_destroy()</code> 释放属性使用的资源.
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-3" class="outline-5">
<h5 id="sec-5-2-2-3">Detaching</h5>
<div class="outline-text-5" id="text-5-2-2-3">
<ul class="org-ul">
<li><code>pthread_detach()</code> 能显示的 detach 一个线程即使它是以可 join 创建.
</li>
<li>没有相反的操作.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-4" class="outline-5">
<h5 id="sec-5-2-2-4">Example: Pthread Joining</h5>
<div class="outline-text-5" id="text-5-2-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(param);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_join(threads[i], &amp;status);
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_join failed, rt=%d\n"</span>, rt);
      exit(1);
    }
    printf(<span style="color: #ffa07a;">"completed join with thread %d having a status of %d\n"</span>
           , i, *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(status));
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3">Stack Management</h4>
<div class="outline-text-4" id="text-5-2-3">
</div><div id="outline-container-sec-5-2-3-1" class="outline-5">
<h5 id="sec-5-2-3-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-3-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstacksize</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">size_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstacksize</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstackaddr</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> **<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stackaddr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstackaddr</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">stackaddr</span>);
</pre>
</div>

<p>
每个线程都有各自独立的 stack, <code>pthread_attr_getstackaddr</code> 和
<code>pthread_attr_setstackaddr</code> 分别获取和设置线程的 stack 属性.
</p>
</div>
</div>

<div id="outline-container-sec-5-2-3-2" class="outline-5">
<h5 id="sec-5-2-3-2">Example: Stack Management</h5>
<div class="outline-text-5" id="text-5-2-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">thread_stack_size</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_attr_getstacksize(&amp;attr, &amp;thread_stack_size);
  printf(<span style="color: #ffa07a;">"thread %d: stack size = %d\n"</span>, id, thread_stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kThround</span> = 1000;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stack_size</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);
  printf(<span style="color: #ffa07a;">"Default stack size = %d\n"</span>, stack_size);
  stack_size = <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">double</span>) * kThround * kThround;
  printf(<span style="color: #ffa07a;">"Setting stack size = %d\n"</span>, stack_size);
  pthread_attr_setstacksize(&amp;attr, stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  pthread_attr_destroy(&amp;attr);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-4" class="outline-4">
<h4 id="sec-5-2-4">Miscellaneous</h4>
<div class="outline-text-4" id="text-5-2-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #87cefa;">pthread_self</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_equal</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t1</span>, <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t2</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_once</span>(<span style="color: #98fb98;">pthread_once_t</span> *<span style="color: #eedd82;">once_control</span>,
              <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">init_routine</span>)(<span style="color: #98fb98;">void</span>));
<span style="color: #98fb98;">pthread_once_t</span> <span style="color: #eedd82;">once_control</span> = PTHREAD_ONCE_INIT;
</pre>
</div>

<ul class="org-ul">
<li><code>pthread_self</code> 返回调用线程的唯一 thread ID.
</li>
<li><code>pthread_equal</code> 比较两个线程 ID 是否相等.
</li>
<li><code>pthread_once</code> 只执行 <code>init_routine</code> 仅仅一次在进程中.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">Overview</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Mutex 以&#8221;mutual exclusion&#8221;(互斥)简称.
</p>

<p>
Mutex variable 就像一把&#8221;锁&#8221;一样保护共享数据资源.mutex 的基本概念就是,只有一个线程能 lock 一个 mutex 变量在任何时候.所以,即使很多线程尝试去锁一个
mute,也仅仅只有一个线程能成功.
</p>

<p>
典型使用 mutex 的顺序如下:
</p>
<ol class="org-ol">
<li>创建和初始化 mutex 变量;
</li>
<li>许多线程尝试锁住 mutex;
</li>
<li>只有一个线程成功锁住 mutex,其他线程等待;
</li>
<li>拥有 mutex 的线程进行自己的操作;
</li>
<li>拥有线程解锁 mutex;
</li>
<li>其他线程继续获取 mutex 并持续如上步骤;
</li>
<li>最后 mutex 销毁.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">Creating and Destroying Mutexes</h4>
<div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_destroy</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_init</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">mutex</span>,
          <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_destroy</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_init</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Mutex 变量由 <code>pthread_mutex_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_mutex_init()</code> 函数,并能设置 mutex 的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置 mutex 变量的属性,必须是 <code>pthread_mutexattr_t</code> 类型.Pthread 标准中定义的 3 种可选 mutex 属性:
</p>

<ul class="org-ul">
<li>Protocol: Specifies the protocol used to prevent priority inversions
for a mutex.
</li>
<li>Prioceiling: Specifies the priority ceiling of a mutex.
</li>
<li>Process-shared: Specifies the process sharing of a mutex.(Pthread
mutex 能被 process 间使用).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3">Locking and Unlocking Mutexes</h4>
<div class="outline-text-4" id="text-5-3-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_lock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_trylock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_unlock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
</pre>
</div>

<p>
<code>pthread_mutex_lock()</code> 函数被用来获取传入的 mutex 变量,如果 mutex 已经被其他线程占用,那么这个调用就阻塞调用线程,使它进入睡眠等待这个 mutex 直到它被释放.
</p>

<p>
<code>pthread_mutex_trylock()</code> 仅尝试获取锁,若不成功也立即返回&#8217;busy&#8217;信号.
</p>
</div>
</div>
<div id="outline-container-sec-5-3-4" class="outline-4">
<h4 id="sec-5-3-4">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-5-3-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ThreadData</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tid</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shared_x</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">lock</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">ThreadData</span> *<span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">static_cast</span>&lt;ThreadData *&gt;(param);
  printf(<span style="color: #ffa07a;">"begin from thread id: %d\n"</span>, data-&gt;tid);
  pthread_mutex_lock(&amp;lock);
  shared_x += data-&gt;data;
  printf(<span style="color: #ffa07a;">"thread %d: x = %d\n"</span>, data-&gt;tid, shared_x);
  pthread_mutex_unlock(&amp;lock);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">ThreadData</span> <span style="color: #eedd82;">threads_data</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  shared_x = 0;
  pthread_mutex_init(&amp;lock, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    threads_data[i].tid = i;
    threads_data[i].data = i * i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;threads_data[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    pthread_join(threads[i], &amp;status);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Condition Variables</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Overview</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Mutex 变量如锁一般防止多个线程访问共享数据资源,如果某个线程等待某个共享数据达到某个数值才进行相应的操作,那么这个线程需要不断的去 poll,查看是否满足需要的值,这样开销很大,因为线程需要一直处于忙状态.
</p>

<p>
引入 Condition Variables 来完成这样的同步到某个实际数据值而不要不断 poll.
</p>

<p>
Condition 变量一般与 mutex 一起使用.锁住查看的共享数据资源.
</p>

<p>
使用 Condition 的一般步骤如下:
</p>
<ul class="org-ul">
<li>声明和定义需要同步的共享数据;
</li>
<li>声明和定义 condition 变量;
</li>
<li>声明和定义相对应的 mutex;
</li>
<li>创建线程使用 condition 变量同步.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Creating and Destroying Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_destroy</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_init</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">cond</span>,
                      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_destroy</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_init</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Condition 变量由 <code>pthread_cond_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">convar</span> = PTHREAD_COND_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_cond_init()</code> 函数,并能设置 condition 的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置 condition 变量的属性,必须是 <code>pthread_condattr_t</code> 类型.只有一种属性可选:是否进程共享,也就是允许其他进程中的线程也能看到它.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Waiting and Signaling on Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_wait</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,
                      <span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_signal</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_broadcast</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
</pre>
</div>

<p>
<code>pthread_cond_wait()</code> 阻塞调用它的线程直到其中 <code>cond</code> 被 signal.这个函数需要在占有 <i>mutex</i> 时被调用,而它将 <b>自动释放</b> mutex 当它等待时.等到
signal 收到,线程被唤醒, <i>mutex</i> 将 <b>自动被占有</b> .最后当线程完成
condition 的操作,要负责对 mutex 解锁.
</p>

<p>
<code>pthread_cond_signal()</code> 用来 signal 其他等待这个 <code>cond</code> 的线程.它需要在占有 <i>mutex</i> 时被调用.然后必须对 mutex 解锁来完成 <code>pthread_cond_wait</code>
的等待.
</p>

<p>
如果有多余一个线程处于等待 <code>cond</code> 而阻塞, 应该用
<code>pthread_cond_broadcast()</code> 替换 <code>pthread_cond_signal()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 3;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLoops</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kCountLimit</span> = 15;

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_count</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">count_cv</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">IncreaseCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kLoops; ++i) {
    pthread_mutex_lock(&amp;count_mutex);
    g_count++;
    <span style="color: #00ffff;">if</span> (g_count == kCountLimit) {
      pthread_cond_signal(&amp;count_cv);
      printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, signal cond\n"</span>, id, g_count);
    }
    printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, unlock mutex\n"</span>, id, g_count);
    pthread_mutex_unlock(&amp;count_mutex);
    sleep(1);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">WatchCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_mutex_lock(&amp;count_mutex);
  <span style="color: #00ffff;">while</span> (g_count &lt; kCountLimit) {
    pthread_cond_wait(&amp;count_cv, &amp;count_mutex);
    printf(<span style="color: #ffa07a;">"watch thread %d: count = %d, receive signal\n"</span>, id, g_count);
  }
  pthread_mutex_unlock(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_mutex_init(&amp;count_mutex, <span style="color: #7fffd4;">NULL</span>);
  pthread_cond_init(&amp;count_cv, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span>;
  rt = pthread_create(&amp;threads[0], &amp;attr, WatchCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[0]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[1], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[1]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[2], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[2]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    pthread_join(threads[i], <span style="color: #7fffd4;">NULL</span>);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_cond_destroy(&amp;count_cv);
  pthread_mutex_destroy(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Barrier</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Overview</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Barrier 就是栅栏一样,调用等待 barrier 的线程需要等待直到满足调用 barrier 的线程个数达到要求的 <code>count</code>.
</p>
</div>
</div>

<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">Creating, Destroying and Wait Barrier</h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_init</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>,
                <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_destroy</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_init</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_destroy</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_wait</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
</pre>
</div>

<p>
Barrier 变量由 <code>pthread_barrier_t</code> 声明定义,而且必须初始化在使用前.需要传入满足 barrier 等待的个数 <code>count</code>, 两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_barrier_init()</code> 函数,并能设置 barrier 的属性 <code>attr</code>.
</li>
</ol>

<p>
线程调用 barrier,只需要调用 <code>pthread_barrier_wait</code> 来等待 barrier 达到满足条件.
</p>

<p>
<a id="google-wrap" name="google-wrap"></a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Google wrap the Pthread</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Mutex 类和 CondVar 类</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Google api 的 base 包里封装了 Mutex 类和 CondVar 类.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">base</span> {
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">LinkerInitialized</span> { <span style="color: #eedd82;">LINKER_INITIALIZED</span> };
}

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LOCKABLE</span> <span style="color: #eedd82;">PThreadMutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #eedd82;">PThreadMutex</span>(<span style="color: #7fffd4;">base</span>::LinkerInitialized) {
    pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>);
  }
  <span style="color: #eedd82;">PThreadMutex</span>()   { pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #eedd82;">PThreadMutex</span>()  { pthread_mutex_destroy(&amp;mutex_); }

  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Lock</span>()     { CHECK_EQ(0, pthread_mutex_lock(&amp;mutex_)); }
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Unlock</span>()   { CHECK_EQ(0, pthread_mutex_unlock(&amp;mutex_)); }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #00ffff;">friend</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span>;
  <span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex_</span>;

  DISALLOW_COPY_AND_ASSIGN(PThreadMutex);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">PThreadCondVar</span>()  { pthread_cond_init(&amp;cv_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #87cefa;">PThreadCondVar</span>() { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_destroy</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Signal</span>()        { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_signal</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SignalAll</span>()     { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_broadcast</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Wait</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>) {
    CHECK_EQ(0, pthread_cond_wait(&amp;cv_, &amp;mu-&gt;mutex_));
  }
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">WaitWithTimeout</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>, <span style="color: #98fb98;">int64</span> <span style="color: #eedd82;">millis</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> <span style="color: #eedd82;">tv</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> <span style="color: #eedd82;">ts</span>;
    gettimeofday(&amp;tv, <span style="color: #7fffd4;">NULL</span>);
    ts.tv_sec = tv.tv_sec + millis / 1000;
    ts.tv_nsec = millis % 1000;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = pthread_cond_timedwait(&amp;cv_, &amp;mu-&gt;mutex_, &amp;ts);
    <span style="color: #00ffff;">if</span> (!result) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

    CHECK_EQ(ETIMEDOUT, result);
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">cv_</span>;
  DISALLOW_COPY_AND_ASSIGN(<span style="color: #98fb98;">PThreadCondVar</span>);
};

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadCondVar</span> <span style="color: #98fb98;">CondVar</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadMutex</span> <span style="color: #98fb98;">Mutex</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">GoogleOnceInit 类</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pthread_once_t</span> <span style="color: #98fb98;">GoogleOnceType</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">GOOGLE_ONCE_INIT</span> PTHREAD_ONCE_INIT

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GoogleOnceInit</span>(<span style="color: #98fb98;">GoogleOnceType</span>* <span style="color: #eedd82;">once</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">initializer</span>)()) {
  CHECK_EQ(0, pthread_once(once, initializer));
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Monitoring, Debugging and Performance Analysis Tools for Pthreads</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Monitoring</h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1">Linux <b>ps</b> command</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
使用 Linux 自带的 <code>ps</code> 命令查看运行的 thread 情况,<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?ps">ps 的 man 手册</a>.
</p>
<div class="org-src-container">

<pre class="src src-sh">&#10140;$ ps -Lf
UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
shougang 13103  8814 13103  0    1 23:30 pts/17   00:00:00 /bin/zsh
shougang 13237 13103 13237  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13240  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13241  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13242  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13243  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13244  0    6 23:30 pts/17   00:00:00 [thread]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2">Linux <b>top</b> command</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Linux 的 <code>top</code> 命令加上 <code>-H</code> 参数, process 中的 threads 也能看到.
如下是 <code>top -H</code> 的一个例子:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/top.png" />
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Debugging</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">GDB</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Threads.html#Threads">Debugging Programs with Multiple Threads</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Thread-Stops.html#Thread-Stops">GDB: Stopping and starting multi-thread programs</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/GDB_002fMI-Thread-Commands.html#GDB_002fMI-Thread-Commands">GDB/MI: Threads commands</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2">DDD</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li><a href="http://www.gnu.org/software/ddd/manual/html_mono/ddd.html#Threads">Examining Threads</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Performance Analysis Tools<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li><a href="http://www.openspeedshop.org/wp/">Open|SpeedShop</a>
</li>
<li><a href="http://www.cs.uoregon.edu/research/tau/home.php">TAU</a>
</li>
<li><a href="https://software.intel.com/en-us/intel-advisor-xe">Intel Advisor</a>
</li>
</ul>

<p>
<a id="boost-thread" name="boost-thread"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Boost thread library</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Overview</h3>
<div class="outline-text-3" id="text-8-1">
<p>
直到 C++11 库才比较好的支持 thread,之前 C++程序使用操作系统支持的 thread 库(如
Pthread).但这样做至少有个主要的问题:(1) 这些库基本是 C 的库,需要很小心的
C++中使用,和(2) 每个操作系统提供自己的一套对 thread 支持的库.以致,编写的代码既不标准又不可移植.
</p>

<p>
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread</a>可以解决这两个主要问题. Boost Thread 不是通过继承来使用线程,而是 Boost 的 thread 类使用一个 Callable 的对象创建.
</p>
</div>

<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1">编译 Boost Thread 程序</h4>
<div class="outline-text-4" id="text-8-1-1">
</div><div id="outline-container-sec-8-1-1-1" class="outline-5">
<h5 id="sec-8-1-1-1">include</h5>
<div class="outline-text-5" id="text-8-1-1-1">
<p>
根据使用到的 Boost Thread 中的类型包含不同头文件:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/locks.hpp&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-1-1-2" class="outline-5">
<h5 id="sec-8-1-1-2">compile</h5>
<div class="outline-text-5" id="text-8-1-1-2">
<p>
对于 Gcc 编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">g++ Program.o -o Program -lboost_thread -lboost_system
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Thread Management</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">Thread 类</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">  #include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread</span>
  {
  <span style="color: #00ffff;">public</span>:
      <span style="color: #87cefa;">thread</span>() noexcept;
      <span style="color: #87cefa;">thread</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;

      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      ~<span style="color: #87cefa;">thread</span>();

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A1</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A2</span>,...&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>,<span style="color: #98fb98;">A1</span> <span style="color: #eedd82;">a1</span>,<span style="color: #98fb98;">A2</span> <span style="color: #eedd82;">a2</span>,...);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);
      <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">id</span>;
      <span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;

      <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">joinable</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
      <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join</span>();
...
};
</pre>
</div>

<p>
整个 thread 类包含 thread 的所有特性,如 thread id, join, detach 等.
</p>
</div>
<div id="outline-container-sec-8-2-1-1" class="outline-5">
<h5 id="sec-8-2-1-1">Create Thread</h5>
<div class="outline-text-5" id="text-8-2-1-1">
<p>
Callable 对象既可以是一个函数又可以是类中的 <code>operator()</code> 实现,如下:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Hello</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
  }
};

<span style="color: #98fb98;">Hello</span> <span style="color: #eedd82;">h</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(h);
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(hello);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-1-2" class="outline-5">
<h5 id="sec-8-2-1-2">Passing data</h5>
<div class="outline-text-5" id="text-8-2-1-2">
<p>
传递参数给线程
</p>
<ol class="org-ol">
<li>thread 创建时附加后面
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(hello, str);
</pre>
</div>
<ol class="org-ol">
<li>利用 <code>Boost.bind</code> 库接口
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(bind(hello, str));
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">Thread group 类</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
可以使用 thread group 类管理 thread,通过 <code>add_thread</code> 和 <code>create_thread</code>
添加线程到管理类中, 可以直接 <code>join_all</code> 将所有管理类中的线程 join.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread_group</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">thread_group</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">thread_group</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">thread_group</span>();
    ~<span style="color: #87cefa;">thread_group</span>();

    <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #98fb98;">thread</span>* <span style="color: #87cefa;">create_thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">threadfunc</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_this_thread_in</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_thread_in</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join_all</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interrupt_all</span>();
    <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">size</span>() <span style="color: #00ffff;">const</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">Miscellaneous</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Boost Thread 中还有 <code>strict_scoped_thread</code> 类和 <code>scoped_thread</code> 类,提供线程结束不是调用 <code>terminate</code> ,而是调用传入的参数来执行特定行为.
</p>
</div>
</div>
<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4">Example: Thread Creation</h4>
<div class="outline-text-4" id="text-8-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/bind.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(){
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thrd</span>(bind(hello, str));
  thrd.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">mutex</span>:
    <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">noncopyable</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">mutex</span>();
    ~<span style="color: #87cefa;">mutex</span>();

    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">platform</span>-specific-type native_handle_type;
    <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #98fb98;">scoped_lock</span>;
    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unspecified</span>-type scoped_try_lock;
};
</pre>
</div>

<ul class="org-ul">
<li><code>lock()</code> 来获取锁.
</li>
<li><code>unlock()</code> 释放锁.
</li>
<li><code>typedef unique_lock&lt;mutex&gt; scoped_lock;</code> 定义了 <code>scoped_lock</code> 的类型,通过 <code>boost::mutex::scoped_lock</code> 来定义一个 RAII-style 锁,离开定义区域自动释放锁.
</li>
</ul>
</div>

<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><code>lock_guard</code></h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
<code>boost::lock_guard</code> 非常简单:
</p>
<ul class="org-ul">
<li>构造时,它获取锁.
</li>
<li>析构时,它释放锁.
</li>
</ul>

<p>
它提供了一个简单的 RAII-style 锁对象,使得 exception-safe 锁和解锁更容易.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">lock_guard</span>
<span style="color: #b0c4de;">#if</span> ! <span style="color: #b0c4de;">defined</span> BOOST_THREAD_NO_MAKE_LOCK_GUARD
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>, <span style="color: #98fb98;">adopt_lock_t</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
<span style="color: #b0c4de;">#endif</span>
}
</pre>
</div>

<p>
基本使用,传入可 <code>Lockable</code> 的 mutex 类型:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #87cefa;">lock</span>(count_mutex) ;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-8-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">count</span> {
  <span style="color: #87cefa;">count</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>) : id_(id) {
  }
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(count_mutex);
      cout &lt;&lt; id_ &lt;&lt; <span style="color: #ffa07a;">": "</span> &lt;&lt; i &lt;&lt; endl;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id_</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread1</span>(count(1));
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread2</span>(count(2));
  thread1.join();
  thread2.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Condition Variables</h3>
<div class="outline-text-3" id="text-8-4">
<p>
与 Pthread, Boost Condition Variable 功能更全面,如不同条件的
<code>wait_until</code> , <code>wait_for</code> 等功能.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
    <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable</span>
    {
    <span style="color: #00ffff;">public</span>:
        <span style="color: #87cefa;">condition_variable</span>();
        ~<span style="color: #87cefa;">condition_variable</span>();

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_one</span>() noexcept;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all</span>() noexcept;

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>);

        <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">predicate_type</span>&gt;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,<span style="color: #eedd82;">predicate_type</span> predicate);

        <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
        <span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">cv_status</span>::<span style="color: #98fb98;">type</span>
        <span style="color: #87cefa;">wait_until</span>(
            <span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
            <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">t</span>);
...
};
</pre>
</div>
</div>

<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
利用 Condition Variables 实现一个简单的 read/writer Buffer.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kBufSize</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kIters</span> = 100;

<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">io_mutex</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Buffer</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #98fb98;">scoped_lock</span>;
  <span style="color: #87cefa;">Buffer</span>() : p(0), c(0), full(0) {
  }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Put</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == kBufSize) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is full."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == kBufSize) {
        cond.wait(lock);
      }
    }
    buf[p] = m;
    p = (p + 1) % kBufSize;
    ++full;
    cond.notify_one();
  }

  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Get</span>() {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == 0) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is empty."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == 0) {
        cond.wait(lock);
      }
    }
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = buf[c];
    c = (c + 1) % kBufSize;
    --full;
    cond.notify_one();
    <span style="color: #00ffff;">return</span> i;
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">mutex</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">condition</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">full</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">buf</span>[kBufSize];
};

<span style="color: #98fb98;">Buffer</span> <span style="color: #eedd82;">buf</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writer</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"sending: "</span> &lt;&lt; i &lt;&lt; endl;
    }
    buf.Put(i);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reader</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = buf.Get();
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"received: "</span> &lt;&lt; n &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_reader</span>(&amp;<span style="color: #eedd82;">reader</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_writer</span>(&amp;<span style="color: #eedd82;">writer</span>);
  thread_reader.join();
  thread_writer.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Miscellaneous</h3>
<div class="outline-text-3" id="text-8-5">
</div><div id="outline-container-sec-8-5-1" class="outline-4">
<h4 id="sec-8-5-1">Barrier</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
基本使用:
</p>
<ol class="org-ol">
<li>定义 barrier,传入参与 thread 个数: <code>barrier b(num_threads)</code>.
</li>
<li>thread 中等待 barrier: <code>b.wait()</code>.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">barrier</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">barrier</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>);
    <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">F</span>&amp;&amp;);

    ~<span style="color: #87cefa;">barrier</span>();

    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">count_down_and_wait</span>();
};
</pre>
</div>


<p>
<a id="other-materials" name="other-materials"></a>
</p>
</div>
</div>

<div id="outline-container-sec-8-5-2" class="outline-4">
<h4 id="sec-8-5-2">Once Routines</h4>
<div class="outline-text-4" id="text-8-5-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>

<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">once_flag</span>;
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Function</span>, <span style="color: #00ffff;">class</span> ...ArgTypes&gt;
  <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>, <span style="color: #98fb98;">Function</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">ArgTypes</span>&amp;&amp;... args);

<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span> BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">func</span>)(),<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>);
<span style="color: #b0c4de;">#endif</span>

}
</pre>
</div>
</div>
<div id="outline-container-sec-8-5-2-1" class="outline-5">
<h5 id="sec-8-5-2-1">Example: Call once</h5>
<div class="outline-text-5" id="text-8-5-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">once_flag</span> <span style="color: #eedd82;">flag</span> = BOOST_ONCE_INIT;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">init</span>()
{
  ++i;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">thread</span>()
{
  <span style="color: #7fffd4;">boost</span>::call_once(&amp;init, flag);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd1</span>(&amp;<span style="color: #eedd82;">thread</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd2</span>(&amp;<span style="color: #eedd82;">thread</span>);
  thrd1.join();
  thrd2.join();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; i &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">其他资料</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Books:</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li><a href="http://shop.oreilly.com/product/9781565921153.do">PThreads Programming</a> and <a href="http://wiki.dreamrunner.org/public_html/Books%20Review/Pthreads%20Programming/Pthreads%20Programming.html">Its notes</a>
</li>
<li><a href="http://www.justsoftwaresolutions.co.uk/blog/">Anthony Williams’ blog</a> and his book, <a href="http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&amp;tag=preshonprogr-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988770">C++ Concurrency in Action</a>
</li>
<li>Herlihy &amp; Shavit&#8217;s <i>The Art of Multiprocessor Programming</i>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Online resources:</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li><i>Dmitriy V’jukov’s website</i> and various <a href="https://groups.google.com/forum/?fromgroups#!forum/lock-free">forum discussions</a>
</li>
<li><a href="http://bartoszmilewski.com/">Bartosz Milewski’s blog</a>
</li>
<li>Charles Bloom’s <a href="http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html">Threading Posts</a> on his blog
</li>
<li>Doug Lea&#8217;s <a href="http://g.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a>
</li>
<li><a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">memory-barriers.txt document</a>
</li>
<li>Hans Boehm’s <a href="http://www.hboehm.info/c++mm/">collection of links about the C++11 memory model</a>
</li>
<li>Scott Meyers&#8217;s <a href="http://scottmeyers.blogspot.hk/2012/04/information-on-c11-memory-model.html">Information on the C++11 Memory Model </a>
</li>
<li>Herb Sutter’s <a href="http://www.gotw.ca/publications/">Effective Concurrency series</a>
</li>
<li>POSIX Standard: <a href="http://www.unix.org/version3/ieee_std.html">http://www.unix.org/version3/ieee_std.html</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">有关 Mutex</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li><a href="http://home.roadrunner.com/~hinnant/mutexes/locking.html">Handling mutexes in C++</a>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">Mutex, Lock, Condition Variable Rationale</a>
</li>
</ul>

<p>
<a id="pthread-library" name="pthread-library"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Pthread Library Routines Reference</h2>
<div class="outline-text-2" id="text-10">
<p>
<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_atfork.txt">pthread_atfork</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_destroy.txt">pthread_attr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getdetachstate.txt">pthread_attr_getdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getguardsize.txt">pthread_attr_getguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getinheritsched.txt">pthread_attr_getinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedparam.txt">pthread_attr_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedpolicy.txt">pthread_attr_getschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getscope.txt">pthread_attr_getscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstack.txt">pthread_attr_getstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstackaddr.txt">pthread_attr_getstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstacksize.txt">pthread_attr_getstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_init.txt">pthread_attr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setdetachstate.txt">pthread_attr_setdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setguardsize.txt">pthread_attr_setguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setinheritsched.txt">pthread_attr_setinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedparam.txt">pthread_attr_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedpolicy.txt">pthread_attr_setschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setscope.txt">pthread_attr_setscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstack.txt">pthread_attr_setstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstackaddr.txt">pthread_attr_setstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstacksize.txt">pthread_attr_setstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_destroy.txt">pthread_barrier_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_init.txt">pthread_barrier_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_wait.txt">pthread_barrier_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_destroy.txt">pthread_barrierattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_getpshared.txt">pthread_barrierattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_init.txt">pthread_barrierattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_setpshared.txt">pthread_barrierattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cancel.txt">pthread_cancel</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_pop.txt">pthread_cleanup_pop</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_push.txt">pthread_cleanup_push</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_broadcast.txt">pthread_cond_broadcast</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt">pthread_cond_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt">pthread_cond_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_signal.txt">pthread_cond_signal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_timedwait.txt">pthread_cond_timedwait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_wait.txt">pthread_cond_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getclock.txt">pthread_condattr_getclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getpshared.txt">pthread_condattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt">pthread_condattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setclock.txt">pthread_condattr_setclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setpshared.txt">pthread_condattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt">pthread_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_detach.txt">pthread_detach</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_equal.txt">pthread_equal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_exit.txt">pthread_exit</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getconcurrency.txt">pthread_getconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getcpuclockid.txt">pthread_getcpuclockid</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getschedparam.txt">pthread_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getspecific.txt">pthread_getspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_join.txt">pthread_join</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_create.txt">pthread_key_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_delete.txt">pthread_key_delete</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_kill.txt">pthread_kill</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_destroy.txt">pthread_mutex_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_getprioceiling.txt">pthread_mutex_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_init.txt">pthread_mutex_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_lock.txt">pthread_mutex_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_setprioceiling.txt">pthread_mutex_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_timedlock.txt">pthread_mutex_timedlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_trylock.txt">pthread_mutex_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt">pthread_mutex_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_destroy.txt">pthread_mutexattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprioceiling.txt">pthread_mutexattr_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprotocol.txt">pthread_mutexattr_getprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getpshared.txt">pthread_mutexattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_gettype.txt">pthread_mutexattr_gettype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt">pthread_mutexattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprioceiling.txt">pthread_mutexattr_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprotocol.txt">pthread_mutexattr_setprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setpshared.txt">pthread_mutexattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_settype.txt">pthread_mutexattr_settype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_once.txt">pthread_once</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_destroy.txt">pthread_rwlock_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_init.txt">pthread_rwlock_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_rdlock.txt">pthread_rwlock_rdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedrdlock.txt">pthread_rwlock_timedrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedwrlock.txt">pthread_rwlock_timedwrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_tryrdlock.txt">pthread_rwlock_tryrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_trywrlock.txt">pthread_rwlock_trywrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_unlock.txt">pthread_rwlock_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_wrlock.txt">pthread_rwlock_wrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_destroy.txt">pthread_rwlockattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_getpshared.txt">pthread_rwlockattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_init.txt">pthread_rwlockattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_setpshared.txt">pthread_rwlockattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_self.txt">pthread_self</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcancelstate.txt">pthread_setcancelstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcanceltype.txt">pthread_setcanceltype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setconcurrency.txt">pthread_setconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedparam.txt">pthread_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedprio.txt">pthread_setschedprio</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setspecific.txt">pthread_setspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_sigmask.txt">pthread_sigmask</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_destroy.txt">pthread_spin_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_init.txt">pthread_spin_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_lock.txt">pthread_spin_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_trylock.txt">pthread_spin_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_unlock.txt">pthread_spin_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_testcancel.txt">pthread_testcancel</a>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html">http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools">https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools</a>
</p></div>


</div>
</div>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">DreamRunner</span></span>

      











<time datetime="2014-08-07T00:00:00+08:00"  class="updated" >Aug 7<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/c-plus-plus/'>C++</a>, <a class='category' href='/blog/categories/multithreading/'>Multithreading</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/" data-via="" data-counturl="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
  
	<!-- JiaThis Button BEGIN -->
<div id="ckepop">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_qzone">QQ空间</a>
	<a class="jiathis_button_tsina">新浪微博</a>
	<a class="jiathis_button_tqq">腾讯微博</a>
	<a class="jiathis_button_renren">人人网</a>
	<a href="http://www.jiathis.com/share?uid=1658718" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">var jiathis_config = {data_track_clickback:true};</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1342523038679945" charset="utf-8"></script>
<!-- JiaThis Button END -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/07/09/ru-he-shi-xian-pythonde-withyu-ju/" title="Previous Post: 如何实现Python的with语句">&laquo; 如何实现Python的with语句</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/08/25/C11-multithreading-programming/" title="Next Post: 浅谈C++11 multithreading programming">浅谈C++11 multithreading programming &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/15/make-colorful-equations-with-mathjax/">Make Colorful Equations With Mathjax</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/25/C11-multithreading-programming/">浅谈C++11 Multithreading Programming</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/07/C-multithreading-programming/">浅谈C++ Multithreading Programming</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/09/ru-he-shi-xian-pythonde-withyu-ju/">如何实现Python的with语句</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie/">Multithreading相关术语总结</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Category Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/algorithm' style='font-size: 113.84615384615384%'>Algorithm(6)</a> <a href='/blog/categories/c-' style='font-size: 113.84615384615384%'>C++(6)</a> <a href='/blog/categories/design-pattern' style='font-size: 160.0%'>Design Pattern(26)</a> <a href='/blog/categories/dsp' style='font-size: 102.3076923076923%'>DSP(1)</a> <a href='/blog/categories/fpga' style='font-size: 102.3076923076923%'>FPGA(1)</a> <a href='/blog/categories/misc' style='font-size: 102.3076923076923%'>Misc(1)</a> <a href='/blog/categories/multithreading' style='font-size: 113.84615384615384%'>Multithreading(6)</a> <a href='/blog/categories/programming-pearls' style='font-size: 116.15384615384616%'>Programming Pearls(7)</a> <a href='/blog/categories/software' style='font-size: 106.92307692307692%'>Software(3)</a> <a href='/blog/categories/web' style='font-size: 106.92307692307692%'>Web(3)</a> </span>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/shishougang">@shishougang</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'shishougang',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/103923268925965955200?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - DreamRunner -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'dreamrunner';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/';
        var disqus_url = 'http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
