<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Multithreading | (learn&think)]]></title>
  <link href="http://dreamrunner.org/blog/categories/multithreading/atom.xml" rel="self"/>
  <link href="http://dreamrunner.org/"/>
  <updated>2014-08-07T20:42:01+08:00</updated>
  <id>http://dreamrunner.org/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈C++ Multithreading Programming]]></title>
    <link href="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
随着多核 CPU 随处可见,多线程(multithreading)可以被用来实现并行,提高 CPU 的利用率和性能显著的提高.掌握多线程编程也成为现代实现软件的基本要求技能之一.<a href="https://computing.llnl.gov/tutorials/parallel_comp/">Introduction to Parallel Computing</a>详细的介绍了 Parallel Computing;
为什么使用它;Parallel Computing 的分类;Parallel Computing 的 limits 和
costs; Parallel Computing 的程序模型;如何设计 Parallel 程序等.
</p>

<p>
这里先介绍多线程的概念,多线程中涉及的基本概念,然后用实例介绍 Pthread 库的使用,并介绍 Google Code 中如何把它封装成 C++类,最后介绍可移植并大量使用的
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread 库</a>.
</p>

<p>
还有一些其他的 Thread 库:
</p>
<ul class="org-ul">
<li><a href="http://openmp.org/wp/">OpenMP</a> 是一个可移植的接口,在共享内存的多处理器上实现 fork-join 并行.
OpenMP 的 tutorial:<a href="https://computing.llnl.gov/tutorials/openMP/">这里</a> 和 <a href="http://vergil.chemistry.gatech.edu/resources/programming/OpenMP.pdf">这里</a>,
</li>
<li><a href="http://omniorb.sourceforge.net/omni42/omnithread.html">OMNI Thread</a>为 C++提供 Thread 操作的.
</li>
<li><a href="http://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries">其他 multithreading libraries</a>.
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Thread</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">定义</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A <b>thread</b> is defined as an independent stream of instructions that can
be scheduled to run as such by the operating system.所以它是在程序中独立于其他代码可由操作系统调度的一段指令.
</p>

<p>
那么是操作系统是如何具体实现这一独立性呢?
</p>

<p>
要理解 thread,必须先明白 process.进程由操作系统创建来运行相应的程序,进程包含程序资源和程序执行状态的信息.以 Linux 的进程为例包含:
</p>
<ul class="org-ul">
<li>Process ID, process group ID, user ID, and group ID
</li>
<li>Environment
</li>
<li>Working directory
</li>
<li>Program instructions
</li>
<li>Registers
</li>
<li>Stack
</li>
<li>Heap
</li>
<li>File descriptors
</li>
<li>Signal actions
</li>
<li>Shared libraries
</li>
<li>Inter-process communication tools (such as message queues, pipes,
semaphores, or shared memory).
</li>
</ul>

<img class="center" src="/images/blog/2014/c++_multithreaing/process_thread.png">

<p>
Thread 使用 Process 的资源,并且能成为独立的元件被操作系统调度,是因为它仅重复那些使得它们能成为独立运行代码的必要资源.Thread 维护它自己如下的信息:
</p>
<ul class="org-ul">
<li>Stack pointer
</li>
<li>Registers
</li>
<li>Scheduling properties (such as policy or priority)
</li>
<li>Set of pending and blocked signals
</li>
<li>Thread specific data.
</li>
</ul>

<p>
与 Process 比较,Thread 可以总结如下:
</p>
<ul class="org-ul">
<li>Thread 相当于一个 lightweight 的 Process,拥有如 ID,properties 等相似信息,
但仅仅包含能使得它独立运行的信息即可.
</li>
<li>信息包含的不同,与需要复制大量信息来创建 Process 比,Thread 的创建比较快捷.
</li>
<li>独立的 Processes 不共享任何信息.每个 Process 运行在独立的地址空间.Threads 共享所在 Process 的资源,全局变量和文件描述符.
</li>
<li>Threads 可以直接与所在同一 Process 的 Threads 通信.而 Processes 必须使用
inter-process communication(IPC)来通信.
</li>
<li>因为 Threads 的资源共享性,增加并行操作资源的难度,需要引入 Thread 同步机制来达到资源并行性.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">一些术语</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Posix Thread 基本模型如下图,一些有关其中 Thread 的术语:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/threads_model.png">

<ul class="org-ul">
<li><b>Lightweight Process(LWP)</b> 可以被认为虚拟的 CPU,在系统中通常 LWP 的个数大于实际 CPU 个数.Thread 库通过与 LWP 沟通来调度 thread.LWP 也通常被称为
kernel threads.
</li>
<li><b><a href="http://en.wikipedia.org/wiki/System_Contention_Scope">Contention Scope</a></b> 是如何决定哪个线程得到调度.
</li>
<li><b>Bound threads</b> 拥有系统级别的 Contention Scope,也就是,它们与其他进程一同竞争.
</li>
<li><b>Unbound threads</b> 拥有进程级别的 Contention Scope.
</li>
<li><b>Thread-safe</b> 意味共享数据被得到保护,可以同时被多个 thread 调用而安全.
</li>
<li><b>Reentrant code</b> 意味程序可以被多个 thread 并行运行.
</li>
<li><b><a href="https://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions">asynchronous-safe function</a></b> 在 signal handler 下被安全调用并没有任何副作用.
</li>
<li><b>Concurrency vs. Parallelism</b> 并不一样.Parallelism 意味同时运行代码.而
Concurrency 意味许多任务可以以任何顺序执行或可以是并行运行.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Amdahl 法则和 Pareto 原则</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Threads 能提供益处 <i>对于相适</i> 的应用.所以 thread 的并行性对于应用来说也有它的限制.
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Amdahl 法则</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
<a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl 法则</a> 陈述到潜在的程序加速由能被并行的代码率 P 定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{1-P}
\end{align}
$$

<ul class="org-ul">
<li>如果代码中没有能并行的部分,P=0,那么 speedup=1.
</li>
<li>如果所有代码都能并行,P=1,那么 speedup 能达到无限(理论上).
</li>
<li>如果 50%的代码能并行,那么最大的 speedup=2,也就是最多 2 倍的加速.
</li>
</ul>

<p>
引入能并行的处理器个数,那么进一步可以定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{\dfrac{P}{N} + (1-P)}
其中 P 并行率,N 处理器个数
\end{align}
$$

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl1.gif">

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl2.gif">
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Pareto 原则</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
<a href="http://en.wikipedia.org/wiki/Pareto_principle">Pareto 原则</a> 陈述到 80%的处理器时间花在 20%的代码中.所以仔细分析代码,不要把时间花在并行/优化那部分不重要的代码.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Thread 设计模式<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-3">
<p>
在程序中有不同的方法使用线程,这里讨论 3 种线程设计模式,没有哪一种模式最好,每种模式都有相应适合的应用场合.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Boss/worker(Thread pool)</h3>
<div class="outline-text-3" id="text-3-1">
<img class="center" src="/images/blog/2014/c++_multithreaing/boss_workers_pattern.gif">

<p>
如上图,一个 Boss 线程创建其他 Worker 线程,并给它们分配任务,必要的话,并等待其他线程运行结束.通常 Boss 线程会在初始建立 Thread Pool 来为之后分配.尽管线程是轻量级的,但是创建它们仍是有开销的.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Peer(Workcrew)</h3>
<div class="outline-text-3" id="text-3-2">
<img class="center" src="/images/blog/2014/c++_multithreaing/peer_pattern.gif">

<p>
Peer 模式又叫做 workcrew 模式,一个 thread 创建其他 peer threads 当程序开始,但是如上图,与 Boss/worker 模式不同,这个 thread 之后也变成 peer thread 去处理自己的任务.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Pipeline</h3>
<div class="outline-text-3" id="text-3-3">
<img class="center" src="/images/blog/2014/c++_multithreaing/pipeline_pattern.gif">

<p>
Pipeline 模式假定:
</p>
<ul class="org-ul">
<li>一串连续长输入.
</li>
<li>每个输入经过一连串的子操作(熟知为 stages 或 fliers).
</li>
<li>每个处理 stage 能一次处理个不同的输入.
</li>
</ul>

<p>
如上图, Pipeline 就像流水线一般,每个 thread 是一个长链中的一部分.每个
thread 处理由之前 thread 过的数据.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">线程同步原语</h2>
<div class="outline-text-2" id="text-4">
<p>
如上线程中的定义,线程们共享进程中的全局变量或资源,它们可以并行同时对这些数据和资源操作,如果没有一定的机制协调它们,那么数据或资源将处于一个不安全状态,引起诸如如下的一些问题:
</p>

<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Race_condition#Software">Race condition</a>发生于不能决定行为的结果因为线程们操作共享数据或资源没有遵循一定的同步规则.
</li>
<li><a href="http://en.wikipedia.org/wiki/ABA_problem">ABA problem</a>发生于一个地方被读取两次,都读到相同的值,'值是相同的'被用来说明'没有东西被改变'.但是,另外一个线程能在这两次读取中间执行操作并修改这个位置的值,然后做一些其他操作,最后把这个值改回去,以致愚弄第一个线程让它认为'没有东西被改变',即使第二个线程的操作已经破坏了这个假设.
</li>
</ul>

<p>
所以我们需要如下的一些线程同步原语满足不同的线程间同步需求.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Mutex</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29">Mutex</a> 又被称为 Lock,所以它就像一把 Lock,一个线程 Lock 住一段资源,那么其他线程就不能去访问那段资源,只有等到第一个线程 Unlock 那么资源,它才能访问.
</p>

<p>
在 Lock 和 Unlock 之间的代码,一般被称为 <b>critical section</b>.
</p>

<p>
Mutex 也包含一些复杂的类型,如下:
</p>
<ul class="org-ul">
<li>Recursive: 允许占有锁的那一个线程再次获取同样的锁,对递归算法是必要的.
</li>
<li>Queuing: 使得 <b>公平</b> 的获取锁,通过 FIFO 排序锁的请求.
</li>
<li>Reader/Writer(rwlock): 允许多个 reader 同时获取锁,如果有 reader 占用锁,writer 只有等到 reader 释放锁.
</li>
<li>Scoped: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> 类型定义的锁获取和解锁.
</li>
</ul>

<p>
但 Mutex 也会引入其他一些问题,如<a href="http://en.wikipedia.org/wiki/Deadlock">deadlock</a> 和 <a href="http://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>.
</p>

<p>
在 Blog 中之前<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/">浅谈 Mutex (Lock)</a>中可以看到更多有关 Mutex 的性能和开销分析,并如何实现一个轻量级的 Mutex.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Join</h3>
<div class="outline-text-3" id="text-4-2">
<p>
线程 join 机制能让一个线程 join 到另外一个线程中.比如一个子线程 join 回主线程,那么主线程就会等待子线程运行结束.从而达到线程间等待的同步机制.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Condition Variable</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Condition variable 允许线程同步到某个共享资源的某个值.
</p>

<p>
比如,程序有一个计数器,当计数器达到某一个值时去激活某个线程运行.把计数器当成一个 Condition variable.这个线程可以等待这个 Condition variable,其他 active 线程操作完这个 Condition variable,可以通过 signal/broadcast 去唤醒那些等待这个 Condition variable 睡眠的线程.
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Barrier</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Barrier 是一种能让一系列线程在某个点得到同步的方法,通过让参与 barrier 的线程等待直到所有参与线程都调用了这个 barrier 函数.本质上就是,阻塞所有参与 barrier 的线程直到最慢的那个参与线程调用 barrier.
</p>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Spinlock</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Spinlock 与 mutex 类似,是种锁,但当获取锁失败时,spinlock 不会让线程进入睡眠,而是不断 poll 去获取这个锁直到获取成功.更多<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/#mutex-vs-spinlock">Mutex 与 Spinlock 的区别</a>.
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Semaphore</h3>
<div class="outline-text-3" id="text-4-6">
<p>
当某些资源具有多个时,简单的 Mutex 不能满足,引入 Semphore,Semphore 可以根据资源个数初始化为任意值.当线程们占有所有资源,使得 Semphore 为 0,那么其他线程再获取资源只有等待.当 Semphore 值只能是 1 或 0 时,它相当于简单的 Mutex.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Pthread</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Overview</h3>
<div class="outline-text-3" id="text-5-1">
<p>
原始的 Pthread API 由 ANSI/IEEE POSIX 1003.1 - 1995 standard 定义.POSIX 标准也随着时间不断改进.
</p>

<p>
接下来主要把 Pthread API 分成如下主要 5 部分:
</p>
<ol class="org-ol">
<li>Thread Management
</li>
<li>Mutex Variables
</li>
<li>Condition Variables
</li>
<li>Synchronization
</li>
<li>Miscellaneous
</li>
</ol>

<p>
如果想把 Pthread 封装成类对象或 Scoped Lock,可以参考之后
<a href="#google-wrap">Google wrap the Pthread</a>,或直接使用之后介绍的<a href="#boost-thread">Boost thread library</a>.
</p>

<p>
如果更全面的 API 参考文章最后的<a href="#pthread-library">Pthread Library Routines Reference</a>.更多有关资料参考文章后的<i>其他资料</i>.
</p>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">编译 Pthread 程序</h4>
<div class="outline-text-4" id="text-5-1-1">
</div><div id="outline-container-sec-5-1-1-1" class="outline-5">
<h5 id="sec-5-1-1-1">include</h5>
<div class="outline-text-5" id="text-5-1-1-1">
<p>
对于 POSIX 系统,包含头文件 <code>pthread.h</code>. 如果使用 <code>semaphore</code>, 包含
<code>semaphore.h</code>.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;semaphore.h&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-1-2" class="outline-5">
<h5 id="sec-5-1-1-2">compile</h5>
<div class="outline-text-5" id="text-5-1-1-2">
<p>
对于 Gcc 编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">gcc Program.o -o Program -lpthread
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Thread Management</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Creating and Terminating Threads</h4>
<div class="outline-text-4" id="text-5-2-1">
</div><div id="outline-container-sec-5-2-1-1" class="outline-5">
<h5 id="sec-5-2-1-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_create</span>(<span style="color: #98fb98;">pthread_t</span> *<span style="color: #eedd82;">thread</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> *(*<span style="color: #eedd82;">start_routine</span>)(<span style="color: #98fb98;">void</span>*), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pthread_exit</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cancel</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_init</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_destroy</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-2" class="outline-5">
<h5 id="sec-5-2-1-2">Creating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-2">
<p>
<code>pthread_create</code> 创建一个新的线程并运行它.它能在代码的任何处被多次调用.
</p>

<p>
<code>pthread_create</code> 的参数:
</p>
<ul class="org-ul">
<li><code>thread</code>:返回新 thread 程的唯一标识.
</li>
<li><code>attr</code>:设置 thread 的性质.NULL 为默认性质.
</li>
<li><code>start_routine</code>: 新 thread 运行的函数指针.
</li>
<li><code>arg</code>:传给 <code>start_routine</code> 的参数,必须强制转换成 <code>void *</code>.NULL 为没有参数传入.
</li>
</ul>

<p>
Process 能创建的最大 thread 个数由系统配置决定.如下 Ubuntu 打印出的结果:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       8MB
coredumpsize    0kB
memoryuse       unlimited
maxproc         62694
descriptors     1024
memorylocked    64kB
addressspace    unlimited
maxfilelocks    unlimited
sigpending      62694
msgqueue        819200
nice            0
rt_priority     0
rt_time         unlimited
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-3" class="outline-5">
<h5 id="sec-5-2-1-3">Thread Attributes</h5>
<div class="outline-text-5" id="text-5-2-1-3">
<p>
<code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 被用来初始化/销毁 thread
性质对象.
</p>

<p>
性质包括:
</p>
<ul class="org-ul">
<li>Detached or joinable state
</li>
<li>Scheduling inheritance
</li>
<li>Scheduling policy
</li>
<li>Scheduling parameters
</li>
<li>Scheduling contention scope
</li>
<li>Stack size
</li>
<li>Stack address
</li>
<li>Stack guard (overflow) size
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-1-4" class="outline-5">
<h5 id="sec-5-2-1-4">Thread Binding</h5>
<div class="outline-text-5" id="text-5-2-1-4">
<p>
Pthread APIs 并没有提供 binding threads 到特定 cpus/cores 的接口.但不同系统可能包含这功能,比如提供非标准的<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt"><code>pthread_setaffinity_np</code> </a> 接口.
</p>

<p>
比如设置两个线程都在 core0 上运行,如下设置:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">cpu_set_t</span> <span style="color: #eedd82;">cpus</span>;
CPU_ZERO(&amp;cpus);
CPU_SET(0, &amp;cpus);
pthread_setaffinity_np(thread[0], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
pthread_setaffinity_np(thread[1], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-5" class="outline-5">
<h5 id="sec-5-2-1-5">Terminating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-5">
<p>
一个线程有很多种方法终止:
</p>
<ul class="org-ul">
<li>线程从它的运行中正常放回.它的工作完成.
</li>
<li>线程调用 <code>pthread_exit</code> 无论它的工作完成否.
</li>
<li>线程被另外一个线程调用 <code>pthread_cancel</code> 来取消.
</li>
<li>整个线程终止因为调用 <code>exec()</code> 或 <code>exit()</code>.
</li>
<li><code>main()</code> 函数先完成,没有调用 <code>pthread_exit</code>.
</li>
</ul>

<p>
<code>pthread_exit()</code> 允许指定一个可选的终止 <code>status parameter</code>.这个可选参数一般返回给线程"joining"到这个终止线程.
</p>

<p>
<code>pthread_exit()</code> 不关闭文件,在线程打开的任何文件将继续打开在线程终止后.
</p>

<p>
在 <code>main()</code> 调用 <code>pthread_exit()</code> :
</p>
<ul class="org-ul">
<li>如果 <code>main()</code> 在它创建的 threads 之前终止,并没有显示的调用
<code>pthread_exit()</code>,这将是个问题.所有创建的线程将终止因为 main()结束,不再存在支持这些线程.
</li>
<li>通过 main()在最后调用 <code>pthread_exit()</code>, main()将阻塞并保持存活来支持它创建的线程运行直到它们完成.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-1-6" class="outline-5">
<h5 id="sec-5-2-1-6">Example: Pthread Creation and Termination</h5>
<div class="outline-text-5" id="text-5-2-1-6">
<p>
如果注释掉 main()中最后的 <code>pthread_exit(NULL);</code> ,那么它创建的线程将会完成不了所有的打印而被强制退出.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], <span style="color: #7fffd4;">NULL</span>, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Joining and Detaching Threads</h4>
<div class="outline-text-4" id="text-5-2-2">
</div><div id="outline-container-sec-5-2-2-1" class="outline-5">
<h5 id="sec-5-2-2-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_join</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>, <span style="color: #98fb98;">void</span> **<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_detach</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setdetachstate</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">detachstate</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getdetachstate</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">detachstate</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-2-2" class="outline-5">
<h5 id="sec-5-2-2-2">Joining</h5>
<div class="outline-text-5" id="text-5-2-2-2">
<p>
Joining 是同步不同线程的方法之一,原理如下图:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/join.png">

<ul class="org-ul">
<li><code>pthread_join()</code> 阻塞调用它的线程直到指定的 <code>threadid</code> 的线程终止.
</li>
<li>调用的线程能获取目标线程终止返回的 <code>status</code> 只要目标线程调用
  <code>pthread_exit()</code>.
</li>
<li>当一个线程被创建,它的属性之一是它是否可以 join.只有创建的能被 join 的线程才能被 join.如果线程线程以 detached 创建,它永远都不能被 join.
</li>
<li>显示的创建一个线程可 join 或 detached,使用在 <code>pthread_create()</code> 中的 <code>attr</code>
参数.典型的步骤是:
<ol class="org-ol">
<li>定义 <code>pthread_attr_t</code> 类型的 pthread 属性;
</li>
<li>用 <code>pthread_attr_init()</code> 初始化属性变量;
</li>
<li>用 <code>pthread_attr_setdetachstate()</code> 设置 detached 属性;
</li>
<li>用 <code>pthread_attr_destroy()</code> 释放属性使用的资源.
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-3" class="outline-5">
<h5 id="sec-5-2-2-3">Detaching</h5>
<div class="outline-text-5" id="text-5-2-2-3">
<ul class="org-ul">
<li><code>pthread_detach()</code> 能显示的 detach 一个线程即使它是以可 join 创建.
</li>
<li>没有相反的操作.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-4" class="outline-5">
<h5 id="sec-5-2-2-4">Example: Pthread Joining</h5>
<div class="outline-text-5" id="text-5-2-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(param);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_join(threads[i], &amp;status);
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_join failed, rt=%d\n"</span>, rt);
      exit(1);
    }
    printf(<span style="color: #ffa07a;">"completed join with thread %d having a status of %d\n"</span>
           , i, *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(status));
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3">Stack Management</h4>
<div class="outline-text-4" id="text-5-2-3">
</div><div id="outline-container-sec-5-2-3-1" class="outline-5">
<h5 id="sec-5-2-3-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-3-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstacksize</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">size_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstacksize</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstackaddr</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> **<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stackaddr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstackaddr</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">stackaddr</span>);
</pre>
</div>

<p>
每个线程都有各自独立的 stack, <code>pthread_attr_getstackaddr</code> 和
<code>pthread_attr_setstackaddr</code> 分别获取和设置线程的 stack 属性.
</p>
</div>
</div>

<div id="outline-container-sec-5-2-3-2" class="outline-5">
<h5 id="sec-5-2-3-2">Example: Stack Management</h5>
<div class="outline-text-5" id="text-5-2-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">thread_stack_size</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_attr_getstacksize(&amp;attr, &amp;thread_stack_size);
  printf(<span style="color: #ffa07a;">"thread %d: stack size = %d\n"</span>, id, thread_stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kThround</span> = 1000;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stack_size</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);
  printf(<span style="color: #ffa07a;">"Default stack size = %d\n"</span>, stack_size);
  stack_size = <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">double</span>) * kThround * kThround;
  printf(<span style="color: #ffa07a;">"Setting stack size = %d\n"</span>, stack_size);
  pthread_attr_setstacksize(&amp;attr, stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  pthread_attr_destroy(&amp;attr);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-4" class="outline-4">
<h4 id="sec-5-2-4">Miscellaneous</h4>
<div class="outline-text-4" id="text-5-2-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #87cefa;">pthread_self</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_equal</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t1</span>, <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t2</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_once</span>(<span style="color: #98fb98;">pthread_once_t</span> *<span style="color: #eedd82;">once_control</span>,
              <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">init_routine</span>)(<span style="color: #98fb98;">void</span>));
<span style="color: #98fb98;">pthread_once_t</span> <span style="color: #eedd82;">once_control</span> = PTHREAD_ONCE_INIT;
</pre>
</div>

<ul class="org-ul">
<li><code>pthread_self</code> 返回调用线程的唯一 thread ID.
</li>
<li><code>pthread_equal</code> 比较两个线程 ID 是否相等.
</li>
<li><code>pthread_once</code> 只执行 <code>init_routine</code> 仅仅一次在进程中.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">Overview</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Mutex 以"mutual exclusion"(互斥)简称.
</p>

<p>
Mutex variable 就像一把"锁"一样保护共享数据资源.mutex 的基本概念就是,只有一个线程能 lock 一个 mutex 变量在任何时候.所以,即使很多线程尝试去锁一个
mute,也仅仅只有一个线程能成功.
</p>

<p>
典型使用 mutex 的顺序如下:
</p>
<ol class="org-ol">
<li>创建和初始化 mutex 变量;
</li>
<li>许多线程尝试锁住 mutex;
</li>
<li>只有一个线程成功锁住 mutex,其他线程等待;
</li>
<li>拥有 mutex 的线程进行自己的操作;
</li>
<li>拥有线程解锁 mutex;
</li>
<li>其他线程继续获取 mutex 并持续如上步骤;
</li>
<li>最后 mutex 销毁.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">Creating and Destroying Mutexes</h4>
<div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_destroy</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_init</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">mutex</span>,
          <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_destroy</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_init</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Mutex 变量由 <code>pthread_mutex_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_mutex_init()</code> 函数,并能设置 mutex 的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置 mutex 变量的属性,必须是 <code>pthread_mutexattr_t</code> 类型.Pthread 标准中定义的 3 种可选 mutex 属性:
</p>

<ul class="org-ul">
<li>Protocol: Specifies the protocol used to prevent priority inversions
for a mutex.
</li>
<li>Prioceiling: Specifies the priority ceiling of a mutex.
</li>
<li>Process-shared: Specifies the process sharing of a mutex.(Pthread
mutex 能被 process 间使用).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3">Locking and Unlocking Mutexes</h4>
<div class="outline-text-4" id="text-5-3-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_lock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_trylock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_unlock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
</pre>
</div>

<p>
<code>pthread_mutex_lock()</code> 函数被用来获取传入的 mutex 变量,如果 mutex 已经被其他线程占用,那么这个调用就阻塞调用线程,使它进入睡眠等待这个 mutex 直到它被释放.
</p>

<p>
<code>pthread_mutex_trylock()</code> 仅尝试获取锁,若不成功也立即返回'busy'信号.
</p>
</div>
</div>
<div id="outline-container-sec-5-3-4" class="outline-4">
<h4 id="sec-5-3-4">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-5-3-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ThreadData</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tid</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shared_x</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">lock</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">ThreadData</span> *<span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">static_cast</span>&lt;ThreadData *&gt;(param);
  printf(<span style="color: #ffa07a;">"begin from thread id: %d\n"</span>, data-&gt;tid);
  pthread_mutex_lock(&amp;lock);
  shared_x += data-&gt;data;
  printf(<span style="color: #ffa07a;">"thread %d: x = %d\n"</span>, data-&gt;tid, shared_x);
  pthread_mutex_unlock(&amp;lock);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">ThreadData</span> <span style="color: #eedd82;">threads_data</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  shared_x = 0;
  pthread_mutex_init(&amp;lock, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    threads_data[i].tid = i;
    threads_data[i].data = i * i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;threads_data[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    pthread_join(threads[i], &amp;status);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Condition Variables</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Overview</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Mutex 变量如锁一般防止多个线程访问共享数据资源,如果某个线程等待某个共享数据达到某个数值才进行相应的操作,那么这个线程需要不断的去 poll,查看是否满足需要的值,这样开销很大,因为线程需要一直处于忙状态.
</p>

<p>
引入 Condition Variables 来完成这样的同步到某个实际数据值而不要不断 poll.
</p>

<p>
Condition 变量一般与 mutex 一起使用.锁住查看的共享数据资源.
</p>

<p>
使用 Condition 的一般步骤如下:
</p>
<ul class="org-ul">
<li>声明和定义需要同步的共享数据;
</li>
<li>声明和定义 condition 变量;
</li>
<li>声明和定义相对应的 mutex;
</li>
<li>创建线程使用 condition 变量同步.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Creating and Destroying Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_destroy</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_init</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">cond</span>,
                      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_destroy</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_init</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Condition 变量由 <code>pthread_cond_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">convar</span> = PTHREAD_COND_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_cond_init()</code> 函数,并能设置 condition 的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置 condition 变量的属性,必须是 <code>pthread_condattr_t</code> 类型.只有一种属性可选:是否进程共享,也就是允许其他进程中的线程也能看到它.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Waiting and Signaling on Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_wait</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,
                      <span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_signal</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_broadcast</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
</pre>
</div>

<p>
<code>pthread_cond_wait()</code> 阻塞调用它的线程直到其中 <code>cond</code> 被 signal.这个函数需要在占有 <i>mutex</i> 时被调用,而它将 <b>自动释放</b> mutex 当它等待时.等到
signal 收到,线程被唤醒, <i>mutex</i> 将 <b>自动被占有</b> .最后当线程完成
condition 的操作,要负责对 mutex 解锁.
</p>

<p>
<code>pthread_cond_signal()</code> 用来 signal 其他等待这个 <code>cond</code> 的线程.它需要在占有 <i>mutex</i> 时被调用.然后必须对 mutex 解锁来完成 <code>pthread_cond_wait</code>
的等待.
</p>

<p>
如果有多余一个线程处于等待 <code>cond</code> 而阻塞, 应该用
<code>pthread_cond_broadcast()</code> 替换 <code>pthread_cond_signal()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 3;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLoops</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kCountLimit</span> = 15;

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_count</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">count_cv</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">IncreaseCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kLoops; ++i) {
    pthread_mutex_lock(&amp;count_mutex);
    g_count++;
    <span style="color: #00ffff;">if</span> (g_count == kCountLimit) {
      pthread_cond_signal(&amp;count_cv);
      printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, signal cond\n"</span>, id, g_count);
    }
    printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, unlock mutex\n"</span>, id, g_count);
    pthread_mutex_unlock(&amp;count_mutex);
    sleep(1);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">WatchCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_mutex_lock(&amp;count_mutex);
  <span style="color: #00ffff;">while</span> (g_count &lt; kCountLimit) {
    pthread_cond_wait(&amp;count_cv, &amp;count_mutex);
    printf(<span style="color: #ffa07a;">"watch thread %d: count = %d, receive signal\n"</span>, id, g_count);
  }
  pthread_mutex_unlock(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_mutex_init(&amp;count_mutex, <span style="color: #7fffd4;">NULL</span>);
  pthread_cond_init(&amp;count_cv, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span>;
  rt = pthread_create(&amp;threads[0], &amp;attr, WatchCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[0]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[1], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[1]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[2], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[2]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    pthread_join(threads[i], <span style="color: #7fffd4;">NULL</span>);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_cond_destroy(&amp;count_cv);
  pthread_mutex_destroy(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Barrier</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Overview</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Barrier 就是栅栏一样,调用等待 barrier 的线程需要等待直到满足调用 barrier 的线程个数达到要求的 <code>count</code>.
</p>
</div>
</div>

<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">Creating, Destroying and Wait Barrier</h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_init</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>,
                <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_destroy</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_init</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_destroy</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_wait</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
</pre>
</div>

<p>
Barrier 变量由 <code>pthread_barrier_t</code> 声明定义,而且必须初始化在使用前.需要传入满足 barrier 等待的个数 <code>count</code>, 两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_barrier_init()</code> 函数,并能设置 barrier 的属性 <code>attr</code>.
</li>
</ol>

<p>
线程调用 barrier,只需要调用 <code>pthread_barrier_wait</code> 来等待 barrier 达到满足条件.
</p>

<p>
<a id="google-wrap" name="google-wrap"></a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Google wrap the Pthread</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Mutex 类和 CondVar 类</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Google api 的 base 包里封装了 Mutex 类和 CondVar 类.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">base</span> {
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">LinkerInitialized</span> { <span style="color: #eedd82;">LINKER_INITIALIZED</span> };
}

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LOCKABLE</span> <span style="color: #eedd82;">PThreadMutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #eedd82;">PThreadMutex</span>(<span style="color: #7fffd4;">base</span>::LinkerInitialized) {
    pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>);
  }
  <span style="color: #eedd82;">PThreadMutex</span>()   { pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #eedd82;">PThreadMutex</span>()  { pthread_mutex_destroy(&amp;mutex_); }

  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Lock</span>()     { CHECK_EQ(0, pthread_mutex_lock(&amp;mutex_)); }
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Unlock</span>()   { CHECK_EQ(0, pthread_mutex_unlock(&amp;mutex_)); }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #00ffff;">friend</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span>;
  <span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex_</span>;

  DISALLOW_COPY_AND_ASSIGN(PThreadMutex);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">PThreadCondVar</span>()  { pthread_cond_init(&amp;cv_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #87cefa;">PThreadCondVar</span>() { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_destroy</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Signal</span>()        { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_signal</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SignalAll</span>()     { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_broadcast</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Wait</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>) {
    CHECK_EQ(0, pthread_cond_wait(&amp;cv_, &amp;mu-&gt;mutex_));
  }
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">WaitWithTimeout</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>, <span style="color: #98fb98;">int64</span> <span style="color: #eedd82;">millis</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> <span style="color: #eedd82;">tv</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> <span style="color: #eedd82;">ts</span>;
    gettimeofday(&amp;tv, <span style="color: #7fffd4;">NULL</span>);
    ts.tv_sec = tv.tv_sec + millis / 1000;
    ts.tv_nsec = millis % 1000;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = pthread_cond_timedwait(&amp;cv_, &amp;mu-&gt;mutex_, &amp;ts);
    <span style="color: #00ffff;">if</span> (!result) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

    CHECK_EQ(ETIMEDOUT, result);
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">cv_</span>;
  DISALLOW_COPY_AND_ASSIGN(<span style="color: #98fb98;">PThreadCondVar</span>);
};

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadCondVar</span> <span style="color: #98fb98;">CondVar</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadMutex</span> <span style="color: #98fb98;">Mutex</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">GoogleOnceInit 类</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pthread_once_t</span> <span style="color: #98fb98;">GoogleOnceType</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">GOOGLE_ONCE_INIT</span> PTHREAD_ONCE_INIT

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GoogleOnceInit</span>(<span style="color: #98fb98;">GoogleOnceType</span>* <span style="color: #eedd82;">once</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">initializer</span>)()) {
  CHECK_EQ(0, pthread_once(once, initializer));
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Monitoring, Debugging and Performance Analysis Tools for Pthreads</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Monitoring</h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1">Linux <b>ps</b> command</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
使用 Linux 自带的 <code>ps</code> 命令查看运行的 thread 情况,<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?ps">ps 的 man 手册</a>.
</p>
<div class="org-src-container">

<pre class="src src-sh">&#10140;$ ps -Lf
UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
shougang 13103  8814 13103  0    1 23:30 pts/17   00:00:00 /bin/zsh
shougang 13237 13103 13237  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13240  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13241  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13242  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13243  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13244  0    6 23:30 pts/17   00:00:00 [thread]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2">Linux <b>top</b> command</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Linux 的 <code>top</code> 命令加上 <code>-H</code> 参数, process 中的 threads 也能看到.
如下是 <code>top -H</code> 的一个例子:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/top.png">
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Debugging</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">GDB</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Threads.html#Threads">Debugging Programs with Multiple Threads</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Thread-Stops.html#Thread-Stops">GDB: Stopping and starting multi-thread programs</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/GDB_002fMI-Thread-Commands.html#GDB_002fMI-Thread-Commands">GDB/MI: Threads commands</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2">DDD</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li><a href="http://www.gnu.org/software/ddd/manual/html_mono/ddd.html#Threads">Examining Threads</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Performance Analysis Tools<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li><a href="http://www.openspeedshop.org/wp/">Open|SpeedShop</a>
</li>
<li><a href="http://www.cs.uoregon.edu/research/tau/home.php">TAU</a>
</li>
<li><a href="https://software.intel.com/en-us/intel-advisor-xe">Intel Advisor</a>
</li>
</ul>

<p>
<a id="boost-thread" name="boost-thread"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Boost thread library</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Overview</h3>
<div class="outline-text-3" id="text-8-1">
<p>
直到 C++11 库才比较好的支持 thread,之前 C++程序使用操作系统支持的 thread 库(如
Pthread).但这样做至少有个主要的问题:(1) 这些库基本是 C 的库,需要很小心的
C++中使用,和(2) 每个操作系统提供自己的一套对 thread 支持的库.以致,编写的代码既不标准又不可移植.
</p>

<p>
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread</a>可以解决这两个主要问题. Boost Thread 不是通过继承来使用线程,而是 Boost 的 thread 类使用一个 Callable 的对象创建.
</p>
</div>

<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1">编译 Boost Thread 程序</h4>
<div class="outline-text-4" id="text-8-1-1">
</div><div id="outline-container-sec-8-1-1-1" class="outline-5">
<h5 id="sec-8-1-1-1">include</h5>
<div class="outline-text-5" id="text-8-1-1-1">
<p>
根据使用到的 Boost Thread 中的类型包含不同头文件:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/locks.hpp&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-1-1-2" class="outline-5">
<h5 id="sec-8-1-1-2">compile</h5>
<div class="outline-text-5" id="text-8-1-1-2">
<p>
对于 Gcc 编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">g++ Program.o -o Program -lboost_thread -lboost_system
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Thread Management</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">Thread 类</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">  #include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread</span>
  {
  <span style="color: #00ffff;">public</span>:
      <span style="color: #87cefa;">thread</span>() noexcept;
      <span style="color: #87cefa;">thread</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;

      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      ~<span style="color: #87cefa;">thread</span>();

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A1</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A2</span>,...&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>,<span style="color: #98fb98;">A1</span> <span style="color: #eedd82;">a1</span>,<span style="color: #98fb98;">A2</span> <span style="color: #eedd82;">a2</span>,...);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);
      <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">id</span>;
      <span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;

      <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">joinable</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
      <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join</span>();
...
};
</pre>
</div>

<p>
整个 thread 类包含 thread 的所有特性,如 thread id, join, detach 等.
</p>
</div>
<div id="outline-container-sec-8-2-1-1" class="outline-5">
<h5 id="sec-8-2-1-1">Create Thread</h5>
<div class="outline-text-5" id="text-8-2-1-1">
<p>
Callable 对象既可以是一个函数又可以是类中的 <code>operator()</code> 实现,如下:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Hello</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
  }
};

<span style="color: #98fb98;">Hello</span> <span style="color: #eedd82;">h</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(h);
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(hello);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-1-2" class="outline-5">
<h5 id="sec-8-2-1-2">Passing data</h5>
<div class="outline-text-5" id="text-8-2-1-2">
<p>
传递参数给线程
</p>
<ol class="org-ol">
<li>thread 创建时附加后面
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(hello, str);
</pre>
</div>
<ol class="org-ol">
<li>利用 <code>Boost.bind</code> 库接口
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(bind(hello, str));
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">Thread group 类</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
可以使用 thread group 类管理 thread,通过 <code>add_thread</code> 和 <code>create_thread</code>
添加线程到管理类中, 可以直接 <code>join_all</code> 将所有管理类中的线程 join.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread_group</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">thread_group</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">thread_group</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">thread_group</span>();
    ~<span style="color: #87cefa;">thread_group</span>();

    <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #98fb98;">thread</span>* <span style="color: #87cefa;">create_thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">threadfunc</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_this_thread_in</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_thread_in</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join_all</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interrupt_all</span>();
    <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">size</span>() <span style="color: #00ffff;">const</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">Miscellaneous</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Boost Thread 中还有 <code>strict_scoped_thread</code> 类和 <code>scoped_thread</code> 类,提供线程结束不是调用 <code>terminate</code> ,而是调用传入的参数来执行特定行为.
</p>
</div>
</div>
<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4">Example: Thread Creation</h4>
<div class="outline-text-4" id="text-8-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/bind.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(){
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thrd</span>(bind(hello, str));
  thrd.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">mutex</span>:
    <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">noncopyable</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">mutex</span>();
    ~<span style="color: #87cefa;">mutex</span>();

    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">platform</span>-specific-type native_handle_type;
    <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #98fb98;">scoped_lock</span>;
    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unspecified</span>-type scoped_try_lock;
};
</pre>
</div>

<ul class="org-ul">
<li><code>lock()</code> 来获取锁.
</li>
<li><code>unlock()</code> 释放锁.
</li>
<li><code>typedef unique_lock&lt;mutex&gt; scoped_lock;</code> 定义了 <code>scoped_lock</code> 的类型,通过 <code>boost::mutex::scoped_lock</code> 来定义一个 RAII-style 锁,离开定义区域自动释放锁.
</li>
</ul>
</div>

<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><code>lock_guard</code></h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
<code>boost::lock_guard</code> 非常简单:
</p>
<ul class="org-ul">
<li>构造时,它获取锁.
</li>
<li>析构时,它释放锁.
</li>
</ul>

<p>
它提供了一个简单的 RAII-style 锁对象,使得 exception-safe 锁和解锁更容易.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">lock_guard</span>
<span style="color: #b0c4de;">#if</span> ! <span style="color: #b0c4de;">defined</span> BOOST_THREAD_NO_MAKE_LOCK_GUARD
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>, <span style="color: #98fb98;">adopt_lock_t</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
<span style="color: #b0c4de;">#endif</span>
}
</pre>
</div>

<p>
基本使用,传入可 <code>Lockable</code> 的 mutex 类型:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #87cefa;">lock</span>(count_mutex) ;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-8-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">count</span> {
  <span style="color: #87cefa;">count</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>) : id_(id) {
  }
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(count_mutex);
      cout &lt;&lt; id_ &lt;&lt; <span style="color: #ffa07a;">": "</span> &lt;&lt; i &lt;&lt; endl;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id_</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread1</span>(count(1));
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread2</span>(count(2));
  thread1.join();
  thread2.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Condition Variables</h3>
<div class="outline-text-3" id="text-8-4">
<p>
与 Pthread, Boost Condition Variable 功能更全面,如不同条件的
<code>wait_until</code> , <code>wait_for</code> 等功能.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
    <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable</span>
    {
    <span style="color: #00ffff;">public</span>:
        <span style="color: #87cefa;">condition_variable</span>();
        ~<span style="color: #87cefa;">condition_variable</span>();

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_one</span>() noexcept;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all</span>() noexcept;

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>);

        <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">predicate_type</span>&gt;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,<span style="color: #eedd82;">predicate_type</span> predicate);

        <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
        <span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">cv_status</span>::<span style="color: #98fb98;">type</span>
        <span style="color: #87cefa;">wait_until</span>(
            <span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
            <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">t</span>);
...
};
</pre>
</div>
</div>

<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
利用 Condition Variables 实现一个简单的 read/writer Buffer.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kBufSize</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kIters</span> = 100;

<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">io_mutex</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Buffer</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #98fb98;">scoped_lock</span>;
  <span style="color: #87cefa;">Buffer</span>() : p(0), c(0), full(0) {
  }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Put</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == kBufSize) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is full."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == kBufSize) {
        cond.wait(lock);
      }
    }
    buf[p] = m;
    p = (p + 1) % kBufSize;
    ++full;
    cond.notify_one();
  }

  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Get</span>() {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == 0) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is empty."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == 0) {
        cond.wait(lock);
      }
    }
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = buf[c];
    c = (c + 1) % kBufSize;
    --full;
    cond.notify_one();
    <span style="color: #00ffff;">return</span> i;
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">mutex</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">condition</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">full</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">buf</span>[kBufSize];
};

<span style="color: #98fb98;">Buffer</span> <span style="color: #eedd82;">buf</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writer</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"sending: "</span> &lt;&lt; i &lt;&lt; endl;
    }
    buf.Put(i);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reader</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = buf.Get();
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"received: "</span> &lt;&lt; n &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_reader</span>(&amp;<span style="color: #eedd82;">reader</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_writer</span>(&amp;<span style="color: #eedd82;">writer</span>);
  thread_reader.join();
  thread_writer.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Miscellaneous</h3>
<div class="outline-text-3" id="text-8-5">
</div><div id="outline-container-sec-8-5-1" class="outline-4">
<h4 id="sec-8-5-1">Barrier</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
基本使用:
</p>
<ol class="org-ol">
<li>定义 barrier,传入参与 thread 个数: <code>barrier b(num_threads)</code>.
</li>
<li>thread 中等待 barrier: <code>b.wait()</code>.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">barrier</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">barrier</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>);
    <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">F</span>&amp;&amp;);

    ~<span style="color: #87cefa;">barrier</span>();

    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">count_down_and_wait</span>();
};
</pre>
</div>


<p>
<a id="other-materials" name="other-materials"></a>
</p>
</div>
</div>

<div id="outline-container-sec-8-5-2" class="outline-4">
<h4 id="sec-8-5-2">Once Routines</h4>
<div class="outline-text-4" id="text-8-5-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>

<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">once_flag</span>;
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Function</span>, <span style="color: #00ffff;">class</span> ...ArgTypes&gt;
  <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>, <span style="color: #98fb98;">Function</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">ArgTypes</span>&amp;&amp;... args);

<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span> BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">func</span>)(),<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>);
<span style="color: #b0c4de;">#endif</span>

}
</pre>
</div>
</div>
<div id="outline-container-sec-8-5-2-1" class="outline-5">
<h5 id="sec-8-5-2-1">Example: Call once</h5>
<div class="outline-text-5" id="text-8-5-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">once_flag</span> <span style="color: #eedd82;">flag</span> = BOOST_ONCE_INIT;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">init</span>()
{
  ++i;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">thread</span>()
{
  <span style="color: #7fffd4;">boost</span>::call_once(&amp;init, flag);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd1</span>(&amp;<span style="color: #eedd82;">thread</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd2</span>(&amp;<span style="color: #eedd82;">thread</span>);
  thrd1.join();
  thrd2.join();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; i &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">其他资料</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Books:</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li><a href="http://shop.oreilly.com/product/9781565921153.do">PThreads Programming</a> and <a href="http://wiki.dreamrunner.org/public_html/Books%20Review/Pthreads%20Programming/Pthreads%20Programming.html">Its notes</a>
</li>
<li><a href="http://www.justsoftwaresolutions.co.uk/blog/">Anthony Williams’ blog</a> and his book, <a href="http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&amp;tag=preshonprogr-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988770">C++ Concurrency in Action</a>
</li>
<li>Herlihy &amp; Shavit's <i>The Art of Multiprocessor Programming</i>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Online resources:</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li><i>Dmitriy V’jukov’s website</i> and various <a href="https://groups.google.com/forum/?fromgroups#!forum/lock-free">forum discussions</a>
</li>
<li><a href="http://bartoszmilewski.com/">Bartosz Milewski’s blog</a>
</li>
<li>Charles Bloom’s <a href="http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html">Threading Posts</a> on his blog
</li>
<li>Doug Lea's <a href="http://g.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a>
</li>
<li><a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">memory-barriers.txt document</a>
</li>
<li>Hans Boehm’s <a href="http://www.hboehm.info/c++mm/">collection of links about the C++11 memory model</a>
</li>
<li>Scott Meyers's <a href="http://scottmeyers.blogspot.hk/2012/04/information-on-c11-memory-model.html">Information on the C++11 Memory Model </a>
</li>
<li>Herb Sutter’s <a href="http://www.gotw.ca/publications/">Effective Concurrency series</a>
</li>
<li>POSIX Standard: <a href="http://www.unix.org/version3/ieee_std.html">http://www.unix.org/version3/ieee_std.html</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">有关 Mutex</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li><a href="http://home.roadrunner.com/~hinnant/mutexes/locking.html">Handling mutexes in C++</a>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">Mutex, Lock, Condition Variable Rationale</a>
</li>
</ul>

<p>
<a id="pthread-library" name="pthread-library"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Pthread Library Routines Reference</h2>
<div class="outline-text-2" id="text-10">
<p>
<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_atfork.txt">pthread_atfork</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_destroy.txt">pthread_attr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getdetachstate.txt">pthread_attr_getdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getguardsize.txt">pthread_attr_getguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getinheritsched.txt">pthread_attr_getinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedparam.txt">pthread_attr_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedpolicy.txt">pthread_attr_getschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getscope.txt">pthread_attr_getscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstack.txt">pthread_attr_getstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstackaddr.txt">pthread_attr_getstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstacksize.txt">pthread_attr_getstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_init.txt">pthread_attr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setdetachstate.txt">pthread_attr_setdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setguardsize.txt">pthread_attr_setguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setinheritsched.txt">pthread_attr_setinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedparam.txt">pthread_attr_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedpolicy.txt">pthread_attr_setschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setscope.txt">pthread_attr_setscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstack.txt">pthread_attr_setstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstackaddr.txt">pthread_attr_setstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstacksize.txt">pthread_attr_setstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_destroy.txt">pthread_barrier_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_init.txt">pthread_barrier_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_wait.txt">pthread_barrier_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_destroy.txt">pthread_barrierattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_getpshared.txt">pthread_barrierattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_init.txt">pthread_barrierattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_setpshared.txt">pthread_barrierattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cancel.txt">pthread_cancel</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_pop.txt">pthread_cleanup_pop</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_push.txt">pthread_cleanup_push</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_broadcast.txt">pthread_cond_broadcast</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt">pthread_cond_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt">pthread_cond_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_signal.txt">pthread_cond_signal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_timedwait.txt">pthread_cond_timedwait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_wait.txt">pthread_cond_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getclock.txt">pthread_condattr_getclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getpshared.txt">pthread_condattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt">pthread_condattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setclock.txt">pthread_condattr_setclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setpshared.txt">pthread_condattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt">pthread_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_detach.txt">pthread_detach</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_equal.txt">pthread_equal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_exit.txt">pthread_exit</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getconcurrency.txt">pthread_getconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getcpuclockid.txt">pthread_getcpuclockid</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getschedparam.txt">pthread_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getspecific.txt">pthread_getspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_join.txt">pthread_join</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_create.txt">pthread_key_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_delete.txt">pthread_key_delete</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_kill.txt">pthread_kill</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_destroy.txt">pthread_mutex_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_getprioceiling.txt">pthread_mutex_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_init.txt">pthread_mutex_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_lock.txt">pthread_mutex_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_setprioceiling.txt">pthread_mutex_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_timedlock.txt">pthread_mutex_timedlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_trylock.txt">pthread_mutex_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt">pthread_mutex_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_destroy.txt">pthread_mutexattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprioceiling.txt">pthread_mutexattr_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprotocol.txt">pthread_mutexattr_getprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getpshared.txt">pthread_mutexattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_gettype.txt">pthread_mutexattr_gettype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt">pthread_mutexattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprioceiling.txt">pthread_mutexattr_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprotocol.txt">pthread_mutexattr_setprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setpshared.txt">pthread_mutexattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_settype.txt">pthread_mutexattr_settype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_once.txt">pthread_once</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_destroy.txt">pthread_rwlock_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_init.txt">pthread_rwlock_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_rdlock.txt">pthread_rwlock_rdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedrdlock.txt">pthread_rwlock_timedrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedwrlock.txt">pthread_rwlock_timedwrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_tryrdlock.txt">pthread_rwlock_tryrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_trywrlock.txt">pthread_rwlock_trywrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_unlock.txt">pthread_rwlock_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_wrlock.txt">pthread_rwlock_wrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_destroy.txt">pthread_rwlockattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_getpshared.txt">pthread_rwlockattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_init.txt">pthread_rwlockattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_setpshared.txt">pthread_rwlockattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_self.txt">pthread_self</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcancelstate.txt">pthread_setcancelstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcanceltype.txt">pthread_setcanceltype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setconcurrency.txt">pthread_setconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedparam.txt">pthread_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedprio.txt">pthread_setschedprio</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setspecific.txt">pthread_setspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_sigmask.txt">pthread_sigmask</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_destroy.txt">pthread_spin_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_init.txt">pthread_spin_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_lock.txt">pthread_spin_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_trylock.txt">pthread_spin_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_unlock.txt">pthread_spin_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_testcancel.txt">pthread_testcancel</a>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html">http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools">https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools</a>
</p></div>


</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multithreading相关术语总结]]></title>
    <link href="http://dreamrunner.org/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie/"/>
    <updated>2014-07-05T23:23:52+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie</id>
    <content type="html"><![CDATA[<p>在谈到内存模型,Multithreading,尤其 lock-free programmming 等时,总会遇到
一些相关术语来描述,如 Memory Barrier,Acquire semantics,Release
semantics,happens-before relation 等.在这里稍微整理一下.</p>

<!-- more -->

<h2 id="memory-barriers">Memory Barriers</h2>

<p>在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/">浅谈 Memory Reordering</a>
中谈到编译器 reordering 和在多核下的处理器的 reordering,在 lock-free
programming 中,如果不控制好这两者的 reordering 就会引起上文中所不想的结果.</p>

<p>你可以通过指令强制 CPU 和编译器在内存处理上的顺序,这些指令就被成为
<a href="http://en.wikipedia.org/wiki/Memory_barrier">Memory Barrier</a>.</p>

<p>有很多指令作为 memory barriers,所以需要知道很多不同类型的 memory
barriers. <a href="http://g.oswego.edu/dl/jmm/cookbook.html">Doug Lea 指出</a>如下
的四大类可以很好的归纳在 CPU 上的特殊指令.尽管不是完全,大多数时候,一个正
真的 CPU 指令执行包含上面 barrier 类型的各种组合,或附带其他效果.无论如何,
一旦你理解了这四种类型的 memory barriers,你就很好的理解了大部分真正 CPU
的关于内存约束的指令.
<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">Memory Barriers Are Like Source Control Operations</a>
这篇把 Memory Barriers 与 Source Control 作类比,熟悉 Source Control 机制的可
以很形象的理解各类 Memory Barriers 机制.</p>

<p><img class="center" src="/images/blog/2014/multithreading/memory_barriers_types.png" title="‘memory_barriers_types’" ></p>

<h3 id="loadload">LoadLoad</h3>

<p>顺序: Load1; <strong>LoadLoad</strong>; Load2</p>

<p>保证 Load1 的数据加载在被 load2 和之后的 load 指令读取加载之前.是一个比较好
的方法防止看到旧的数据.以这个经典的例子,CPU1 检查一个共享的标识变量 flag 来确
认一些数据是否被 CPU1 更新.如果标识变量 flag 是 true 的话,把<code>LoadLoad</code>barrier
放在读取更新数据之前:</p>

<p><code>c++
if (is_updated) {
    LOADLOAD_FENCE();  // Prevent reordering of loads
    return value;  // Load updated value
}
</code></p>

<p>只要<code>is_updated</code>被 CPU1 看到为 true, <code>LoadLoad</code>fence 防止 CPU1 读到比标识变
量 flag 本身旧的<code>value</code>.</p>

<h3 id="storestore">StoreStore</h3>

<p>顺序: Store1; <strong>StoreStore</strong>; Store2</p>

<p>保证 Store1 的数据被其他 CPU 看到在与这数据相关的 Store2 和之后的 store 指令之
前.同样,它足够的防止其他 CPU 看到自己的旧数据.同上一样的例子,CPU1 需要更
新一些数据到共享的内存中,把<code>StoreStore</code> barrier 放在标识变量 flag 是 true
之前:</p>

<p><code>c++
value = x;
STORESTORE_FENCE();
is_updated = 1;  // Set shared flag to show the update of data
</code></p>

<p>一旦其他 CPU 看到<code>is_updated</code>为 true,它能自信它看到正确的<code>value</code>值.而且
<code>value</code>不需要原子类型,它可以是一个包含很多元素的大数据结构.</p>

<h3 id="loadstore">LoadStore</h3>

<p>顺序: Load1; <strong>LoadStore</strong>; Store2</p>

<p>保证 Load1 的数据被加载在与这数据相关的 Store2 和之后的 store 指令之
前.</p>

<h3 id="storeload">StoreLoad</h3>

<p>顺序: Store1; <strong>StoreLoad</strong>; Load2</p>

<p>保证 Store1 的数据被其他 CPU 看到在数据被 Load2 和之后的 load 指令加载之前.也
就是说,它有效的防止所有 barrier 之前的 stores 与所有 barrier 之后的 load 乱序.</p>

<p><code>StoreLoad</code>是唯一的.它是唯一的 memory barrier 类型来防止<code>r1=r2=0</code>在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#memory-ordering-at-processor-time">Memory ordering at processor time</a>
中给出的例子.</p>

<p><code>StoreLoad</code>有什么区别与<code>StoreStore</code>之后跟<code>LoadLoad</code>?虽
然,<code>StoreStore</code>按序把存储改变推送到主内存中,<code>LoadLoad</code>按序把改变加载过
来,但是这两种类型的 barrier 是不够的.Store 可以延迟任意的指令,以致在 Load
之后,Load 也可以不是加载最新 Store 之后的内容.这就是为啥 PowerPC 的指令
<code>lwsync</code>,包含这三种 memory barriers,<code>LoadLoad</code>,<code>LoadStore</code>和
<code>StoreStore</code>,但不包含<code>StoreLoad</code>,是不足以防止<code>r1=r2=0</code>在那个实例中.</p>

<h3 id="data-dependency-barriers">Data dependency barriers</h3>

<p>除了上面 4 大类,还有<code>Loadload</code>的弱化模式的<code>Data dependency barrier</code>.如
<code>LoadLoad</code>类似,在两个 load 顺序执行,load2 依赖于 load1 的结果,<code>Data
dependency barrier</code>需要插入保证两者的顺序.</p>

<p>但与<code>LoadLoad</code>不同,<code>Data dependency barrier</code>只是部分顺序约束在内在以来
的 load,就是 load1 必须与 load2 是 <strong>data</strong> dependency 而不是仅仅是
<strong>control</strong> dependency.</p>

<ul>
  <li>data dependency</li>
</ul>

<p>r1 与 r2 之间是 data dependency.</p>

<p><code>c
r1 = 1;
r2 = r1;
</code></p>

<ul>
  <li>control dependency</li>
</ul>

<p>r1 与 r2 之间是 control dependency.</p>

<p><code>c
r1 = value;
if (r1) {
    r2 = r1;
} else {
    r2 = 1;
}
</code></p>

<h3 id="more">More</h3>

<ul>
  <li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS</a> </li>
  <li><a href="www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf">Memory Barriers: a Hardware View for Software Hackers</a></li>
</ul>

<h2 id="acquire-and-release-semantics">Acquire and Release semantics</h2>

<p>在 lock-free programming 中,共享内存被多个线程通过合作传递信息来处理,在
这种处理下,acquire 和 release semantics 是关键技术保证可靠的传递信息在线
程之间.</p>

<p>acqure 和 release semantics 并没有好的被定义,这里借用 Jeff Preshing 在
<a href="http://preshing.com/20120913/acquire-and-release-semantics/">这里</a>给
予的定义:</p>

<p><img class="right" src="/images/blog/2014/multithreading/read_acquire.png" width="170" height="110" title="‘read_acquire’" ></p>

<p><strong>Acquire semantics</strong> 是一种只能应用于如下操作的性质: 从
共享内存读取,无论是
<a href="http://en.wikipedia.org/wiki/Read-modify-write">read-modify-write</a> 操
作还是普通的加载.这一操作被认为是一个 <strong>read acquire</strong>. Acquire
semantics 防止 read acquire 程序上<strong>之后</strong>的任何读或写操作与它的内存乱
序.</p>

<p><br /></p>

<p><img class="right" src="/images/blog/2014/multithreading/write_release.png" width="170" height="110" title="‘write_release’" ></p>

<p><strong>Release semantics</strong> 是一种只能应用于如下操作的性质: 写入到共享内存,
无论是 read-modify-write 操作还是普通的存储.这一操作被认为是一个 <strong>write release</strong>.
Release semantics 防止 write release 程序上<strong>之前</strong>的任何读或写
操作与它的乱序.</p>

<p>Acqure 和 release semantics 能通过之前四种 memory barrier 的简单组合来达到.</p>

<p><img class="center" src="/images/blog/2014/multithreading/acquire_release_semantics.png" title="‘acquire_release_semantics’" ></p>

<p>Acqure 和 release semantics 可以基本划分为如下结构:</p>

<p><img class="center" src="/images/blog/2014/multithreading/acquire_release_semantics_category.png" title="‘acquire_release_semantics_category’" ></p>

<h3 id="fence-">使用明确的平台相关 Fence 指令</h3>

<p>在 X86/64 使用<code>mefence</code>指令,mfence 是一个满足全部 memory barrier,防止任何类型的内存乱序.</p>

<p><img class="center" src="/images/blog/2014/multithreading/platform-specific_fence.png" title="‘platform-specific_fence’" ></p>

<h3 id="c11--fences">可移植的 C++11 的 Fences</h3>

<p>C++11 的 atomic 库定义了一个可移植的函数<code>atomic_thread_fence()</code>,输入一个
变量来指定什么类型的 fence.</p>

<p><img class="center" src="/images/blog/2014/multithreading/fence_in_c++11.png" title="‘fence_in_c++11’" ></p>

<h3 id="c11--atomic-fence">可移植的 C++11 的 atomic,非明确的 fence</h3>

<p>在 C++11 中,可以直接对 atomic 变量直接约束 fence,而不是显示的明确 fence.与上
面明确 fence 相比,这实际是更优的方法来表达 acquire and release semantics
在 C++11 中.</p>

<p><img class="center" src="/images/blog/2014/multithreading/without_fence_c++11.png" title="‘without_fence_c++11’" ></p>

<h2 id="happens-before-relation">Happens-before relation</h2>

<p><em>Happens-before</em> 是一个术语来描述 C++11,Java,LLVM 之类背后的<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#weak-vs-strong-memory-models">软件内存模型</a>.</p>

<p>在之上每个语言里都能找到* happends-before *的定义,尽管每个都有不同的说法,但
内在意思基本一致.粗略地讲,基本定义如下:</p>

<p><blockquote><p>A 和 B 表示一个多线程进行的操作.若 A <strong>happens-before</strong> B,那<br/>么,在 B 进行前,A 对 B 的内存影响有效的被 B 看到.</p></blockquote></p>

<p>无论使用任何编程语言,它们都有一个共同处:如果操作 A 和 B 被同一个进程进行,A
的语句在 B 的语句之前在程序顺序上,那么 A <em>优先发生(happens-before)</em>B.这也
是在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#weak-vs-strong-memory-models">Memory ordering</a>
中谈到中心原则.</p>

<p>这里再次提一下指令重排序问题,有人有如下疑问: 指令重排序会破坏
happens-before 原则吗？happens-before 的程序次序原则说：在一个线程内，按
照程序代码顺序，书写在前面的操作会先行发生于书写在后面的操作。如果线程
内出现指令重排序，那不是破坏了程序次序原则了吗？</p>

<p>是会破坏程序次序的执行,但是并不破坏 happens-before 原则,并不造成内存对单
线程有效性的破坏.这里主要的困惑是时间上顺序的发生之前(happening
before)与先行发生(happens-before)两者关系.</p>

<p>时间上顺序的发生在前于(happening before)与先行发生(happens-before)两者是
不一样的,基本没太大关系.特别:</p>

<ol>
  <li>A 先行发生(happens-before)B 并不意味着 A 发生在前于(happening before)B.</li>
  <li>A 发生在前于(happening before)B 并不意味 A 先行发生(happens-before)B.</li>
</ol>

<p>谨记 happens-before 是由一系列编程语言特定定义的操作间的关系,它的存在独
立于时间的概念.</p>

<h3 id="happens-before--happening-before">happens-before 并不意味 happening before</h3>

<p>如下例子有 happens-before 关系但并不是顺序执行,没有 happening before.如下
代码:(1) 存储到 A,之后(2)存储到 B.根据程序顺序原则,(1) happens-before (2).</p>

<p><code>c++
int A, B;
void test() {
  A = B + 1;  // (1)
  B = 0;  // (2)
}
</code></p>

<p>用 O2 打开优化编译的如下:</p>

<p>``` sh
$ gcc -S -O2  -masm=intel test.c</p>

<pre><code>mov	eax, DWORD PTR B
mov	DWORD PTR B, 0
add	eax, 1
mov	DWORD PTR A, eax ```
</code></pre>

<p>从汇编指令看出,第二句<code>mov DWORD PTR B, 0</code>就已经完成对<code>B</code>的存储,但是
对<code>A</code>的存储还没进行.(1)顺序上并没有在(2)之前执行!</p>

<p>但是 happens-before 原则有被违背吗?根据定义,(1)的内存效用必须有效被看到
在进行(2)之前.也就是存储 A 必须影响存储 B.</p>

<p>在这里,存储 A 实际并没有影响存储 B.(2)被提前执行与之后执行仍然一样,相当与
(1)的内存有效性是一样的.因此,这并不算违背 happens-before 原则.</p>

<h3 id="happening-before--happens-before">happening before 并不意味 happens-before</h3>

<p>这是个时间上发生于前但并含有 happens-before 关系的例子.如下的代码,想象一
个线程调用<code>UpdateValue</code>,而另一个线程调用<code>ConsumeValue</code>.因为处理共享的
数据并行的,为了简单,认为普通的读取和存储<code>int</code>是 atomic 的.因为程序顺序原
则,在(1)和(2)之间 happens-before 关系,(3)和(4)之间 happens-before 关系.</p>

<p>``` c++
int value = 0;
int updated = 0;</p>

<p>void UpdateValue() {
    value = 123;  // (1)
    update = 1;  // (2)
}</p>

<p>void ConsumeValue() {
if (update) {  // (3)
    printf(“%d\n”, value);  // (4)
}
```</p>

<p>进一步假设在运行开始的时候,(3)读取<code>update</code>到为 1,这个值是有(2)在另外个线程
中存储的.这里,我们可以得出时间顺序上(2)必须发生前于(3).但是这里并没有规
则意味着在(2)和(3)之间有 happens-before 关系.(2)和(3)之间没有
happens-before 关系,(1)和(4)之间也没有 happens-before 关系.因此,(1)和(4)
的内存可以重排序,因为编译器重排序或在 CPU 上内存重排序,以致(4)可以打印
“0”,即使(3)读到 1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈Mutex (Lock)]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/"/>
    <updated>2014-06-29T20:52:09+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a>(又叫 Lock),在多线程中,作为同步的基本类型,用来保证没有两个线程或进程同时在他们的关键区域.因为 Mutex 这种排它性,很多人认为 Mutex 开销很大,尽量避免使用它.就如这篇
分析完共享数据问题后,进一步分析说明
<a href="http://courses.cs.washington.edu/courses/cse451/03wi/section/prodcons.htm">Avoiding locks</a>
来解决这个问题.但 Mutex 真的开销如此大,还是被大家误解了?Matthew
Dillon <a href="http://groups.google.com/group/net.micro.mac/msg/752d18de371bd65c?dmode=source">写道</a>,”Most
people have the misconception that locks are slow.”, Jeff Preshing 也
<a href="http://preshing.com/20111118/locks-arent-slow-lock-contention-is/">写了这篇”Locks Aren’t Slow; Lock Contention Is”</a>.</p>

<p>那么接下来做 3 个关于 Mutex 的 Benchmark,具体分析一下 Mutex 的开销如何,最后并
利用原子操作和 semaphore 实现一个 lightweight Mutex.</p>

<!-- more -->

<p>一个 Mutex 仅仅从 Lock 到 Unlock 具体开销是多少,是不是占用很多时间,从
<a href="http://preshing.com/20111124/always-use-a-lightweight-mutex/">Always Use a Lightweight Mutex</a>
从可以看到在 windows 中有两种
Mutex:<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684266%28v=vs.85%29.aspx">Muetx</a>
和
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682530%28v=vs.85%29.aspx">Critical Section</a>,
重量级和轻量级的区别,两者的时间开销相差 25 倍多,所以一直使用轻量级的 Mutex.</p>

<p><a href="http://ridiculousfish.com/blog/posts/barrier.html">这篇文章</a>在高强度
下 lock 的性能:每个线程做任何事情都占用 lock(高冲突),lock 占用极短的时间
(高频率).值得一读,但是在实际应用中,基本避免如此使用 locks.这里对
Mutex Contention 和 Mutex Frequency 都做最好和最坏场景的使用测试.</p>

<p>Mutex 被灌以避免使用也因为其他原因.现在有很多大家熟知的
<a href="en.wikipedia.org/wiki/Non-blocking_algorithma">lock-free programming</a>
技术.Lock-free 编程非常具有挑战性,但在实际场景中获得巨大的性能.既然有
lock-free 的技术吸引我们使用它们,那么 locks 就显得索然无味了.</p>

<p>但也不能因此忽略 lock.因为在实际很多场景,它仍然是利器.</p>

<h2 id="lightweight-mutex-benchmark">Lightweight Mutex Benchmark</h2>

<p>Linux 下的 POSIX thread 是轻量级的 Mutex.基于 Linux 特有的
<a href="http://en.wikipedia.org/wiki/Futex">futex</a> 技术,当没有其他线程竞争锁时它被优化过.使
用如下简单的例子,测试一个单线程 lock 和 unlock,所有代码在 <a href="https://github.com/shishougang/blog_multithreading/tree/master/mutex_time">Github 上</a>.</p>

<p><code>c++
pthread_mutex_init(&amp;lock, NULL);
const int kN = 1000000;
for (int i = 0; i &lt; kN; ++i) {
    pthread_mutex_lock(&amp;lock);
    pthread_mutex_unlock(&amp;lock);
}
pthread_mutex_destroy(&amp;lock);
</code></p>

<p>插入相应的时间代码,算出 10 万次的单线程 lock/unlock 平均时间.在不同的处理
器下,结果如下:</p>

<p><img class="center" src="/images/blog/2014/multithreading/mutex_benchmark.png" width="450" height="200" title="‘mutex_benchmark’" ></p>

<p>如果假设一个线程每分钟获取 1e5 次 mutex,并且没有其他线程与它竞争.基于如下
的图,可预计 0.2%到 0.4%的开销.不算差.在比较低频率下,开销基本忽略不计.之
后 <a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock#build-own-lightweight-mutex">Build own lightweight mutex</a>,会利用 <a href="http://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> 和一个原子操作,实现一个 lightweight mutex.</p>

<p>POSIX thread 与 Windows Critical Section 不同,它不仅支持线程间的同步,
还支持进程间的同步.实例代码如下:</p>

<p>```  c++  mutex_between_process.cc
pthread_mutex_t mutex;
pthread_mutexattr_t attrmutex;</p>

<p>/* Initialise attribute to mutex. */
pthread_mutexattr_init(&amp;attrmutex);
pthread_mutexattr_setpshared(&amp;attrmutex, PTHREAD_PROCESS_SHARED);
pthread_mutex_init(&amp;mutex, &amp;attrmutex);</p>

<p>/* Use the mutex. */</p>

<p>/* Clean up. */
pthread_mutex_destroy(pmutex);
pthread_mutexattr_destroy(&amp;attrmutex);
```</p>

<h2 id="mutex-contention-benchmark">Mutex Contention Benchmark</h2>

<p>在测试中,产生一个不断生成随机数的线程,使用自己编制的线程安全的
<a href="http://en.wikipedia.org/wiki/Mersenne_twister">Mersenne Twister</a> 实现
代码.每过一段时间,它获取和释放一个锁,获取和释放锁之间的时间每次是随机的,但
是总的平均时间是提前设计好的.这个随机的过程就是个泊松分布过程,计算出产
生一个随机数的平均时间 6.25 ns 在 2.93 GHz i7 上,把它作为运行单位.利用
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/poisson-process.html">Poisson Process</a>
的算法决定运行多少个运行单位在获取和释放锁之间.并利用
<a href="http://dreamrunner.org/blog/2014/06/24/high-resolution-time/">High Resolution Time</a>API
计算时间.这个线程的代码如下,所有代码在 <a href="https://github.com/shishougang/blog_multithreading/tree/master/mutex_contention">Github 上</a>:</p>

<p>``` c++
  GetMonotonicTime(&amp;start);
  for (;;) {
    work_units = static_cast<int> (random.PoissonInterval(
        global_state.average_unlock_count) + 0.5f);
    for (int i = 0; i &lt; work_units; ++i) {
      random.Integer();
    }
    thread_stats.workdone += work_units;</int></p>

<pre><code>GetMonotonicTime(&amp;end);
elapsed_time = GetElapsedTime(&amp;start, &amp;end);
if (elapsed_time &gt;= global_state.time_limit) {
  break;
}

// Do some work while holding the lock
pthread_mutex_lock(&amp;global_state.thread_mutex);
work_units = static_cast&lt;int&gt; (random.PoissonInterval(
    global_state.average_locked_count) + 0.5f);
for (int i = 0; i &lt; work_units; ++i) {
  random.Integer();
}
thread_stats.workdone += work_units;
pthread_mutex_unlock(&amp;global_state.thread_mutex);

thread_stats.iterations++;
GetMonotonicTime(&amp;end);
elapsed_time = GetElapsedTime(&amp;start, &amp;end);
if (elapsed_time &gt;= global_state.time_limit) {
  break;
}   } ```
</code></pre>

<p>这里模拟获取和释放 15000 次锁每秒,从 1 个线程运行到 2 个线程,最后到 4 个线
程.并且验证占用锁的时间,从 0%到 100%的每次运行时间占用锁.把 1 个线程的完成
的工作量作为基准数据,其他的去除以它,计算相对增益.基本测试方案如下:</p>

<p><code>c++
// Test 15000 locks per second: thread number, lock_interval
    1, 1/15000.0f, 
    2, 1/15000.0f,
    3, 1/15000.0f,
    4, 1/15000.0f,
</code></p>

<p><img src="/images/blog/2014/multithreading/lock_benchmark.png" title="lock_benchmark’" ></p>

<p>从图中看出,随着锁占用的时间增加,并行性越来越差,直到最后占用 60%以后,单
线程运行的更好.可以说,短时间的占用锁的时间,以 10%以内,系统达到很高的并
行性.虽然并不是完美的,但是也接近.锁总体很快.</p>

<p>把这个结果放到实际中,Jeff Preshing 在
<a href="http://preshing.com/20111118/locks-arent-slow-lock-contention-is/">这篇</a>
提到,实际的游戏程序中,15000 的锁每秒来自 3 个线程,占用锁的时间相对 2%.在图
中很适中的区域.</p>

<h2 id="mutex-frequency-benchmark">Mutex Frequency Benchmark</h2>

<p>尽管一个 lightweight mutex 有开销,但如上测试在 2.40GHz i5 上,lock/unlock 锁
开销约 <strong>34.2ns</strong> ,因此 15000 锁每秒开销很低以致不是严重影响结果.那么把
锁的每秒频率提高呢?</p>

<p>只创建 2 个线程,进行一系列的锁的每秒频率测试在 2.40GHz i5 上,从占用锁时间
10 ns(1e8/s)到 100 us(1e4/s),用单线程的占用锁时间 10 ms 作为基准工作量,其
他与它比较,测试方案如下:</p>

<p>``` c++
  // Reference
  1, 10e-3f,      // 10 ms        100/s</p>

<pre><code>// Test various lock rates with 2 threads
2, 10e-9f,      // 10 ns        100000000/s
2, 31.6e-9f,    // 31.6 ns      31600000/s
2, 100e-9f,     // 100 ns       10000000/s
2, 316e-9f,     // 316 ns       3160000/s
2, 1e-6f,       // 1 us         1000000/s
2, 3.16e-6f,    // 3.16 us      316000/s
2, 10e-6f,      // 10 us        100000/s
2, 31.6e-6f,    // 31.6 us      31600/s
2, 100e-6f,     // 100 us       10000/s ```
</code></pre>

<p><img src="/images/blog/2014/multithreading/frequency_benchmark.png" title="‘frequency_bechmark’" ></p>

<p>如预想一样,对于非常高频率的锁,锁的开销开始减少实际工作量.在网络上,可以
找到很多同样的测试.图中下边的线条,对于这样高的频率,也就是占用锁的时间
很短,就一些 CPU 的指令,这样的情况下,当锁之间的工作如此简单,那么一个
lock-free 的实现更适合.</p>

<p>我们获得了一大块关于锁的性能:从它进行很好的情况,到缓慢应用的情况.在考
虑实际锁的使用情况,不能说所有锁都是慢的.必须承认,很容易乱用锁,但不用太
担心,任何的瓶颈问题都会在细心的 profiling 中发现.当你考虑锁是如何的稳定,
相对容易的理解它们(与 lock-free 技术相比),锁有时候其实很好用.</p>

<h2 id="build-own-lightweight-mutex">Build own lightweight mutex</h2>

<p>我们也可以实现自己的简单轻量级的 mutex,但仅仅作为教育手段,理解 mutex 一些
内在实现细节,实际现在操作系统都提供轻量级的 mutex,千万不要自己实现一个
并实际使用,直接只用操作系统提供的即可.</p>

<p>网络上有很多种方法在用户层写自己的 mutex:</p>

<ul>
  <li><a href="http://preshing.com/20120226/roll-your-own-lightweight-mutex/">roll-your-own-lightweight-mutex</a> 利用 Windows 提供的 semaphore 和 atomic 操作实现的 mutex.</li>
  <li><a href="http://cbloomrants.blogspot.hk/2011/07/07-15-11-review-of-many-mutex.html">Review of many Mutex implementations</a> 很长的一篇文章,总结了很多种 mutex 的实现细节.</li>
</ul>

<p>这里利用
<a href="http://www.haiku-os.org/legacy-docs/benewsletter/Issue1-26.html#Engineering1-26">Benaphore</a>
技术,在 Linux 平台上利用 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_init.html">semaphore</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">atomic</a> 操作实现自己的 C++版本的
lightweight mutex.这里并没有用
<a href="http://www.open-std.org/JTC1/sc22/wg21/docs/papers/2007/n2427.html">C++11 的原子库</a>.所
有代码在 <a href="https://github.com/shishougang/blog_multithreading/tree/master/benaphore_mutex">Github 上</a>.</p>

<p>``` c++
 #include <semaphore.h>
class Benaphore {
 public:
  Benaphore() : counter_(0) {
    sem_init(&amp;semaphore_, 0, 0);
  }
  ~Benaphore() {
    sem_destroy(&amp;semaphore_);
  }
  void Lock() {
    if (__sync_add_and_fetch(&amp;counter_, 1) &gt; 1) {
      sem_wait(&amp;semaphore_);
    }
  }
  void Unlock() {
    if (__sync_sub_and_fetch(&amp;counter_, 1) &gt; 0) {
      sem_post(&amp;semaphore_);
    }
  }
  bool TryLock() {
    return __sync_bool_compare_and_swap(&amp;counter_, 0, 1);
  }</semaphore.h></p>

<p>private:
  long counter<em>;
  sem_t semaphore</em>;
};
```</p>

<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html"><code>__sync_add_and_fetch</code></a>
是一个由 GCC 内部提供的 <em>atomic read-modify-write (RMW)</em> 操作,它把 1 加到
某个数并且返回新的数,在同一时间所有操作由一个线程原子操作完成,其他线程
不能干涉,只能在后等待.这里<code>counter_</code>初始化为 0,第一个线程调用<code>Lock</code>将得
到 1 从<code>__sync_add_and_fetch</code>,然后跳过<code>sem_wait</code>,一旦这个线程占用这个锁,
之后线程都将递增<code>counter_</code>,获得大于 1 的数,从而调用<code>sem_wait</code>等待.</p>

<p>之后,第一个线程完成自己的操作,调用<code>Unlock</code>,<code>__sync_sub_and_fetch</code>的返
回值大于 1 说明有其他线程在等待这个 mutex,调用<code>sem_post</code>唤醒其他线程.</p>

<h3 id="section">底层分析与性能</h3>

<p>上面使用了<code>__sync_add_and_fetch</code>,它编译成<code>lock xadd</code>指令如下.在没有竞
争下的 lock/unlock 操作性能与 pthread mutex 相当.但是在 mutex 多线程竞争情况
下,这个 mutex 性能没有 pthread mutex 好.</p>

<p><img src="/images/blog/2014/multithreading/lightweight_mutex_assembly.png" title="‘lightweight_mutex_assembly’" ></p>

<h3 id="mutex-">增强 Mutex 支持递归</h3>

<p>上面简单的 lightweight mutex 的局限性是它不能递归.也就是同一个线程试图获
取同样的锁两次以上,将造成死锁(deadlock).递归锁在函数调用自己时很有用.比
如在内存管理代码中,可能会遇到如下代码:</p>

<p>``` c++
Realloc(void* ptr, size_t size)
{
    LOCK;</p>

<pre><code>if (ptr == NULL)
{
    return Alloc(size);
}
else if (size == 0)
{
    Free(size);
    return NULL;
}
else
    ... }
</code></pre>

<p>Alloc(size_t size)
{
    LOCK;</p>

<pre><code>... } ```
</code></pre>

<p><code>Lock</code>是个封装好的 C++宏,用来获取锁和自动结果当退出函数.</p>

<p>可以看到,当传递<code>NULL</code>给<code>Realloc</code>,锁被<code>Realloc</code>函数获取,然后第二次被获
取当<code>Alloc</code>被调用.</p>

<p>把它扩展成可递归的锁如下,加入 2 个新成员变量,<code>owner_</code>,存储当前占有线程的
ID(TID),和<code>recursion_</code>,存储递归的层数.基本代码如下:</p>

<p>``` c++
 #include <semaphore.h>
 #include <pthread.h>
 #define LIGHT_ASSERT(x) { if (!(x)) __builtin_trap(); }</pthread.h></semaphore.h></p>

<p>class RecursiveBenaphore {
 public:
  RecursiveBenaphore() : counter<em>(0), owner</em>(0), recursion<em>(0) {
    sem_init(&amp;semaphore</em>, 0, 0);
  }
  ~RecursiveBenaphore() {
    sem_destroy(&amp;semaphore<em>);
  }
  void Lock() {
    pthread_t thread_id = pthread_self();
    if (__sync_add_and_fetch(&amp;counter</em>, 1) &gt; 1) {
      if (!pthread_equal(thread_id, owner<em>)) {
        sem_wait(&amp;semaphore</em>);
      }
    }
    owner_ = thread_id;
    recursion<em>++;
  }
  void Unlock() {
    pthread_t thread_id = pthread_self();
    LIGHT_ASSERT(pthread_equal(thread_id, owner</em>));
    long recur = –recursion<em>;
    if (recur == 0) {
      owner</em> = 0;
    }
    long result = <em>_sync_sub_and_fetch(&amp;counter</em>, 1);
    if (result &gt; 0) {
      if (recur == 0) {
        int sem_value;
        sem_getvalue(&amp;semaphore<em>, &amp;sem_value);
        if (sem_value == 0) {
          sem_post(&amp;semaphore</em>);
        }
      }
    }
  }
  bool TryLock() {
    pthread_t thread_id = pthread_self();
    if (pthread_equal(thread_id, owner<em>)) {
      __sync_add_and_fetch(&amp;counter</em>, 1);
    } else {
      bool result = <em>_sync_bool_compare_and_swap(&amp;counter</em>, 0, 1);
      if (result == false) {
        return false;
      }
      owner_ = thread_id;
    }
    recursion_++;
    return true;
  }</p>

<p>private:
  long counter<em>;
  sem_t semaphore</em>;
  pthread_t owner<em>;
  long recursion</em>;
};
```</p>

<p>如之前一样,第一个线程调用<code>Lock</code>,设置<code>owner_</code>为自己的 TID,增加
<code>recursion_</code>到 1.如果同一个线程再次调用<code>Lock</code>,它将同时增加
<code>recursion_</code>和<code>counter_</code>.</p>

<p>之后,第一个线程完成自己的操作,调用<code>Unlock</code>,同时减少<code>recursion_</code>和<code>counter_</code>,
仅仅调用<code>sem_post</code>唤醒其他线程当<code>recursion_</code>减少到<code>0</code>.如果
<code>recursion_</code>仍然大于 0,意味着当前的线程仍然占有此锁在外层程序.</p>

<p>最后进行<strong>压力测试</strong>,建立一些线程,每个随机获取锁,随机的递归层次.代码在
<a href="https://github.com/shishougang/blog_multithreading/tree/master/benaphore_mutex">Github 上</a>.</p>

<p>一些细节问题:
* 在<code>Unlock</code>中,设置<code>owner_</code>为 0 在调用<code>__sync_sub_and_fetch</code>之前,否则可
  能发生死锁(deadlock).比如,有两个线程 TID 是 111 和 222.
    1. 线程 111 完成操作调用<code>Unlock</code>,先调用<code>__sync_sub_and_fetch</code>把<code>counter_</code>减到 0
    2. 在设置<code>owner_</code>为 0 被中断,线程 222 得到运行,它调用<code>Lock</code>,发现<code>counter_</code>为 0,跳过<code>sem_wait</code>,设置<code>owner_=222</code>,完成<code>Lock</code>操作.
    3. 线程 222 被中断调出,线程 111 重新得到运行,设置<code>owner_</code>为 0,然后完成<code>Unlock</code>操作.
    4. 因为此时<code>owner_</code>为 0,线程 222 不能在递归占用锁,一旦它再次获取锁,形成死锁.</p>

<ul>
  <li>
    <p>在<code>Unlock</code>中,<code>recursion_</code>被拷贝到本地变量一次,之后只本地变量,比如没
有在<code>__sync_sub_and_fetch</code>之后重新读取她.因为在那之后它能被其他线程
已经改变. </p>
  </li>
  <li>
    <p><code>recursion_</code>和<code>owner_</code>没有原子操作.因为它们在调用<code>Lock</code>的
<code>__sync_add_and_fetch</code>和调用<code>Unlock</code>的<code>__sync_sub_and_fetch</code>之间,线
程占有锁,独占<code>recursion_</code>和<code>owner_</code>的读写操作,并拥有所有的 acquire
and release semantics.对<code>recursion_</code>和<code>owner_</code>使用原子操作没必要.因
为在 X86/84 的平台上,<code>__sync_add_and_fetch</code>生成<code>lock xadd</code>的指令,保证
全部的 memory barrier,也就保证 acquire and release semantics.</p>
  </li>
</ul>

<h2 id="mutex-vs-spinlock">Mutex VS Spinlock</h2>

<p>提到 Mutex,往往会提到 Spinlock,因为在使用 Lock 时,会遇到如何在 Mutex 与 Spinlock 之
间选择.那么接下来对比一下两者.</p>

<h3 id="section-1">定义</h3>

<p>Mutex: 如果一个线程试图获取一个 mutex,但是没有成功,因为 mutex 已经被占用,
它将进入睡眠,让其他进程运行,直到 mutex 被其他进程释放.</p>

<p>Spinlock: 如果一个线程试图获取一个 Spinlock, 但是没有成功,它将持续试着
去获取它,直到它最终成功获取,因为它将不允许其他线程运行(然而,操作系统将
强制调度其他线程).</p>

<h3 id="section-2">各自缺点</h3>

<p>Mutex: Mutex 将使得线程睡眠,然后再唤醒它们,两者都是开销比较大的操作,也
就是 context switch 的开销.如果锁只是被其他线程占用非常短的时间,那么时间
花在使的线程睡眠并唤醒它可能超过它使用 spinlock 持续获取锁的时间.</p>

<p>Spinlock: Spinlock 持续获取锁,浪费很多 CPU 时间,如果锁被其他线程占用很长
时间,那么它将浪费很多时间,不如使得线程进入睡眠,让出 CPU.<a href="http://jfdube.wordpress.com/2011/09/24/lessons-learnt-while-spinning/">Spinlock 的确能优化 context switches</a>
但会在没有
<a href="http://en.wikipedia.org/wiki/Priority_inversion">threads priority inversion</a>
的平台上产生副作用.(但一个高优先级的线程自旋一个锁来等待一个低优先级的
线程释放这个锁,就会造成死锁).在没有 Preemption 的 Uniprocessor,使用
spinlock 是没有意义的,当前只有一个线程运行,没有必要保护关键区域,也没有其他线程同时运行,释放锁
给它.</p>

<p>所以在 Linux 下,Spinlock 在 kernel 这样实现:</p>

<ul>
  <li>没有打开<code>CONFIG_SMP</code>和<code>CONFIG_PREEMPT</code>,spinlock 实现代码是空的.</li>
  <li>没有打开<code>CONFIG_SMP</code>,打开<code>CONFIG_PREEMPT</code>,spinlock 仅仅是简单的关闭
preemption,足够来防止任何的
<a href="http://en.wikipedia.org/wiki/Race_condition">races</a>. </li>
  <li>打开<code>CONFIG_SMP</code>,打开<code>CONFIG_PREEMPT</code>,spinlock 实现如下代码,不断检查
lock 是否被其他线程释放: </li>
</ul>

<p><code>c
  extern inline void spin_lock(spinlock_t *plock)
  {
    __asm__ __volatile__(
        spin_lock_string
        :"=m" (__dummy_lock(plock)));
  }
  // Macro spin_lock_string expand
  extern inline void spin_lock(spinlock_t *plock)
 {
  1:
    lock ; btsl ,plock;
    jc 2f;
    .section .text.lock,"ax"
  2: 
    testb ,plock;
    rep;nop;
    jne 2b;
    jmp 1b;
    .previous
 }
</code></p>

<h3 id="section-3">总结</h3>

<table>
  <thead>
    <tr>
      <th>Criteria</th>
      <th>Muutex</th>
      <th>Spinlock</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>机制</td>
      <td>尝试获取锁.若可得到就占有.若不能,就进入睡眠等待.</td>
      <td>尝试获取锁.若可得到就占有.若不能,持续尝试直到获取.</td>
    </tr>
    <tr>
      <td>什么时候使用</td>
      <td>当线程进入睡眠没有伤害.或需要等待一段足够长的时间才能获取锁.</td>
      <td>当线程不应该进入睡眠如中断处理等.当只需等待非常短的时间就能获取锁.</td>
    </tr>
    <tr>
      <td>缺点</td>
      <td>引起 context switch 和 scheduling 开销.</td>
      <td>线程不做任何事情在获取到锁前.浪费 CPU 运行.</td>
    </tr>
  </tbody>
</table>

<p><a href="http://en.wikipedia.org/wiki/Spinlock#Alternatives">大多数操作系统(包括 Solaris,Mac OS X 和 FreeBSD)使用混合的机制叫”adaptive mutex”或”hybrid mutex”</a>.一
个 hybrid mutex 首先行为和 spinlock 一样,如果不能获取锁,持续尝试获取,但过
了一定的时间,它就和 mutex 一样,让线程进入睡眠.<sup id="fnref:f1"><a href="#fn:f1" rel="footnote">1</a></sup>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:f1">
      <p>http://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex<a href="#fnref:f1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈Memory Reordering]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/"/>
    <updated>2014-06-28T22:55:22+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering</id>
    <content type="html"><![CDATA[<h2 id="memory-ordering">Memory ordering</h2>
<p>在我们编写的 C/C++代码和它被在 CPU 上运行,按照一些规则,代码的内存交互会被
乱序.内存乱序同时由编译器(编译时候)和处理器(运行时)造成,都为了使代码运
行的更快.</p>

<p><img src="/images/blog/2014/multithreading/memory_model.png" title="‘memory_ordering’" ></p>

<p>被编译开发者和处理器制造商遵循的中心内存排序准则是:
<blockquote><p>不能改变单线程程序的行为.</p></blockquote></p>

<p>因为这条规则,在写单线程代码时内存乱序被普遍忽略.即使在多线程程序中,它
也被时常忽略,因为有 mutexes,semaphores 等来防止它们调用中的内存乱序.仅当
lock-free 技术被使用时,内存在不受任何互斥保护下被多个线程共享,内存乱序
的影响能被看到.</p>

<p>下面先比较 Weak 和 Strong 的内存模型,然后分两部分,实际内存乱序如何在编译和运行时发生,并如何防止它们.</p>

<!-- more -->

<h2 id="weak-vs-strong-memory-models">Weak VS strong Memory Models</h2>
<p><a href="http://preshing.com/about">Jeff Preshing</a> 在
<a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">Weak vs. Strong Memory Models</a>
中很好的总结了从 Weak 到 Strong 的类型:</p>

<table>
  <thead>
    <tr>
      <th>非常弱</th>
      <th>数据依赖性的弱</th>
      <th>强制</th>
      <th>顺序一致</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DEC Alpha</td>
      <td>ARM</td>
      <td>X86/64</td>
      <td>dual 386</td>
    </tr>
    <tr>
      <td>C/C++11 low-level atomics</td>
      <td>PowerPC</td>
      <td>SPARC TSO</td>
      <td>Java volatile/C/C++11 atomics</td>
    </tr>
  </tbody>
</table>

<h3 id="section">弱内存模型</h3>

<p>在最弱的内存模型中,可能经历所有四种内存乱序
(<a href="http://g.oswego.edu/dl/jmm/cookbook.html">LoadLoad, StoreStore, LoadStore and StoreLoad</a>).任
何 load 或 store 的操作能与任何的其他的 load 或 store 操作乱序,只要它不改变一
个独立进程的行为.实际中,这样的乱序由于编译器引起的指令乱序或处理器本身
处理指令的乱序.</p>

<p>当处理器是弱硬件内存模式,通常称它为 weakly-ordered 或 weak ordering.或说
它有 relaxed memory model. <strong>DEC Alpha</strong> 是
<a href="http://www.mjmwired.net/kernel/Documentation/memory-barriers.txt#2277">最具代表</a>
的弱排序的处理器.</p>

<p>C/C++的底层原子操作也呈现弱内存模型,无论代码的平台是如 x86/64 的强序处理
器.下面章节
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#memory-ordering-at-compile-time">Memory ordering at compile time</a>
会演示其弱内存模型,并说明如何强制内存顺
序来保护编译器乱序.</p>

<h3 id="section-1">数据依赖性的弱</h3>

<p>ARM 和 PowerPC 系列的处理器内存模型和 Alpha 同样弱,除了它们保持
<a href="http://www.mjmwired.net/kernel/Documentation/memory-barriers.txt#305">data dependency ordering</a>.它
意味两个相依赖的<code>load</code>(load A, load B&lt;-A)被保证顺序<code>load B&lt;-A</code>总能在
<code>load A</code>之后.(A data dependency barrier is a partial ordering on interdependent loads only; it is not required to have any effect on stores, independent loads or overlapping loads.)</p>

<h3 id="section-2">强内存模型</h3>

<p>弱和强内存模型区别<a href="http://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/#comment-5903">存
在分歧</a>.<a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">Preshing</a>
总结的定义是:</p>

<p><blockquote><p>一个强硬件内存模型是在这样的硬件上每条机器指令隐性的保证 acquire and release<br/>semantics 的执行.因此,当一个 CPU 核进行了一串写操作,每个其他的 CPU 核看到这<br/>些值的改变顺序与其顺序一致.</p></blockquote></p>

<p>所以也就是保证了四种内存乱序
(<a href="http://g.oswego.edu/dl/jmm/cookbook.html">LoadLoad, StoreStore, LoadStore and StoreLoad</a>)
中的 3 种,除了不保证 StoreLoad 的顺序.基于以上的定义,x86/64 系列处理器基本
就是强顺序的.之后
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#memory-ordering-at-processor-time">Memory ordering at processor time</a>
可以看到 StoreLoad 在 X86/64 的乱序实验.</p>

<h3 id="section-3">顺序一致</h3>

<p>在顺序一致
(<a href="http://en.wikipedia.org/wiki/Sequential_consistency">Sequential consistency</a>)
的内存模型中,没有内存乱序存在.</p>

<p>如今,很难找到一个现代多核设备保证在硬件层 Sequential consistency.也就早
期的 386 没有强大到能在运行时进行任何内存的乱序.</p>

<p>当用上层语言编程时,Sequential consistency 成为一个重要的软件内存模
型.Java5 和之后版本,用<code>volatile</code>声明共享变量.在 C+11 中,可以使用默认的顺
序约束<code>memory_order_seq_cst</code>在做原子操作时.当使用这些术语后,编译器会限
制编译乱序和插入特定 CPU 的指令来指定合适的 memory barrier 类型.</p>

<h2 id="memory-ordering-at-compile-time">Memory ordering at compile time</h2>
<p>看如下代码:</p>

<p><code>c test.c
int A, B;
void test() {
  A = B + 1;
  B = 0;
}
</code></p>

<p>不打开编译器的优化,把它编译成汇编,我们可以看到,<code>B</code>的赋值在<code>A</code>的后面,和
原程序的顺序一样.</p>

<p>``` sh
$ gcc -S -masm=intel test.c</p>

<pre><code>mov	eax, DWORD PTR B
add	eax, 1
mov	DWORD PTR A, eax
mov	DWORD PTR B, 0 ```
</code></pre>

<p>用<code>O2</code>打开优化:</p>

<p>``` sh
$ gcc -S -O2  -masm=intel test.c</p>

<pre><code>mov	eax, DWORD PTR B
mov	DWORD PTR B, 0
add	eax, 1
mov	DWORD PTR A, eax ```
</code></pre>

<p>这次编译器把<code>B</code>的赋值提到<code>A</code>的前面.为什么它可以这么做呢?内存顺序的中心
没有破坏.这样的改变并不影响单线程程序,单线程程序不能知道这样的区别.</p>

<p>但是当编写 lock-free 代码时,这样的编译器乱序就会引起问题.看如下例子,一个
共享的标识来表明其他共享数据是否更新:</p>

<p><code>c
int value;
int updated = 0;
void UpdateValue(int x) {
    value = x;
    update = 1;
}
</code></p>

<p>如果编译器把<code>update</code>的赋值提到<code>value</code>赋值的前面.即使在单核处理器系统中,会
有问题:在两个参数赋值的中间这个线程被中断,使得另外的程序通过<code>update</code>判
断以为<code>value</code>的值已经得到更新,实际上却没有.</p>

<h3 id="compiler-barriers">显性的 Compiler Barriers</h3>
<p>一种方法是用一个特殊的被称为 Compiler Barrier 的指令来防止编译器优化的乱
序.以下
<a href="http://en.wikipedia.org/wiki/Memory_ordering#Compiler_memory_barrier"><code>asm volative</code></a>
是 GCC 中的方法.</p>

<p><code>c test_barrier.c
int A, B;
void test() {
  A = B + 1;
  asm volatile("" ::: "memory");
  B = 0;
}
</code></p>

<p>经过这样的修改,打开优化,<code>B</code>的存储将保持在要求的顺序上.</p>

<p>``` sh
$ gcc -S -O2  -masm=intel test.c</p>

<pre><code>mov	eax, DWORD PTR B
add	eax, 1
mov	DWORD PTR A, eax
mov	DWORD PTR B, 0 ```
</code></pre>

<h3 id="compiler-barriers-1">隐性的 Compiler Barriers</h3>
<p>在 C++11 中原子库中,每个不是 relaxed 的原子操作同时是一个 compiler barrier.</p>

<p><code>c++
int value;
std::atomic&lt;int&gt; updated(0);
void UpdateValue(int x) {
    value = x;
    // reordering is prevented here
    update.store(1, std::memory_order_release);
}
</code></p>

<p>每一个拥有 compiler barrier 的函数本身也是一个 compiler barrier,即使它是
inline 的.</p>

<p><code>c++
int a;
int b;
void DoSomething() {
    a = 1;
    UpdateValue(1);
    b = a + 1;
}
</code></p>

<p>进一步推知,大多数被调用的函数是一个 compiler barrier.无论它们是否包含
memory barrier.排除 inline 函数,被声明为<a href="http://lwn.net/Articles/285332/"><code>pure attribution</code></a>
或当
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0474c/CHDHIEGF.html">link-time code generation</a>
使用时.因为编译器在编译时,并不知道<code>UpdateValue</code>的运行是否依赖于<code>a</code>或会
改变<code>a</code>的值从而影响<code>b</code>,所以编译器不会乱序它们之间的顺序.</p>

<p>可以看到,有许多隐藏的规则禁止编译指令的乱序,也防止了编译器多进一步的代
码优化,所以在某些场景
<a href="https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt">Why the “volatile” type class should not be used</a>,
来让编译器进一步优化.</p>

<h3 id="section-4">无缘由的存储</h3>

<p>有隐形的 Compiler Barriers,同样 GCC 编译器也有无缘由的存储.来自<a href="https://gcc.gnu.org/ml/gcc/2007-10/msg00266.html">这里的实例</a>:</p>

<p>``` c
extern int v;</p>

<pre><code>void
f(int set_v)
{
  if (set_v)
    v = 1;
}
</code></pre>

<p>```</p>

<p>在 i686,GCC 3.3.4–4.3.0 用<code>O1</code>编译得到:</p>

<p><code>sh
            pushl   %ebp
            movl    %esp, %ebp
            cmpl    $0, 8(%ebp)
            movl    $1, %eax
            cmove   v, %eax        ; load (maybe)
            movl    %eax, v        ; store (always)
            popl    %ebp
            ret
</code></p>

<p>在单线程中,没有问题,但多线程中调用<code>f(0)</code>仅仅只是读取 v 的值,但中断后回去
覆盖其他线程修改的值.引起
<a href="http://www.devx.com/cplus/Article/42725">data rate</a>.在新的 C++11 标准中
明确禁止了这样的行为,看<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">最近 C+11 标准进行的 draft</a>§1.10.22 节:</p>

<p><blockquote><p>Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded by this standard.</p></blockquote></p>

<h2 id="memory-ordering-at-processor-time">Memory ordering at processor time</h2>

<p>看一个简单的 CPU 乱序的简单例子,即使在强内存模型的 X86/64 也能看到.有两个
整数<code>X</code>和<code>Y</code>初始是 0,另外两个变量 r1 和 r2 读取它们的值,两个线程并行运行,执
行如下的机器代码:</p>

<p><img class="center" src="/images/blog/2014/multithreading/ordering-example.png" width="370" height="100" title="‘ordering-example’" ></p>

<p>每个线程存储 1 到一个共享变量,然后把对方变量读取到一个变量或一个寄存器中.无
论哪个线程先写 1 到内存,另外个线程读回那个值,意味着最后 r1=1 或 r2=1 或两者
都是.但是 X86/64 是强内存模型,它还是允许<strong>乱序</strong>机器指令.特别,每个线程允许
延迟存储到读回之后.以致最后 r1 和 r2 能同时等于 0–违反直觉的一个结果.因为
指令可能如下顺序执行:</p>

<p><img class="center" src="/images/blog/2014/multithreading/reordering-example.png" width="190" height="100" title="‘reordering-example’" ></p>

<p>写一个实例程序,实际看一下 CPU 的确乱序了指令.源码可以
<a href="https://github.com/shishougang/blog_multithreading/tree/master/memory_reordering">Github 下载</a>.两
个读写的线程代码如下:</p>

<p>``` c++
sem_t begin_sem1;
sem_t begin_sem2;
sem_t end_sem;</p>

<p>int X, Y;
int r1, r2;</p>

<p>void *ThreadFunc1(void *param) {
  MersenneTwister random(1);
  for (;;) {
    sem_wait(&amp;begin_sem1);
    // random delay
    while (random.Integer() % 8 != 0) {
    }
    X = 1;
    asm volatile(“” ::: “memory”);  // prevent compiler ordering
    r1 = Y;
    sem_post(&amp;end_sem);
  }
  return NULL;
}</p>

<p>void *ThreadFunc2(void *param) {
  MersenneTwister random(2);
  for (;;) {
    sem_wait(&amp;begin_sem2);
    // random delay
    while (random.Integer() % 8 != 0) {
    }
    Y = 1;
    asm volatile(“” ::: “memory”);  // prevent compiler ordering
    r2 = X;
    sem_post(&amp;end_sem);
  }
  return NULL;
}
```</p>

<p>随机的延迟被插入在存储的开始处,为了交错线程的开始时间,以来达到重叠两个线程
的指令的目的.随机延迟使用线程安全的<code>MersenneTwister</code>类.汇编代码<code>asm
volatile("" ::: "memory");</code>如上节所述只是用来
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#memory-ordering-at-compile-time">防止编译器的乱序</a>,
因为这里是要看 CPU 的乱序,排除编译器的乱序影响.</p>

<p>主线程如下,利用
<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sem_init.html">POSIX 的 semaphore</a>
同步它与两个子线程的同步.先让两个子线程等待,直到主线程初始化<code>X=0</code>和
<code>Y=0</code>.然后主线程等待,直到两个子线程完成操作,然后主线程检查<code>r1</code>和<code>r2</code>的
值.所以 semaphore 防止线程见的不同步引起的内存乱序,主线程代码如下:</p>

<p>``` c++
int main(int argc, char *argv[]) {
  sem_init(&amp;begin_sem1, 0, 0);
  sem_init(&amp;begin_sem2, 0, 0);
  sem_init(&amp;end_sem, 0, 0);</p>

<p>pthread_t thread[2];
  pthread_create(&amp;thread[0], NULL, ThreadFunc1, NULL);
  pthread_create(&amp;thread[1], NULL, ThreadFunc2, NULL);</p>

<p>int detected = 0;
  for (int i = 1; ; ++i) {
    X = 0;
    Y = 0;
    sem_post(&amp;begin_sem1);
    sem_post(&amp;begin_sem2);
    sem_wait(&amp;end_sem);
    sem_wait(&amp;end_sem);
    if (r1 == 0 &amp;&amp; r2 == 0) {
      detected++;
      printf(“%d reorders detected after %d iterations\n”, detected, i);
    }
  }
  return 0;
}
```</p>

<p>在 Intel i5-2435M X64 的 ubuntu 下运行一下程序:</p>

<p><code>sh
1 reorders detected after 2181 iterations
2 reorders detected after 4575 iterations
3 reorders detected after 7689 iterations
4 reorders detected after 22215 iterations
5 reorders detected after 60023 iterations
6 reorders detected after 60499 iterations
7 reorders detected after 61639 iterations
8 reorders detected after 62243 iterations
9 reorders detected after 67998 iterations
10 reorders detected after 68098 iterations
11 reorders detected after 71179 iterations
12 reorders detected after 71668 iterations
13 reorders detected after 72417 iterations
14 reorders detected after 73970 iterations
15 reorders detected after 78227 iterations
16 reorders detected after 81897 iterations
17 reorders detected after 82722 iterations
18 reorders detected after 85377 iterations
...
</code></p>

<p>差不多每 <strong>4000</strong> 次的迭代才发现一次 CPU 内存乱序.所以多线程的 bug 是多么难
发现.那么如何消除这些乱序.至少有如下两种方法:</p>

<ol>
  <li>让两个子线程在同一个 CPU 核下运行.(没有可移植性方法,如下是 linux 平台的).</li>
  <li>使用 CPU 的 memory barrier 防止它的乱序.</li>
</ol>

<h3 id="lock-to-one-processor">Lock to one processor</h3>
<p>让两个子线程在同一个 CPU 核下运行,代码如下:</p>

<p><code>c++
  cpu_set_t cpus;
  CPU_ZERO(&amp;cpus);
  CPU_SET(0, &amp;cpus);
  pthread_setaffinity_np(thread[0], sizeof(cpu_set_t), &amp;cpus);
  pthread_setaffinity_np(thread[1], sizeof(cpu_set_t), &amp;cpus);
</code></p>

<h3 id="place-a-memory-barrier">Place a memory barrier</h3>

<p>防止一个 Store 在 Load 之后的乱序,需要一个 StoreLoad 的 barrier.这里使用
<code>mfence</code>的一个全部 memory barrier,防止任何类型的内存乱序.代码如下:</p>

<p><code>c++
void *ThreadFunc1(void *param) {
  MersenneTwister random(1);
  for (;;) {
    sem_wait(&amp;begin_sem1);
    // random delay
    while (random.Integer() % 8 != 0) {
    }
    X = 1;
    asm volatile("mfence" ::: "memory");  // prevent CPU ordering
    r1 = Y;
    sem_post(&amp;end_sem);
  }
  return NULL;
  }
</code></p>

<h2 id="more">More</h2>

<ol>
  <li><a href="http://www.cl.cam.ac.uk/~pes20/weakmemory/">University of Cambridge 整理的文档和论文</a></li>
  <li><a href="http://lwn.net/Articles/470681/">Paul McKenney 概括他们做的一些工作和工具</a></li>
  <li><a href="http://www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&amp;tag=preshonprogr-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0123973376">The Art of Multiprocessor Programming</a></li>
  <li><a href="http://www.amazon.com/C-Concurrency-Action-Practical-Multithreading/dp/1933988770/ref=pd_sim_b_2?ie=UTF8&amp;refRID=1QTX99XZAM6HKVG7X0G2">C++ Concurrency in Action: Practical Multithreading</a></li>
  <li><a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.2011.01.02a.pdf">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a></li>
  <li><a href="https://gcc.gnu.org/wiki/Atomic/GCCMM">The C++11 Memory Model and GCC</a></li>
</ol>

<h2 id="summarization">Summarization</h2>
<ol>
  <li>有两种内存乱序存在:编译器乱序和 CPU 乱序.</li>
  <li>如何防止编译器乱序.</li>
  <li>如何防止 CPU 乱序.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Double-Checked Locking Works in C++11]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/22/double-checked-locking-works-in-c-plus-plus-11/"/>
    <updated>2014-06-22T14:07:01+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/22/double-checked-locking-works-in-c-plus-plus-11</id>
    <content type="html"><![CDATA[<p>在
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">浅谈设计模式六: 单例模式(Singleton)</a>
中提到 double-checked locking pattern(DCLP)来实现 Singleton 设计模式，但是
在 C++11 之前，没有安全方法在可移植的 C++中去实现它．具体原因可见
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
或 Scott Meyers 和 Andrei Alexandrescu 发布的原文
<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">“C++ and the Perils of Double-Checked Locking”</a>
．</p>

<p>C++11 引入了新的内存模型和线程库，使得能在 C++中实现可移植的 DCLP．本文说
明如何实现它．</p>

<!-- more -->

<h2 id="double-checked-locking">什么是 Double-Checked Locking</h2>
<p>在
<a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
很好的介绍什么是 DCLP,这里稍作回顾.</p>

<p>线程安全的方式实现 Signleton 模式如下:</p>

<p><code>c++ singleton.cc
Singleton* Singleton::instance() {
  Lock lock;    // acquire lock (params omitted for simplicity)
  if(pInstance == NULL) {
    pInstance = new Singleton();
  }
  return pInstance;
  }  // release lock (via Lock destructor)
</code></p>

<p>每次获取 Singleton 都要获取一个锁，但是实际上，我们只有当初始化 pInstance 时才需要一个锁。也就是只发生在第一次调用 instance 时。如果在一个程序运行时， instance 被调用了 n 次，我们只需要锁在第一次调用时。当我们知道那 n-1 次锁是没必要的.</p>

<p>DCLP 的关键点是发现，大多数 instance 的调用将看到 pInstance 是非空的，因此根本没必要去尝试初始化它。因此，DCLP 判断 pInstance 是否为空在尝试获取锁前。只有当判断成功（ pInstance 还没有被初始化）才去获取锁，然后之后这个判断在此进行一次确保 pInstance 是仍然空的。（所以名字叫双重检查锁）。第二个检查是有必要的，因为从上可以看到，另外的线程可能碰巧初始化了 pInstance 在 pInstance 被第一次判断和获取锁之间。</p>

<p><code>c++ singleton-dclp.cc
Singleton* Singleton::instance() {
  Singleton *tmp = pInstance;
  ...  // need memory barrier
  if(tmp == 0) { // 1st test
  Lock lock;
  tmp = pInstance;
  if(tmp == 0) { // 2nd test
    tmp  = new Singleton;
  ...  // need memory barrier
    pInstance = tmp;
  }
  }
return pInstance;
}
</code></p>

<p><a href="http://dreamrunner.org/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6/">单例模式(Singleton)</a>
说明了各种不安全实现的缺陷,主要原因是 1) 编译器的乱序编译 和 2) CPU 的乱
序执行指令.所以安全的实现依靠 memory barrier,防止它们的乱序,使得在多线
程中得到同步,C++11 之前没有可移植的 C/C++函数,但现在,C++11 有了.</p>

<h2 id="c11--acqure--release-fence">使用 C++11 的 Acqure 和 Release Fence</h2>
<p>使用 Acqure 和 Release Fence 来实现它,并且保证对实例<code>pInstance</code>进行原子操
作,把它定义为<code>atomic</code>类型,并用<code>memory_order_relaxed</code>操作.(Relaxed
ordering: there are no synchronization or ordering constraints, only
atomicity is required of this operation.)如下实现代码.</p>

<p>``` c++
std::atomic&lt;Singleton *&gt; Singleton::m_pInstance;
std::mutex Singleton::m_mutex;</p>

<p>Singleton* Singleton::instance() {
  Singleton *tmp = m_pInstance.load(std::memory_order_relaxed);
  std::atomic_thread_fence(std::memory_order_acquire);
  if(tmp == nullptr) {
    std::lock_guard<std::mutex> lock(m_mutex);
    tmp = m_pInstance.load(std::memory_order_relaxed);
    if(tmp == nullptr) {
      tmp  = new Singleton;
      std::atomic_thread_fence(std::memory_order_release);
      m_pInstance.store(tmp, std::memory_order_relaxed);
    }
  }
  return m_pInstance;
}
```</std::mutex></p>

<p>在多核系统中,这整个代码也是稳健的,因为 memory fences 在多个线程间建立了
同步的关系.<code>Singleton::m_pInstance</code>作为 guard variable,singleton 变
量自身成为 payload.</p>

<p>如果没有这层同步关系的话,就不能保证第一个线程的所有写操作(这里就是
singleton 实力的创建)被第二个线程读取到,即使<code>m_pInstance</code>已经被第二个线
程能看到.</p>

<h2 id="c11-">使用 C++11 的底层的内存顺序约束</h2>
<p>在 C++11 中也可以在单元操作时附加底层的内存顺序约束来达到同样的目的.一个
write-release 能同步于一个 read-release.</p>

<ol>
  <li>
    <p><code>memory_order_acquire</code>: A load operation with this memory order performs the acquire operation on the affected memory location: prior writes made to other memory locations by the thread that did the release become visible in this thread.</p>
  </li>
  <li>
    <p><code>memory_order_release</code>: A store operation with this memory order performs the release operation: prior writes to other memory locations become visible to the threads that do a consume or an acquire on the same location.</p>
  </li>
</ol>

<p>``` c++
std::atomic&lt;Singleton *&gt; Singleton::m_pInstance;
std::mutex Singleton::m_mutex;</p>

<p>Singleton* Singleton::instance() {
  Singleton *tmp = m_pInstance.load(std::memory_order_acquire);
  if(tmp == nullptr) {
    std::lock_guard<std::mutex> lock(m_mutex);
    tmp = m_pInstance.load(std::memory_order_relaxed);
    if(tmp == nullptr) {
      tmp  = new Singleton;
      m_pInstance.store(tmp, std::memory_order_release);
    }
  }
  return m_pInstance;
}
```</std::mutex></p>

<p>从深层分析来看,这种形式的免锁机制的同步比上面单独 memory fences 来的约束
更小.这种形式的操作只意味在这个操作周围防止内存乱序,而 memory fences 意
味着在一块区域内防止内存乱序.更多细节参考 preshing 的
<a href="http://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/">Acquire and Release Fences Don’t Work the Way You’d Expect</a>
的分析.
## 使用 C++11 的 Sequentially-consistent ordering
C++11 还提供了其他的方法来写 lock-free 的代码.当在 atomic 操作函数中忽略
<code>std::memory_order</code>参数项,那么默认值是<code>std::memory_order_seq_cst</code>,使得
所有原子参数成为
<a href="http://en.wikipedia.org/wiki/Sequential_consistency">sequentically consistent(SC)</a>
原子.通过 SC 原子性,整个算法保证 sequentically consistent 只要没有 <a href="http://www.devx.com/cplus/Article/42725">data races</a>.</p>

<p>``` c++
std::atomic&lt;Singleton *&gt; Singleton::m_pInstance;
std::mutex Singleton::m_mutex;</p>

<p>Singleton* Singleton::instance() {
  Singleton *tmp = m_pInstance.load();
  std::atomic_thread_fence(std::memory_order_acquire);
  if(tmp == nullptr) {
    std::lock_guard<std::mutex> lock(m_mutex);
    tmp = m_pInstance.load(std::memory_order_relaxed);
    if(tmp == nullptr) {
      tmp  = new Singleton;
      std::atomic_thread_fence(std::memory_order_release);
      m_pInstance.store(tmp);
    }
  }
  return m_pInstance;
}
```</std::mutex></p>

<p>SC 的原子性可能更容易理解.权衡点就是它产生的机器代码没有之前做法的高效.比
如如下是 Gcc 4.8.2 intle X64 对上面代码产生的机器代码,通过<code>g++ -O2 -std=c++11 -S</code>.
<img src="/images/blog/2014/multithreading/sc.png" title="sc’" ></p>

<p>因为使用了 SC 原子性,对<code>m_pInstance</code>的存储实现使用了<code>mfence</code>指令,起到一
个在 X64 上的 full memory fence.这是个更严格的指令想对于 DCLP 在 X64 上的实际
需求.一个普通的<code>mov</code>足以胜任.但也无关紧要,因为<code>mfence</code>指令也仅仅执行一
次而已,就在创建 singleton 的实例的代码路径上.</p>

<h2 id="more">More</h2>
<p>使用 <a href="http://preshing.com">Preshing</a> 的小型可移植的 lock-free 库,在没有 C++11
的支持下,使用它的 <a href="http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/#using-mintomic-fences">Mintomic Fences 实现 DCLP</a>.</p>

<p>更多关于 C++11 的 multithreading 库的详解见之后的文章.</p>
]]></content>
  </entry>
  
</feed>
