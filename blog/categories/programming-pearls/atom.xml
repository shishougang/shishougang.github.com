<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming Pearls | (learn&think)]]></title>
  <link href="http://shishougang.github.com/blog/categories/programming-pearls/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-05-17T23:48:05+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column8]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/17/column8/"/>
    <updated>2014-05-17T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/17/column8</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">问题与算法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
给出数组中找出连续子数组最大和。
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">1</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
直接算每个子区间的和并比较得出最大值。算法复杂度 O(n<sup>3</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg1</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; num.size(); ++j) {
      sum = 0;
      <span style="color: #00ffff;">for</span> (k = i; k &lt;= j; k++) {
        sum += num[k];
        <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
          max_sofar = sum;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">2</h4>
<div class="outline-text-4" id="text-1-1-2">
</div><div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">2.1</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
因为x[i..j]直接的和可以基于x[i..j-1]的和算出，不用重头开始算。算法复杂度 O(n<sup>2</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    sum = 0;
    <span style="color: #00ffff;">for</span> (j = i; j &lt; num.size(); ++j) {
      sum += num[j];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2">2.2</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
先算出x[0..i]区间的和为 <code>cum_vector[i]</code> ，那么x[i..j]区间的和就是
<code>cum_vector[j] - cum-vector[i-1]</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2b</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; <span style="color: #eedd82;">cum_vector</span>(num.size() + 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  cum_vector[0] = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    cum_vector[i] = cum_vector[i - 1] + num[i];
  }
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = i; j &lt; cum_vector.size(); ++j) {
      sum = cum_vector[j] - cum_vector[i - 1];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">3</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Divide-and-Conquer算法。
</p>
<ol class="org-ol">
<li>求整个数组的子数组和，可以分成前面一半和后面一半
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_1.jpg" title="'column8_3_1'" >

<ol class="org-ol">
<li>求出前半部分的最大子数组和后半部分的最大子数组和
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_2.jpg" title="'column8_3_2'" >
<p>
[[./images/column8<sub>3</sub><sub>2</sub>.jpg]
</p>

<ol class="org-ol">
<li>求出两部分中间连着的子数组最大和
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_3.jpg" title="'column8_3_3'" >

<ol class="org-ol">
<li>最后比较这3部分和就能得出整个个数组的子数组最大和
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3Core</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #00ffff;">if</span> (l &gt; u) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">if</span> (l == u) {
    <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">max</span>&lt;<span style="color: #98fb98;">float</span>&gt;(num[l], 0);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = (l + u) / 2;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">lmax</span>, <span style="color: #eedd82;">rmax</span>, <span style="color: #eedd82;">sum</span>;
  lmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m; i &gt;= l; --i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; lmax) {
      lmax = sum;
    }
  }
  rmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m + 1; i &lt;= u; ++i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; rmax) {
      rmax = sum;
    }
  }
  <span style="color: #00ffff;">return</span> max(lmax + rmax, max(FindMaxSubvectorAlg3Core(num, l, m),
                              FindMaxSubvectorAlg3Core(num, m + 1, u)));
}

<span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #00ffff;">return</span> FindMaxSubvectorAlg3Core(num, 0, num.size() - 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">4</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
假定已经解决了x[0..i-1]的情况，那么如何扩展到x[0..i]的情况，只多了x[i]
元素？
</p>

<ol class="org-ol">
<li>解决了x[0..i-1]的情况，有这区间的最大子数组和 <code>max_sofar</code> ，和必须以
x[i-1]结尾的子数组最大和;
</li>
<li>到x[0..i]的情况，就要把必须以x[i-1]结尾的子数组最大和与x[i]相加，如果以x[i-1]结尾的子数组为负数的话，加了反而减少总和。所以此种情况以
x[i]的和就是x[i];
</li>
<li>最后把以x[i]与在区间x[0..i-1]的最大子数组和 <code>max_sofar</code> 比较，就能解决
x[0..i]的情况;
</li>
<li>如此一直扩展到x[0..n]算出整个数组的最大子数组和。
</li>
</ol>

<p>
只扫描一遍，算法复杂度O(n)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg4</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">max_sofar</span>, <span style="color: #eedd82;">max_ending_here</span>;
  max_sofar = max_ending_here = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num.size(); ++i) {
    max_ending_here += num[i];
    <span style="color: #00ffff;">if</span> (max_ending_here &lt; 0) {
      max_ending_here = 0;
    }
    <span style="color: #00ffff;">if</span> (max_ending_here &gt; max_sofar) {
      max_sofar = max_ending_here;
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">算法设计技巧</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>保存状态防止重复计算。
</li>
<li>预处理信息到适当的数据结构中来加快之后的计算。比如先建立堆，先排序等。
</li>
<li>分而治之，把大问题分成类似的小问题解决。
</li>
<li>扫描算法。比如解出了x[0..i-1]如何扩展到x[0..i].
</li>
<li>累积。
</li>
<li>确定问题的算法复杂度下界。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">10</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>初始化累积和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code> ， 那么要x[l..u]
区间的和为0的话，cum[l-1] = cum[u]
</li>
<li>排序cum数组;
</li>
<li>扫描排序好的数组cum，找出最相近的相邻数组元素即得到结果。
</li>
</ol>

<p>
算法复杂度 O(n) + O(nlogn) + O(n-1) = O(nlogn).
</p>

<p>
找出子数组和与一个特定值r最相近，算法类似，只是step3找出与r最相近的相邻数组元素。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">11</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>累积收费和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code>
</li>
<li>计算l和u关卡之间的收费 cum[u]-cum[l]
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column7]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/14/column7/"/>
    <updated>2014-05-14T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/14/column7</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一天中密西西比河的流量是多少？
</p>

<p>
作者估算：河口宽度大约1 mile，大约1/250英里深，他猜测流速是5mile每小时或
120mile每天。
</p>

<p>
1mile * 1/250mile * 120 miles/day = 1/2 mile<sup>3</sup>/day
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">基本技巧</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">两个答案好于一个</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
估算中密西西比河的流域是 1000 × 1000 miles， 一年雨量大约1英尺，（1/5000英里每年）。
1000miles * 1000miles * 1/5000 mile/year = 200 mile<sup>3</sup>/year
200mile<sup>3</sup>/year/400days/year = 1/2 mile<sup>3</sup>/day
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">快速检查</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>Rule1： 相加的单位与原来一样。
</li>
<li>Rule2： 相乘的单位是单位的相乘。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">经验法则</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
72法则。
</p>

<p>
假如一笔钱以年利率百分比r存y年。如果r×y=72,那么钱将成2倍。这个估算大体正确，存1000以6%的年利率存12年之后为2012.
</p>

<p>
72法则对估算指数增长非常实用。双倍对于程序员来说很熟悉：2<sup>10</sup>=1024，10
倍双倍就是1thousand，20个双倍就是1million。
</p>

<p>
假如一个指数型复杂度的程序花10秒解决一个n=40的问题，每把n增加1就增加
12%的运行时间。72法则告诉我们，运行时间成2倍当n增加6，也就是1000倍（2<sup>10）当n增加60</sup>(6*10)。所以当n=100时，程序花10,000秒，也就几小时。当n
增加到160,时间成为10<sup>7</sup> 秒,那这时间大约是多少呢？
</p>

<p>
很难记住一年的时间是3.155×10<sup>7</sup> 秒，另一方面，很难忘记Tom Duff的实用经验准则，1%多的误差：
</p>

<strong> $\pi$ 秒是1纳世纪。</strong> ($\pi$ seconds is a nanocentury.)
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">练习</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
不断练习提高自己的估算技巧。
</p>

<p>
书中估算密西西比河的流量并不是特别技巧好，比如直接估测出流速是5mile每小时，很难直观想出这个数字。
</p>

<p>
推荐<a href="http://book.douban.com/subject/4904724/">《这也能想到?——巧妙解答无厘头问题》</a> 这本书，全书都是估算题目，
</p>
<ol class="org-ol">
<li>明白估算的目标精确度只需要达到一个数量级，和真实数据不超过10倍就是比较好的估算。
</li>
<li>估算一个东西的范围的关键是几何平均数。比如这里流量最小1mile每小时，最大10mile每小时，那么估算它为3mile每小时（几何平均）。比如地球的密度，比水大，比铁小，取它们的几何平均。
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">利特尔法则(Little's law)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个稳定系统中长期平均存在的用户数是平均用户离开系统的速率与用户平均在系统的时间的乘积。
</p>

<p>
例如：一个地方能容纳60个人，你准备呆在那大约3小时，所以人们进入这个地方的速率是20个每小时。现在队伍中有20个人，那么意味着你将等1小时左右。
</p>

<p>
或多用户系统的回复时间公式：假定用户连接到回复时间是r的系统中的平均思考时间是z，每个用户或思考或等待系统回复，系统中的任务数大约固定在n，可以测得系统的吞吐量是x（每时间单位的任务数），由Little's law得，
n=x*(z+r)。可以算得r=n/x - z。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
密西西比河的流速大概是5mile每小时或120mile每天，Passaic River应该是
200miles每天。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
软盘有1.44Mbytes，
</p>

<p>
一秒中最少可以打1byte，最多10bytes，也就是每分钟最少60bytes和最多600bytes，它们的几何平均是200byte，认为大约每分钟打字200byte，
1.44*10<sup>6</sup>/200=7200 minutes。
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">5</h3>
<div class="outline-text-3" id="text-2-3">
<p>
证明72法则。
</p>

<p>
若（1+x%）<sup>N</sup> = 2，证明x*N约等于72
</p>

<p>
(1+x%)<sup>N</sup>=2 ==&gt; N*ln(1+x%)=ln2
</p>

<p>
对ln(1+x)泰勒展开是ln(1+x) = x-(x<sup>2</sup>)/2 + (x<sup>3</sup>)/3 + &#x2026;
</p>

<p>
N*ln(1+x%)=ln2 ==&gt; N*x = ln2 * 100 = 69.3
</p>

<p>
因为忽略了-(x<sup>2</sup>)/2这个项，所以N*x约等于72。
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">6</h3>
<div class="outline-text-3" id="text-2-4">
<p>
72/1.33=54, 所以到2052年人口是2倍，就是5.9×2=11.8 billion。那么2050年大约就是11.5 billion。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">10</h3>
<div class="outline-text-3" id="text-2-5">
<p>
估算城市的死亡率。
</p>

<p>
假定大家平均生命是70年，根据Little's law，那么每年的死亡率就是1/70=1.4%的城市人口。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">11</h3>
<div class="outline-text-3" id="text-2-6">
<p>
证明利特尔法则(Little's law)。
</p>

<img src="/images/blog/2014/programmingpearls/column7_11.jpg" title="'column7_11'" >

<p>
时间T进入个数为N(T)，那么到达速率 &lambda;(T) = N(T)/T;
</p>

<p>
时间T离开个数为C(T)，那么离开速率 X = C(T)/T;
</p>

<p>
系统中，时间T中堆积的个数平均为阴影部分A(T),那么平均等待的个数为L(T) =
A(T)/T;
</p>

<p>
时间T离开个数为C(T)，时间T中堆积的个数A(T)，那么每个的等待时间是
W(T)=A(T)/C(T)。
</p>

<p>
可以得到L(T)=C(T)W(T),均衡系统&lambda;(T)=C(T),即L(T)=&lambda;(T)W(T)。
</p>

<p>
完善的数学证明这里：
<a href="http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf">http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf</a>
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">12</h3>
<div class="outline-text-3" id="text-2-7">
<p>
美国报纸说25美分的硬币平均寿命是30年。你如何检测这个声明？
</p>

<p>
硬币制造厂每年平均最小为每个人制造1枚25美分的硬币，最多不会超过100枚，那么几何平均就是10枚，加入它的平均寿命是30年，那么平均每人就有300枚25
美分的硬币在手里，算上手头，家里抽屉，公司抽屉所有的25美分，应该不会超过300枚，所以这个声明的数字有点偏高。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column3]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/13/column3/"/>
    <updated>2014-05-13T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/13/column3</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
<p>
主旨是：don't wirte a big program when a little one will do.
</p>

<!-- more -->

<p>
一些原则：
</p>
<ol class="org-ol">
<li>重构重复的代码到数组。
</li>
<li>封装复杂的结构。
</li>
<li>尽可能使用高级工具。
</li>
<li>让数据来构建程序。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>建立一张税收表格，包括1.这个一行数据范围的最低收入; 2.税收的基本费用; 和3.税收比率。
</li>
<li>用给定税收，二分搜索所处范围，也就是表格的哪一栏。用公式算出税收。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
编写标语函数，输入一个大写字母，输出一个字符数组，该字符数组用字符图形方式描绘该字母
</p>

<ol class="org-ol">
<li>用一个定义的模板语言为每个字母定义标语的格式，存入一个table中;
</li>
<li>写一个对这个自定义模板语言的解析程序，把它解析成打印标语;
</li>
<li>输入一个单词，直接读取table相应的模板格式，用解析程序解析。
</li>
</ol>

<p>
如字母I如下，可以把它编码成：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 lines 9 X
6 lines 3 blank 3 X 3 blank
3 lines 9 X
</pre>
</div>
<p>
或更简化：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 9 X
6 3 b 3 x 3 b
3 9 x
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">4</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Date</span> {
  <span style="color: #87cefa;">Date</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_in</span>) {
    year = year_in;
    month = month_in;
    day = day_in;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>;
};

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMonthDays</span>[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">KDaysOfWeek</span> = 7;
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">YearDays</span> {
  <span style="color: #eedd82;">kNormYearDays</span> = 365,
  <span style="color: #eedd82;">kLeapYearDays</span> = 366,
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsLeapYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">year</span>) {
  <span style="color: #00ffff;">if</span> ((year % 400 == 0) ||
      (((year % 4) == 0) &amp;&amp; (year % 100) != 0)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MonthDaysOfYear</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = kMonthDays[month];
  <span style="color: #00ffff;">if</span> (month == 2 &amp;&amp; IsLeapYear(year)) {
    days++;
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysOfYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  days += date.day;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; date.month; ++i) {
    days += MonthDaysOfYear(date.year, i);
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysBetween</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_pre</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_next</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_</span> = date_pre.year; year_ &lt; date_next.year; ++year_) {
    days += (IsLeapYear(year_) ? kLeapYearDays : kNormYearDays);
  }
  days += DaysOfYear(date_next);
  days -= DaysOfYear(date_pre);
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintCalendar</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">calendar</span>) {
  printf(<span style="color: #ffa07a;">"Sun Mon Tue Wed Thu Fri Sat\n"</span>);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; KDaysOfWeek - calendar[0].size(); ++i) {
    printf(<span style="color: #ffa07a;">"    "</span>);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; calendar.size(); ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; calendar[i].size(); ++j) {
      printf(<span style="color: #ffa07a;">"%-4d"</span>, calendar[i][j]);
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DayOfWeek</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">kFirstDate</span>(1900, 1, 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Mon</span>
  <span style="color: #00ffff;">return</span> (DaysBetween(kFirstDate, date) % 7 + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">CalendarOfMonth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">calendar</span>) {
  <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">first_of_month</span>(year, month, 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_of_week</span> = DayOfWeek(first_of_month);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; MonthDaysOfYear(year, month); ++i) {
    temp.push_back(i);
    <span style="color: #00ffff;">if</span> ((day_of_week + i) % KDaysOfWeek == 6) {
      calendar-&gt;push_back(temp);
      temp.clear();
    }
  }
  printf(<span style="color: #ffa07a;">"Year:%d Month:%d\n"</span>, year, month);
  PrintCalendar(*calendar);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
查找后缀连字符的连接。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">kHyphWords</span>[] = {<span style="color: #ffa07a;">"et-ic"</span>, <span style="color: #ffa07a;">"al-is-tic"</span>, <span style="color: #ffa07a;">"s-tic"</span>, <span style="color: #ffa07a;">"p-tic"</span>, <span style="color: #ffa07a;">"-lyt-ic"</span>,
                      <span style="color: #ffa07a;">"ot-ic"</span>, <span style="color: #ffa07a;">"an-tic"</span>, <span style="color: #ffa07a;">"n-tic"</span>, <span style="color: #ffa07a;">"c-tic"</span>, <span style="color: #ffa07a;">"at-ic"</span>,
                      <span style="color: #ffa07a;">"h-nic"</span>, <span style="color: #ffa07a;">"n-ic"</span>, <span style="color: #ffa07a;">"m-ic"</span>, <span style="color: #ffa07a;">"l-lic"</span>, <span style="color: #ffa07a;">"b-lic"</span>,
                      <span style="color: #ffa07a;">"-clic"</span>, <span style="color: #ffa07a;">"l-ic"</span>, <span style="color: #ffa07a;">"h-ic"</span>, <span style="color: #ffa07a;">"f-ic"</span>, <span style="color: #ffa07a;">"d-ic"</span>,
                      <span style="color: #ffa07a;">"-bic"</span>, <span style="color: #ffa07a;">"a-ic"</span>, <span style="color: #ffa07a;">"-mac"</span>, <span style="color: #ffa07a;">"i-ac"</span>};

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">reverse_hyphs</span> = <span style="color: #7fffd4;">NULL</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseHypenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">reverse_word</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">kHypen</span> = <span style="color: #ffa07a;">'-'</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = strlen(word) - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0, j = 0; i &lt;= len; ++i) {
    <span style="color: #00ffff;">if</span> (word[len - i] == kHypen)
      <span style="color: #00ffff;">continue</span>;
    reverse_word[j++] = word[len - i];
  }
  reverse_word[j] = <span style="color: #ffa07a;">'\0'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RerverseWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">string</span> *<span style="color: #eedd82;">reverse_word</span>) {
  *reverse_word = word;
  reverse(reverse_word-&gt;begin(), reverse_word-&gt;end());
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PreProcessHyphenation</span>() {
  <span style="color: #00ffff;">if</span> (reverse_hyphs != <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  } <span style="color: #00ffff;">else</span> {
    reverse_hyphs = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;string&gt;();
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(kHyphWords) / <span style="color: #00ffff;">sizeof</span>(kHyphWords[0]);
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMaxLen</span> = 10;
      <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">reverse_word</span>[kMaxLen];
      ReverseHypenation(kHyphWords[i], reverse_word);
      reverse_hyphs-&gt;push_back(<span style="color: #98fb98;">string</span>(<span style="color: #eedd82;">reverse_word</span>));
    }
  }
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsBeginWith</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">begin_letter</span>) {
  <span style="color: #00ffff;">if</span> (word.size() &lt; begin_letter.size()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; begin_letter.size(); ++i) {
    <span style="color: #00ffff;">if</span> (begin_letter[i] != word[i]) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">FindHyphenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  PreProcessHyphenation();
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">reverse_word</span>;
  RerverseWord(word, &amp;reverse_word);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; reverse_hyphs-&gt;size(); ++i) {
    <span style="color: #00ffff;">if</span> (IsBeginWith(reverse_word, reverse_hyphs-&gt;at(i))) {
      <span style="color: #00ffff;">return</span> string(kHyphWords[i]);
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column2]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/11/column2/"/>
    <updated>2014-05-11T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/11/column2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一个文件中有4十亿的32位整数，已随机排序，如何找如一个不在这个文件中的
32位数？有足够的内存如何解决？如果你可以用很多外部存储文件但是只有几百个字节的主内存，如何解决？
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">足够的内存</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
利用Column1的比特映射技能，
</p>
<ol class="org-ol">
<li>把所有的数一一映射到内存中的比特位;
</li>
<li>扫描比特位，是0的就是确实的数所在位置。
</li>
</ol>

两次扫描，复杂度 $\mathcal{O}(N)$。
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">有限的内存</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Ed Reingold 的方法：
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是0，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是1，Step 3选组组1;
若相等，随便选一组（两组中都有缺失数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>

<p>
这里以两组内存数组代表外部存储文件：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">find_missing</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nbits</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_zero</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_one</span>[len / 2 + 1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = len;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span> = 0;
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p_in</span> = array;

  <span style="color: #00ffff;">while</span> (nbits--) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_zero</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count_leading_one</span> = 0;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">leading_bit</span> = 1 &lt;&lt; nbits;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">if</span> (p_in[i] &amp; leading_bit) {
        leading_one[count_leading_one++] = p_in[i];
      } <span style="color: #00ffff;">else</span> {
        leading_zero[count_leading_zero++] = p_in[i];
      }
    }
    <span style="color: #00ffff;">if</span> (count_leading_one &lt;= count_leading_zero) {
      res |= leading_bit;
      n = count_leading_one;
      p_in = leading_one;
    } <span style="color: #00ffff;">else</span> {
      n = count_leading_zero;
      p_in = leading_zero;
    }
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">B</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在第i个位置翻转一个n个元素的一维数组。比如n=8,i=3,数组abcdefgh翻转到
defghabc。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Juggling法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
是把前面的元素翻转到后面，逐个移位，翻转位为k：
</p>
<ol class="org-ol">
<li>t存储元素 <code>x[0]</code> ;
</li>
<li>移动 <code>x[k]</code> &#x2013;&gt; <code>x[0]</code>, <code>x[2k]</code> &#x2013;&gt; <code>x[k]</code>, 并偏移i×k是总数n的模;
</li>
<li>当 <code>(i*k)%n</code> 回到 Step 1中的起始元素时，用t赋值，并停止Step 2
</li>
<li>若所有元素都得到移动，结束整个算法，若有元素没有得到移动，选取Step 1中的下一个元素啊继续进行Step1-4.
</li>
</ol>

<p>
在Step4中判断所有元素是否得到移动，比较不易，那么如果知道一共要进行
Step1-4几次呢？
</p>

<p>
Step1的起始位i，Step2中移位位置 <code>(i+j*k)/n</code> ,什么时候等于i呢？
j*k第一次被k整除，也就是j*k是k与n的最小工倍数（lcm, least common
multiple), Step1-4运行一次移动 <code>lcm/k</code> 个元素，一共需要次数
<code>n/(lcm/k)=n*k/lcm</code> 也就是k与n的最大公约数。
</p>

<p>
Step1-4一共运行n和k的最大公约数次。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gcd</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">if</span> (m &lt; n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
    temp = m;
    m = n;
    n = m;
  }
  <span style="color: #00ffff;">while</span> (n) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = n;
    n = m % n;
    m = temp;
  }
  <span style="color: #00ffff;">return</span> m;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_gcd</span> = gcd(n, k);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num_gcd; ++i) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">temp</span> = array[i];
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">prev</span> = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span>;
    <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
      next = prev + k;
      <span style="color: #00ffff;">if</span> (next &gt;= n) {
        next -= n;
      }
      <span style="color: #00ffff;">if</span> (next == i) {
        <span style="color: #00ffff;">break</span>;
      }
      array[prev] = array[next];
      prev = next;
    }
    array[prev] = temp;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Block Swap法</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
翻转数组x，相当于翻转ab到ba，假如a的长度短于b，
</p>
<ol class="org-ol">
<li>把b分为ab<sub>l</sub> b<sub>r</sub> 并且 b<sub>r</sub> 长度与a相同
</li>
<li>交换a与b<sub>r</sub> 得到 b<sub>r</sub> b<sub>l</sub> a;
</li>
<li>a达到最终位置，继续处理 b<sub>r</sub> b<sub>l</sub> ，回到step 1.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">swap array[m..m+len], array[n..n+len]</span>
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; len; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[m + i];
    array[m + i] = array[n + i];
    array[n + i] = temp;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (k == 0 || k == n) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array[0..p-i-1]:final stage</span>
<span style="color: #ff7f24;">   * array[p-i..p-1]:the string a to be swaped</span>
<span style="color: #ff7f24;">   * array[p..p+j-1]:the string b to be swaped</span>
<span style="color: #ff7f24;">   * array[p+j..n-1]:final stage</span>
<span style="color: #ff7f24;">   */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = k;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = n - k;
  <span style="color: #00ffff;">while</span> (i != j) {
    <span style="color: #00ffff;">if</span> (i &lt; j) {
      swap(array, p - i, p + j - i, i);
      j -= i;
    } <span style="color: #00ffff;">else</span> {
      swap(array, p - i, p, j);
      i -= j;
    }
  }
  swap(array, p - i, p, i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Reversal法</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
翻转数组x，相当于翻转ab到ba
</p>
<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup>,
</li>
<li>整个翻转， ba
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reverse</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">e</span>) {
  <span style="color: #00ffff;">while</span> (s &lt; e) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span> = array[s];
    array[s] = array[e];
    array[e] = temp;
    s++;
    e--;
  }
}
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rotate</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  reverse(array, 0, k - 1);
  reverse(array, k, n - 1);
  reverse(array, 0, n - 1);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">C</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个英文字典中，找出所有回文单词。
</p>

<ol class="org-ol">
<li>为每个单词生成相对应的特征码 pans &#x2013;&gt; anps pans;
</li>
<li>按照特征码排序;
</li>
<li>按照相同的特征码，提取相应回文单词组。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span> <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cin</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">string</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;map&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">multimap</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">sort</span>;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">pair</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">classcomp</span> {
  <span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">rhs</span>) <span style="color: #00ffff;">const</span> {
    <span style="color: #00ffff;">if</span> (lhs.compare(rhs) &lt; 0) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">stringcomp</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> a &lt; b;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">signWord</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">sign</span> = word;
  sort(sign.begin(), sign.end(), stringcomp);
  words_map-&gt;insert(pair&lt;string, string&gt;(sign, word));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">squash</span>(<span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span>,
            <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span>) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">old_sig</span>;
  old_sig = words_map-&gt;begin()-&gt;first;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">anagram_vector</span>;
  <span style="color: #00ffff;">for</span> (multimap&lt;string, string, classcomp&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = words_map-&gt;begin();
       it != words_map-&gt;end(); ++it) {
    <span style="color: #00ffff;">if</span> ((*it).first == old_sig) {
      anagram_vector.push_back((*it).second);
    } <span style="color: #00ffff;">else</span> {
      anagram_words-&gt;push_back(anagram_vector);
      old_sig = (*it).first;
      anagram_vector.clear();
      anagram_vector.push_back(old_sig);
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">multimap</span>&lt;<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">classcomp</span>&gt; *<span style="color: #eedd82;">words_map</span> = <span style="color: #00ffff;">new</span>
      <span style="color: #98fb98;">multimap</span>&lt;string, <span style="color: #eedd82;">string</span>, <span style="color: #eedd82;">classcomp</span>&gt;();
  <span style="color: #00ffff;">while</span> (cin &gt;&gt; word) {
    signWord(words_map, word);
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt; *<span style="color: #eedd82;">anagram_words</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;string&gt; &gt;();
  squash(words_map, anagram_words);

  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; &gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = anagram_words-&gt;begin();
       it != anagram_words-&gt;end(); ++it) {
    <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it_inter</span> = it-&gt;begin();
        it_inter != it-&gt;end(); ++it_inter) {
      cout &lt;&lt; *it_inter &lt;&lt; <span style="color: #ffa07a;">" "</span>;
    }
    cout &lt;&lt; endl;
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
给一个单词，在字典中找出它的所有回文单词。
</p>

<ol class="org-ol">
<li>不能预处理词典。顺序的读取词典，算出每个单词的特征码，与给定单词的特征码比较
</li>
<li>可以预处理读取词典，算出每个单词的特征码，并按照特征码排序。二分搜索与给定单词特征码相等的回文单词。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
给定一个包含4300000000个32位整数的顺序文件，请问如何找到一个至少出现两次的整数？
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">内存足够</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
bitmap映射法：
</p>
<ol class="org-ol">
<li>申请足够的bit位，并初始化为0;
</li>
<li>把每个数一一映射到内存中相应bit位，若发现相应位置为0,则置为1,反之，找到重复元素。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">内存不够</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
4300000000大于2的32次方，同上面找缺失元素类似
</p>
<ol class="org-ol">
<li>扫描数字文件，以第一个比特位是否为0,分成两组：是0的一组为组0，是1的一组为组1;
</li>
<li>若组0个数&lt;组1个数，那么缺失数这一位是1，Step 3选择组0;
若组1个数&lt;组0个数，那么缺失数这一位是0，Step 3选组组1;
若相等，随便选一组（两组中都有重复数，这里仅找出一个缺失数），并相应得到么缺失数这一位是;
</li>
<li>回到Step 1, 扫描文件为Step 2所选取的，扫描比特位的位置+1。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">若总数并不大于范围数</h4>
<div class="outline-text-4" id="text-2-2-3">
一个大小为n的数组，里面的数范围[0,n-1],有不确定的重复元素，找到至少一
个重复元素，要求 $\mathcal{O}(1)$ 空间和 $\mathcal{O}(N)$ 时间。

<p>
利用Radix排序的思想实现：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">FindErrors</span> {
  <span style="color: #eedd82;">kFind</span> = 0,
  <span style="color: #eedd82;">kNotFind</span>,
};

<span style="color: #98fb98;">FindErrors</span> <span style="color: #87cefa;">RadixFindDuplicate</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">dup_num</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">while</span> (i != array[i]) {
      <span style="color: #00ffff;">if</span> (array[i] == array[array[i]]) {
        *dup_num = array[i];
        <span style="color: #00ffff;">return</span> kFind;
      }
      swap(array[i], array[array[i]]);
    }
  }
  <span style="color: #00ffff;">return</span> kNotFind;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
参考如上问题A。
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
比较书中问题A的3个不同算法。
</p>

<p>
缓存机制影响。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
翻转abc数组到cba。
</p>

<ol class="org-ol">
<li>翻转a， a<sup>r</sup> b c,
</li>
<li>翻转b， a<sup>r</sup> b<sup>r</sup> c,
</li>
<li>翻转c， a<sup>r</sup> b<sup>r</sup> c<sup>r</sup> ,
</li>
<li>整个翻转， cba.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
9键电话拨号，号码上有字母，拨一个号产生一个英文名字序列。现在给出一个名字的拨号序列，找出电话本冲突的名字？
</p>

<ol class="org-ol">
<li>算出所有电话本里名字对应的拨号序列。
</li>
<li>二分法：排序拨号序列，然后用给出的拨号序列二分搜索找出所有相同的序列所对应的人名。
Hash或数据库：把拨号需类hash化或存储在数据库中，然后用给定的拨号序列直接查找得到相应人名。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
转置矩阵。
</p>

<p>
为每条记录加上行号与列号。然后调用排序算法，先按列排序，然后按行排序。最后删除行号与列号得到转置矩阵。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">MatrixElem</span> {
  <span style="color: #87cefa;">MatrixElem</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_data</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_row</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i_col</span>) {
    data = i_data;
    row = i_row;
    col = i_col;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span>;
};

<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">bool RowComp(const MatrixElem &amp;lhs, const MatrixElem &amp;rhs) {</span>
<span style="color: #ff7f24;">  return lhs.row &lt; rhs.row;</span>
<span style="color: #ff7f24;">  }*/</span>

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">MatrixElemComp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">lhs</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">MatrixElem</span> &amp;<span style="color: #eedd82;">rhs</span>) {
  <span style="color: #00ffff;">if</span> (lhs.col == rhs.col) {
    <span style="color: #00ffff;">return</span> lhs.row &lt; rhs.row;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> lhs.col &lt; rhs.col;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TransposeMatrix</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">matrix</span>, 
                     <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">trans_matrix</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MatrixElem</span>&gt; <span style="color: #eedd82;">matrix_vector</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_row</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_col</span>;
  n_row = matrix.size();
  <span style="color: #00ffff;">if</span> (n_row &lt; 1) {
    <span style="color: #00ffff;">return</span>;
  }
  n_col = matrix[0].size();

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0; row &lt; n_row; ++row) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">col</span> = 0; col &lt; n_col; ++col) {
      <span style="color: #98fb98;">MatrixElem</span> <span style="color: #eedd82;">elem</span> = MatrixElem(matrix[row][col], row, col);
      matrix_vector.push_back(elem);
    }
  }

  sort(matrix_vector.begin(), matrix_vector.end(), MatrixElemComp);

  trans_matrix-&gt;resize(n_row);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">row</span> = 0;  row &lt; n_row; ++row) {
    (trans_matrix-&gt;at(row)).resize(n_col);
  }

  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; matrix_vector.size(); ++i) {
    (*trans_matrix)[i / n_row][i % n_row] = matrix_vector[i].data;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
给定n个实数，一个实数t，和整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t。
</p>

<p>
也就是找出n个中的k个最小数问题。
</p>
</div>

<div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">堆</h4>
<div class="outline-text-4" id="text-2-8-1">
<ol class="org-ol">
<li>建立一个k大小的最大堆;
</li>
<li>遍历n个实数，与最大堆比较
</li>
<li>最大堆k个元素即k个最小值，相加所有与t比较。
</li>
</ol>

算法复杂度：  $\mathcal{O}(n*logk)$。
</div>
</div>

<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2">Random Selection</h4>
<div class="outline-text-4" id="text-2-8-2">
<ol class="org-ol">
<li>随机选定一个值作为pivot，然后通过swap，使得最终pivot左边的数都小于
pivot，pivot右边的数都大于pivot。
</li>
<li>如果返回pivot的index小于k，则在pivot的右半段递归查找。
</li>
<li>如果返回pivot的index大于k，则在pivot的做半段递归查找。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RandomSelectionK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  swap(array[l], array[randint(l, u)]);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pivot</span> = array[l];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = u + 1;
  <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; pivot);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; pivot);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array[i], array[j]);
  }
  swap(array[l], array[j]);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    RandomSelectionK(array, j + 1, u, k);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    RandomSelectionK(array, l, j - 1, k);
  }
}
</pre>
</div>
算法平均时间复杂度： $\mathcal{O}(n)$ 。
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column1]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/10/column1/"/>
    <updated>2014-05-10T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/10/column1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Bitmap Data Structure</h3>
<div class="outline-text-3" id="text-1-1">
<p>
这个数据结构用来表明在有限域中的一个密集集合，当集合中每个元素最多出现一次且没有其他数据与这些元素相关。即使这些情况得不到满足（比如，当有多个相同元素或其他附加数据），一个来自有限域的键能被在一个复杂数据表中用来做索引。
</p>

<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    clr_bit(i);
  }
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;i) != EOF) {
    set_bit(i);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAX_BITS; ++i) {
    <span style="color: #00ffff;">if</span> (test_bit(i)) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, i);
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
如果内存足够大，如何用库实现排序算法。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">comp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(a) -
          *<span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> *&gt;(b));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[10000];
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;array[n]) != EOF) {
    ++n;
  }
  qsort(array, n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), comp);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      printf(<span style="color: #ffa07a;">"%d\n"</span>, array[i]);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如何使用bit操作来实现bit数组？
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BITSPERINTEGER</span> 32
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SHIFT</span> 5
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MASK</span> 0x1F
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_BITS</span> 10000000

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[1 + MAX_BITS / BITSPERINTEGER];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clr_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">test_bit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>) {
  <span style="color: #00ffff;">return</span> array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 4</h3>
<div class="outline-text-3" id="text-2-3">
<p>
如何在0到n-1间随机生成k个唯一的随机整数？
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctime&gt;</span>

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span> = time(<span style="color: #7fffd4;">NULL</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + rand_r(&amp;seed) / (RAND_MAX / (n + 1 - m) + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">generate_unique_random</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">out</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; n; ++i) {
    num[i] = i;
  }
  <span style="color: #00ffff;">for</span>(i = 0; i &lt; k; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span> = randint(i, n - 1);
    <span style="color: #7fffd4;">std</span>::swap(num[i], num[p]);
    out[i] = num[i];
  }
}
</pre>
</div>

<p>
类似于洗牌问题或不知道n时，选取随机数：
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Fisher%E2%80%93Yates%20shuffle.html">Fisher–Yates shuffle</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
使用两次传递算法，第一次排序0-4,999,999，第二次排序
5,000,000-9,999,999.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 6</h3>
<div class="outline-text-3" id="text-2-5">
<p>
每个整数最多出现10次，用4bit就可以表示，多需要空间n×4bit就来存储每个数的个数就可以。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 9</h3>
<div class="outline-text-3" id="text-2-6">
<p>
One problem with trading more space to use less time is that
initializing the space can itself take a great deal of time. Show how
to circumvent this problem by designing a technique to initialize an
entry of a vector to zero the first time it is accessed. Your scheme
should use constant time for initialization and for each vector
access, and use extra space proportional to the size of the vector.
</p>

<p>
data[0&#x2026;n-1]是这个未初始化的数组，每个元素都是个随机数，额外添加两个数组from[0..n-1]和to[0&#x2026;n]，和一个 <code>top</code> 变量。如果元素 <code>data[i]</code> 已经被访问过，那么 <code>from[i] &lt; top</code> 且 <code>to[from[i]] = i</code> 。访问过的如下图：
</p>

<img src="/images/blog/2014/programmingpearls/column1_9.jpg" title="'column1_9'" >
<p>
代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">if</span> (from[i] &lt; top &amp;&amp; to[from[i]] = i) {
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">has been accessed</span>
} <span style="color: #00ffff;">else</span> {
  from[i] = top;
  to[top] = i;
  data[i] = 0;
  top++;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 10</h3>
<div class="outline-text-3" id="text-2-7">
<p>
open hashing with collision resolution by sequential search.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 11</h3>
<div class="outline-text-3" id="text-2-8">
<p>
扫描图纸，通过信鸽载送35nm的影片到测试站，在那里图纸得到重新放大和打印。
</p>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> 12</h3>
<div class="outline-text-3" id="text-2-9">
<p>
用铅笔。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
