<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming Pearls | (learn&think)]]></title>
  <link href="http://shishougang.github.com/blog/categories/programming-pearls/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-06-01T20:28:00+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column14-15]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/24/column14_15/"/>
    <updated>2014-05-24T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/24/column14_15</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Hash存储word次数</h3>
<div class="outline-text-3" id="text-1-1">
<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span>* <span style="color: #98fb98;">Nodeptr</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Node</span> {
  <span style="color: #87cefa;">Node</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">inword</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">incount</span>, <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">innext</span>) {
    word = inword;
    count = incount;
    next = innext;
  }
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
  <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">next</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NHASH</span> 29989
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MULT</span> 31
<span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">bin</span>[NHASH];

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Hash</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">string</span>::<span style="color: #98fb98;">const_iterator</span> <span style="color: #eedd82;">it</span> = str.begin(); it != str.end(); ++it) {
    h = MULT * h + *it;
  }
  <span style="color: #00ffff;">return</span> h % NHASH;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">InWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">p</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span>;
  h = Hash(str);
  <span style="color: #00ffff;">for</span> (p = bin[h]; p != <span style="color: #7fffd4;">NULL</span>; p = p-&gt;next) {
    <span style="color: #00ffff;">if</span> (str.compare(p-&gt;word) == 0) {
      (p-&gt;count)++;
      <span style="color: #00ffff;">return</span>;
    }
  }
  p = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Node</span>(str, 1, bin[h]);
  bin[h] = p;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    bin[i] = <span style="color: #7fffd4;">NULL</span>;
  }
  <span style="color: #00ffff;">while</span> (cin &gt;&gt; str) {
    InWord(str);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">Nodeptr</span> <span style="color: #eedd82;">p</span> = bin[i]; p != <span style="color: #7fffd4;">NULL</span>; p = p-&gt;next) {
      cout &lt;&lt; p-&gt;word &lt;&lt; <span style="color: #ffa07a;">" "</span> &lt;&lt; p-&gt;count &lt;&lt; endl;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Markov产生随机词汇</h3>
<div class="outline-text-3" id="text-1-2">
<p>
利用指针指向不同单词的开头，并按照K个单词对比方式排序，利用二分搜索定位相同K长度的文本，并利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Reservoir%20Sampling.html">Reservoir sampling</a>在不知道长度的情况下，均等的随机选取一个。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXINPUT</span> 4000000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORDS</span> 800000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">K</span> 2
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">input_letters</span>[MAXINPUT];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>[MAXWORDS];

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">WordNcmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">while</span> (*p == *q) {
    <span style="color: #00ffff;">if</span> (*p == 0 &amp;&amp; --n == 0) {
      <span style="color: #00ffff;">return</span> 0;
    }
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> *p - *q;
}


<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">SortCmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">p</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>**)(a);
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">q</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>**)(b);
  <span style="color: #00ffff;">return</span> WordNcmp(*p, *q, K);
}

<span style="color: #98fb98;">char</span>* <span style="color: #87cefa;">SkipNword</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (; n &gt; 0; p++) {
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> p;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FindPhrase</span>(<span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span> = -1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span> = n;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  <span style="color: #00ffff;">while</span> (l + 1 != u) {
    m = (l + u) / 2;
    <span style="color: #00ffff;">if</span> (WordNcmp(word[m], phrase, K) &lt; 0) {
      l = m;
    } <span style="color: #00ffff;">else</span> {
      u = m;
    }
  }
  <span style="color: #00ffff;">return</span> u;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span> = 0;
  word[0] = input_letters;
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%s"</span>, word[nword]) != EOF) {
    word[nword + 1] = word[nword] + strlen(word[nword]) + 1;
    nword++;
    <span style="color: #00ffff;">if</span> (nword == MAXWORDS) {
      <span style="color: #00ffff;">break</span>;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    word[nword][i] = 0;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    printf(<span style="color: #ffa07a;">"%s "</span>, word[i]);
  }
  qsort(word, nword, <span style="color: #00ffff;">sizeof</span>(word[0]), SortCmp);
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span> = input_letters;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">printlen</span> = 100;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">find_index</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (; printlen &gt; 0; --printlen) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">find_index</span> = FindPhrase(word, nword, phrase);
    <span style="color: #00ffff;">for</span> (i = 0; WordNcmp(phrase, word[find_index + i], K) == 0; ++i) {
      <span style="color: #00ffff;">if</span> ((rand() % (i + 1)) == 0) {
        p = word[find_index + i];
      }
    }
    phrase = SkipNword(p, 1);
    <span style="color: #00ffff;">if</span> (strlen(SkipNword(phrase, K - 1)) == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    printf(<span style="color: #ffa07a;">"%s "</span>, SkipNword(phrase, K - 1));
  }
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Markov利用Hash产生随机词汇</h3>
<div class="outline-text-3" id="text-1-3">
<p>
利用Hash表加快搜索相同K长度的文本。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXINPUT</span> 4000000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORDS</span> 800000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">K</span> 2
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">input_letters</span>[MAXINPUT];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>[MAXWORDS];

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">WordNcmp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">while</span> (*p == *q) {
    <span style="color: #00ffff;">if</span> (*p == 0 &amp;&amp; --n == 0) {
      <span style="color: #00ffff;">return</span> 0;
    }
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> *p - *q;
}

<span style="color: #98fb98;">char</span>* <span style="color: #87cefa;">SkipNword</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (; n &gt; 0; p++) {
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> p;
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NHASH</span> 499979
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MULT</span> 31
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bin</span>[NHASH];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span>[MAXWORDS];

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Hash</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>) {
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = 0;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span> = str;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = K; n &gt; 0; p++) {
    h = MULT * h + (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>)(*p);
    <span style="color: #00ffff;">if</span> (*p == 0) {
      --n;
    }
  }
  <span style="color: #00ffff;">return</span> h % NHASH;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">InitHash</span>(<span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NHASH; ++i) {
    bin[i] = - 1;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; nword; ++i) {
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">h</span> = Hash(word[i]);
    next[i] = bin[h];
    bin[h] = i;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nword</span> = 0;
  word[0] = input_letters;
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%s"</span>, word[nword]) != EOF) {
    word[nword + 1] = word[nword] + strlen(word[nword]) + 1;
    nword++;
    <span style="color: #00ffff;">if</span> (nword == MAXWORDS) {
      <span style="color: #00ffff;">break</span>;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    word[nword][i] = 0;
  }
  InitHash(word, nword);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; K; ++i) {
    printf(<span style="color: #ffa07a;">"%s "</span>, word[i]);
  }
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">phrase</span> = input_letters;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">printlen</span> = 100;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (; printlen &gt; 0; --printlen) {
    i = 0;
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = bin[Hash(phrase)]; j &gt;= 0; j = next[j]) {
      <span style="color: #00ffff;">if</span> (WordNcmp(word[j], phrase, K) == 0 &amp;&amp; (rand() % (++i) == 0)) {
        p = word[j];
      }
    }
    phrase = SkipNword(p, 1);
    <span style="color: #00ffff;">if</span> (strlen(SkipNword(phrase, K - 1)) == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    printf(<span style="color: #ffa07a;">"%s "</span>, SkipNword(phrase, K - 1));
  }
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Column14-2</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SiftDown</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">child</span>;
  <span style="color: #00ffff;">for</span> (;;) {
    child = i * 2;
    <span style="color: #00ffff;">if</span> (child &gt; u) {
      <span style="color: #00ffff;">break</span>;
    }
    <span style="color: #00ffff;">if</span> (child + 1 &lt;= u) {
      <span style="color: #00ffff;">if</span> (x[child + 1] &lt; x[child]) {
        child++;
      }
    }
    <span style="color: #00ffff;">if</span> (x[i] &lt;= x[child]) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(x[i], x[child]);
    i = child;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">HeapSort</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = n / 2; i &gt;= 1; --i) {
    SiftDown(x, i, n);
  }
  <span style="color: #00ffff;">for</span> (i = n; i &gt;= 2; --i) {
    swap(x[1], x[i]);
    SiftDown(x, 1, i - 1);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Column15-8</h3>
<div class="outline-text-3" id="text-2-2">
<p>
找出最长重复超过M次的字符串。
</p>

<p>
经过排序后，越是相邻的越是相同的多，至少重复M次，就是计算相邻M个位置的字符所重复的字符长度，即 <code>ComLen(pstr[i], pstr[i + kM])</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">CmpPstr</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">p</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **)a;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">q</span> = (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **)b;
  <span style="color: #00ffff;">return</span> strcmp(*p, *q);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ComLen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">q</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">while</span> (*p &amp;&amp; (*p == *q)) {
    ++i;
    ++p;
    ++q;
  }
  <span style="color: #00ffff;">return</span> i;
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">kMaxN</span> 500000
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">kM</span> 1
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[kMaxN];
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pstr</span>[kMaxN];
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ch</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;
  <span style="color: #00ffff;">while</span> ((ch = getchar()) != EOF) {
    str[n] = ch;
    pstr[n] = &amp;str[n];
    ++n;
  }
  str[n] = 0;
  qsort(pstr, n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span> *), CmpPstr);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxlen</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxindex</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n - kM; ++i) {
    <span style="color: #00ffff;">if</span> (ComLen(pstr[i], pstr[i + kM]) &gt; maxlen) {
      maxlen = ComLen(pstr[i], pstr[i + kM]);
      maxindex = i;
    }
  }
  printf(<span style="color: #ffa07a;">"%.*s\n"</span>, maxlen, pstr[maxindex]);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Column15-9</h3>
<div class="outline-text-3" id="text-2-3">
<p>
找出两个文本中最长的共同字符串。
</p>

<p>
经典<a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem">Longest common substring problem</a>.
利用Dynamic Programming解决。复杂度O(mn).
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #87cefa;">LongestCommonString</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">s</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">t</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; <span style="color: #eedd82;">array</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len_s</span> = s.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len_t</span> = t.size();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  array.resize(len_s);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; len_s; ++i) {
    array[i].resize(len_t);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max_len</span> = 0;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">end_indexs</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; len_s; ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; len_t; ++j) {
      <span style="color: #00ffff;">if</span> (s[i] == t[j]) {
        <span style="color: #00ffff;">if</span> (i == 0 || j == 0) {
          array[i][j] = 1;
        } <span style="color: #00ffff;">else</span> {
          array[i][j] = array[i-1][j-1] + 1;
        }
        <span style="color: #00ffff;">if</span> (array[i][j] == max_len) {
          end_indexs.push_back(i);
        } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (array[i][j] &gt; max_len) {
          max_len = array[i][j];
          end_indexs.clear();
          end_indexs.push_back(i);
        }
      }
    }
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; <span style="color: #eedd82;">res</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = end_indexs.begin(); it != end_indexs.end();
       ++it) {
    res.push_back(s.substr(*it - max_len + 1, max_len));
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Column15-11</h3>
<div class="outline-text-3" id="text-2-4">
<p>
产生单词层次的Markov文本。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMax</span> = 50000;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kK</span> = 5;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kPrintlen</span> = 1000;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[kMax];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">n</span>;
  n = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF) {
    str[n++] = c;
  }
  str[n] = 0;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">q</span>, *<span style="color: #eedd82;">next_p</span>;
  p = str;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">eq_sofar</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; kK; ++i) {
    printf(<span style="color: #ffa07a;">"%c"</span>, str[i]);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; kPrintlen; ++i) {
    eq_sofar = 0;
    <span style="color: #00ffff;">for</span> (q = str; q &lt; str + n - kK + 1; ++q) {
      <span style="color: #00ffff;">for</span> (j = 0; j &lt; kK &amp;&amp; *(p + j) == *(q + j); ++j) {
      }
      <span style="color: #00ffff;">if</span> (j == kK) {
        eq_sofar++;
        <span style="color: #00ffff;">if</span> (rand() % eq_sofar == 0) {
          next_p = q;
        }
      }
    }
    c = *(next_p + kK);
    <span style="color: #00ffff;">if</span> (c == 0) {
      <span style="color: #00ffff;">break</span>;
    }
    putchar(c);
    p = next_p + 1;
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column11-12]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/18/column11_12/"/>
    <updated>2014-05-18T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/18/column11_12</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">QuickSort</h3>
<div class="outline-text-3" id="text-1-1">
<!-- more -->

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = array[m];
  array[m] = array[n];
  array[n] = temp;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">isort</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">t</span>;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; n; ++i) {
    t = array[i];
    <span style="color: #00ffff;">for</span> (j = i; j &gt;= 0  &amp;&amp; array[j - 1] &lt; t; --j) {
      array[j] = array[j - 1];
    }
    array[j - 1] = t;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort1</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">use array[l] for the mid element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = l;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = l + 1; i &lt;= u; ++i) {
    <span style="color: #00ffff;">if</span> (array[i] &lt; array[l]) {
      swap(array, ++m, i);
    }
  }
  swap(array, l, m);
  qsort1(array, l, m - 1);
  qsort1(array, m + 1, u);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort2</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">use array[l] for the mid element, from back to start,</span>
<span style="color: #ff7f24;">    always swap the first element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">m</span>;
  i = m = u + 1;
  <span style="color: #00ffff;">do</span> {
    <span style="color: #00ffff;">do</span> {
      --i;
    } <span style="color: #00ffff;">while</span> (array[i] &lt; array[l]);
    swap(array, --m, i);
  } <span style="color: #00ffff;">while</span> (i &gt; l);
  qsort2(array, l, m - 1);
  qsort2(array, m + 1, u);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort3</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">two-way partition, use array[l] for the mid element */</span>
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span> , <span style="color: #eedd82;">j</span>;
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  qsort3(array, l, j - 1);
  qsort3(array, j + 1, u);
}

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kCutOff</span> = 50;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort4</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">qsort3 + randomization + isort small subarrays + swap inline */</span>
  <span style="color: #00ffff;">if</span> (u - l &lt; kCutOff) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span> , <span style="color: #eedd82;">j</span>;
  swap(array, l, randint(l, u));
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  qsort3(array, l, j - 1);
  qsort3(array, j + 1, u);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">生成随机数</h3>
<div class="outline-text-3" id="text-1-2">
<p>
从n中生成不重复的m个随机数。
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">1</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenerateSortedRand</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">select</span> = m;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">remaining</span> = n;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n &amp;&amp; select &gt; 0; ++i) {
    <span style="color: #00ffff;">if</span> (rand() % remaining &lt; select) {
      cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" "</span>;
      --select;
    }
    --remaining;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">2</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenKnuth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n &amp;&amp; m &gt; 0; ++i) {
    <span style="color: #00ffff;">if</span> (rand() % (n - i) &lt; m) {
      cout &lt;&lt; i &lt;&lt; <span style="color: #ffa07a;">" "</span>;
      --m;
    }
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">3</h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #00ffff;">while</span> (num_set.size() &lt; m) {
    num_set.insert(rand() % n);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end(); ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">4</h4>
<div class="outline-text-4" id="text-1-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(a) - *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(b));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenShuf</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    x[i] = i;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(i, n - 1);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = x[j];
    x[j] = x[i];
    x[i] = t;
  }
  qsort(x, m, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), compare);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    cout &lt;&lt; x[i] &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">delete</span> x;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">原则</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>理解问题。与用户讨论提出问题的有关场景。问题的陈述中往往包含问题的想法，和所有早期的想法一样，它们应该被考虑而不是与其他排斥。
</li>
<li>指出一个抽象问题。一个清晰，整洁的问题陈述不旦帮助我们解决这个问题，并且能体现如何把这个解答应用到其他的问题上。
</li>
<li>探索设计空间。不要急于立刻去解决问题，思考一分钟，花一天时间编程。应该思考一小时，编程一小时。使用通俗的上层语言帮助我们描述设计：伪代码描述控制六，抽象化表示关键数据结构的数据类型。
</li>
<li>实现一种解答。我们应该追求以直接清晰的代码来实现选择的设计，使用最强大的能用的操作。
</li>
<li>回顾。Polya的<a href="http://www.amazon.com/How-Solve-It-Mathematical-Princeton/dp/069111966X">How to Solve It</a>能帮助任何程序员成为更好的问题解决者。在
15页他说：”基本存在一些东西去做，随着足够的学习和突破，我们能改善每个解答，并且在任何情况下，我们都能经常改善我们对解答的理解。“
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Column11-9</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在数组n中以算法复杂度O(n)找出第k个小的元素。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = array[m];
  array[m] = array[n];
  array[n] = temp;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SelectK</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">k</span>) {
  <span style="color: #00ffff;">if</span> (l &gt;= u) {
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  swap(array, l, randint(l, u));
  t = array[l];
  i = l;
  j = u + 1;
  <span style="color: #00ffff;">for</span> (;;) {
    <span style="color: #00ffff;">do</span> {
      ++i;
    } <span style="color: #00ffff;">while</span> (i &lt;= u &amp;&amp; array[i] &lt; t);
    <span style="color: #00ffff;">do</span> {
      --j;
    } <span style="color: #00ffff;">while</span> (array[j] &gt; t);
    <span style="color: #00ffff;">if</span> (i &gt; j) {
      <span style="color: #00ffff;">break</span>;
    }
    swap(array, i, j);
  }
  swap(array, l, j);
  <span style="color: #00ffff;">if</span> (j &lt; k) {
    SelectK(array, j + 1, u, k);
  }
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (j &gt; k) {
    SelectK(array, l, j - 1, k);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">bigrand</span>() {
  <span style="color: #00ffff;">return</span> RAND_MAX * rand() + rand();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">2</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenerateM</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">t</span>;
  i = randint(0, n - 1);
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; m; ++j) {
    t = i + j;
    <span style="color: #00ffff;">if</span> (t &gt;= n) {
      t -= n;
    }
    cout &lt;&lt; t &lt;&lt; <span style="color: #ffa07a;">" "</span> &lt;&lt; endl;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">8</h3>
<div class="outline-text-3" id="text-2-4">
<p>
0..n-1中生成m个随机数。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">b</span>) {
  <span style="color: #00ffff;">return</span> (*<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(a) - *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>*&gt;(b));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenShuf</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">x</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">int</span>[n];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    x[i] = i;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(i, n - 1);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = x[j];
    x[j] = x[i];
    x[i] = t;
  }

  <span style="color: #00ffff;">for</span> (i = 0; i &lt; m; ++i) {
    cout &lt;&lt; x[i] &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
  <span style="color: #00ffff;">delete</span> x;
}
</pre>
</div>

<p>
如果允许有重复的数，如何生成排序的m个随机数。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">multiset</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #00ffff;">while</span> (num_set.size() &lt; m) {
    num_set.insert(rand() % n);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">multiset</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end();
       ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>

<p>
如果可以重复并顺序随机。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenM</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; m; ++i) {
    cout &lt;&lt; randint(0, n - 1) &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">9</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GenSets</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_set</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = n - m ; i &lt; n; ++i) {
    t = randint(0, i);
    <span style="color: #00ffff;">if</span> (num_set.find(t) == num_set.end()) {
      num_set.insert(t);
    } <span style="color: #00ffff;">else</span> {
      num_set.insert(i);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #7fffd4;">set</span>&lt;<span style="color: #98fb98;">int</span>&gt;::<span style="color: #98fb98;">iterator</span> <span style="color: #eedd82;">it</span> = num_set.begin(); it != num_set.end(); ++it) {
    cout &lt;&lt; *it &lt;&lt; <span style="color: #ffa07a;">" "</span>;
  }
  cout &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">10</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">randint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">return</span> m + (rand() / (RAND_MAX / (n - m + 1) + 1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Select</span>() {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">res</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
  res = object[i];
  ++i;
  <span style="color: #00ffff;">while</span> (IsEnd(object[i])) {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = randint(0, i);
      <span style="color: #00ffff;">if</span> (j &lt; 1) {
        res = object[i];
      }
      ++i;
  }
  <span style="color: #00ffff;">return</span> res;
}
</pre>
</div>

<p>
More: <a href="http://wiki.dreamrunner.org/public_html/Algorithms/Random%20and%20Sampling.html#sec-2">选k个</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">12</h3>
<div class="outline-text-3" id="text-2-7">
<p>
生成N&gt;1e6组的m个随机数，计算生成每个随机数出现的概率，是不是符合预期，还是偏差很大而不是随机的。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column8]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/17/column8/"/>
    <updated>2014-05-17T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/17/column8</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">问题与算法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
给出数组中找出连续子数组最大和。
</p>

<!-- more -->
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">1</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
直接算每个子区间的和并比较得出最大值。算法复杂度 O(n<sup>3</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg1</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; num.size(); ++j) {
      sum = 0;
      <span style="color: #00ffff;">for</span> (k = i; k &lt;= j; k++) {
        sum += num[k];
        <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
          max_sofar = sum;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">2</h4>
<div class="outline-text-4" id="text-1-1-2">
</div><div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">2.1</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
因为x[i..j]直接的和可以基于x[i..j-1]的和算出，不用重头开始算。算法复杂度 O(n<sup>2</sup>)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; num.size(); ++i) {
    sum = 0;
    <span style="color: #00ffff;">for</span> (j = i; j &lt; num.size(); ++j) {
      sum += num[j];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2">2.2</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<p>
先算出x[0..i]区间的和为 <code>cum_vector[i]</code> ，那么x[i..j]区间的和就是
<code>cum_vector[j] - cum-vector[i-1]</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg2b</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; <span style="color: #eedd82;">cum_vector</span>(num.size() + 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  cum_vector[0] = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    cum_vector[i] = cum_vector[i - 1] + num[i];
  }
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">max_sofar</span>;
  max_sofar = 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; cum_vector.size(); ++i) {
    <span style="color: #00ffff;">for</span> (j = i; j &lt; cum_vector.size(); ++j) {
      sum = cum_vector[j] - cum_vector[i - 1];
      <span style="color: #00ffff;">if</span> (sum &gt; max_sofar) {
        max_sofar = sum;
      }
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">3</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Divide-and-Conquer算法。
</p>
<ol class="org-ol">
<li>求整个数组的子数组和，可以分成前面一半和后面一半
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_1.jpg" title="'column8_3_1'" >

<ol class="org-ol">
<li>求出前半部分的最大子数组和后半部分的最大子数组和
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_2.jpg" title="'column8_3_2'" >

<ol class="org-ol">
<li>求出两部分中间连着的子数组最大和
</li>
</ol>
<img src="/images/blog/2014/programmingpearls/column8_3_3.jpg" title="'column8_3_3'" >

<ol class="org-ol">
<li>最后比较这3部分和就能得出整个个数组的子数组最大和
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3Core</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">l</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">u</span>) {
  <span style="color: #00ffff;">if</span> (l &gt; u) {
    <span style="color: #00ffff;">return</span> 0;
  }
  <span style="color: #00ffff;">if</span> (l == u) {
    <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">max</span>&lt;<span style="color: #98fb98;">float</span>&gt;(num[l], 0);
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  m = (l + u) / 2;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">lmax</span>, <span style="color: #eedd82;">rmax</span>, <span style="color: #eedd82;">sum</span>;
  lmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m; i &gt;= l; --i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; lmax) {
      lmax = sum;
    }
  }
  rmax = sum = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = m + 1; i &lt;= u; ++i) {
    sum += num[i];
    <span style="color: #00ffff;">if</span> (sum &gt; rmax) {
      rmax = sum;
    }
  }
  <span style="color: #00ffff;">return</span> max(lmax + rmax, max(FindMaxSubvectorAlg3Core(num, l, m),
                              FindMaxSubvectorAlg3Core(num, m + 1, u)));
}

<span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg3</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #00ffff;">return</span> FindMaxSubvectorAlg3Core(num, 0, num.size() - 1);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">4</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
假定已经解决了x[0..i-1]的情况，那么如何扩展到x[0..i]的情况，只多了x[i]
元素？
</p>

<ol class="org-ol">
<li>解决了x[0..i-1]的情况，有这区间的最大子数组和 <code>max_sofar</code> ，和必须以
x[i-1]结尾的子数组最大和;
</li>
<li>到x[0..i]的情况，就要把必须以x[i-1]结尾的子数组最大和与x[i]相加，如果以x[i-1]结尾的子数组为负数的话，加了反而减少总和。所以此种情况以
x[i]的和就是x[i];
</li>
<li>最后把以x[i]与在区间x[0..i-1]的最大子数组和 <code>max_sofar</code> 比较，就能解决
x[0..i]的情况;
</li>
<li>如此一直扩展到x[0..n]算出整个数组的最大子数组和。
</li>
</ol>

<p>
只扫描一遍，算法复杂度O(n)。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">float</span> <span style="color: #87cefa;">FindMaxSubvectorAlg4</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">float</span>&gt; &amp;<span style="color: #eedd82;">num</span>) {
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">max_sofar</span>, <span style="color: #eedd82;">max_ending_here</span>;
  max_sofar = max_ending_here = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; num.size(); ++i) {
    max_ending_here += num[i];
    <span style="color: #00ffff;">if</span> (max_ending_here &lt; 0) {
      max_ending_here = 0;
    }
    <span style="color: #00ffff;">if</span> (max_ending_here &gt; max_sofar) {
      max_sofar = max_ending_here;
    }
  }
  <span style="color: #00ffff;">return</span> max_sofar;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">算法设计技巧</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>保存状态防止重复计算。
</li>
<li>预处理信息到适当的数据结构中来加快之后的计算。比如先建立堆，先排序等。
</li>
<li>分而治之，把大问题分成类似的小问题解决。
</li>
<li>扫描算法。比如解出了x[0..i-1]如何扩展到x[0..i].
</li>
<li>累积。
</li>
<li>确定问题的算法复杂度下界。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">10</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>初始化累积和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code> ， 那么要x[l..u]
区间的和为0的话，cum[l-1] = cum[u]
</li>
<li>排序cum数组;
</li>
<li>扫描排序好的数组cum，找出最相近的相邻数组元素即得到结果。
</li>
</ol>

<p>
算法复杂度 O(n) + O(nlogn) + O(n-1) = O(nlogn).
</p>

<p>
找出子数组和与一个特定值r最相近，算法类似，只是step3找出与r最相近的相邻数组元素。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">11</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>累积收费和数组cum，使得 <code>cum[i]=x[0]+x[1]...x[i]</code>
</li>
<li>计算l和u关卡之间的收费 cum[u]-cum[l]
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column7]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/14/column7/"/>
    <updated>2014-05-14T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/14/column7</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
一天中密西西比河的流量是多少？
</p>

<p>
作者估算：河口宽度大约1 mile，大约1/250英里深，他猜测流速是5mile每小时或
120mile每天。
</p>

<p>
1mile * 1/250mile * 120 miles/day = 1/2 mile<sup>3</sup>/day
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">基本技巧</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">两个答案好于一个</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
估算中密西西比河的流域是 1000 × 1000 miles， 一年雨量大约1英尺，（1/5000英里每年）。
1000miles * 1000miles * 1/5000 mile/year = 200 mile<sup>3</sup>/year
200mile<sup>3</sup>/year/400days/year = 1/2 mile<sup>3</sup>/day
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">快速检查</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>Rule1： 相加的单位与原来一样。
</li>
<li>Rule2： 相乘的单位是单位的相乘。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">经验法则</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
72法则。
</p>

<p>
假如一笔钱以年利率百分比r存y年。如果r×y=72,那么钱将成2倍。这个估算大体正确，存1000以6%的年利率存12年之后为2012.
</p>

<p>
72法则对估算指数增长非常实用。双倍对于程序员来说很熟悉：2<sup>10</sup>=1024，10
倍双倍就是1thousand，20个双倍就是1million。
</p>

<p>
假如一个指数型复杂度的程序花10秒解决一个n=40的问题，每把n增加1就增加
12%的运行时间。72法则告诉我们，运行时间成2倍当n增加6，也就是1000倍（2<sup>10）当n增加60</sup>(6*10)。所以当n=100时，程序花10,000秒，也就几小时。当n
增加到160,时间成为10<sup>7</sup> 秒,那这时间大约是多少呢？
</p>

<p>
很难记住一年的时间是3.155×10<sup>7</sup> 秒，另一方面，很难忘记Tom Duff的实用经验准则，1%多的误差：
</p>

<strong> $\pi$ 秒是1纳世纪。</strong> ($\pi$ seconds is a nanocentury.)
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">练习</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
不断练习提高自己的估算技巧。
</p>

<p>
书中估算密西西比河的流量并不是特别技巧好，比如直接估测出流速是5mile每小时，很难直观想出这个数字。
</p>

<p>
推荐<a href="http://book.douban.com/subject/4904724/">《这也能想到?——巧妙解答无厘头问题》</a> 这本书，全书都是估算题目，
</p>
<ol class="org-ol">
<li>明白估算的目标精确度只需要达到一个数量级，和真实数据不超过10倍就是比较好的估算。
</li>
<li>估算一个东西的范围的关键是几何平均数。比如这里流量最小1mile每小时，最大10mile每小时，那么估算它为3mile每小时（几何平均）。比如地球的密度，比水大，比铁小，取它们的几何平均。
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">利特尔法则(Little's law)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在一个稳定系统中长期平均存在的用户数是平均用户离开系统的速率与用户平均在系统的时间的乘积。
</p>

<p>
例如：一个地方能容纳60个人，你准备呆在那大约3小时，所以人们进入这个地方的速率是20个每小时。现在队伍中有20个人，那么意味着你将等1小时左右。
</p>

<p>
或多用户系统的回复时间公式：假定用户连接到回复时间是r的系统中的平均思考时间是z，每个用户或思考或等待系统回复，系统中的任务数大约固定在n，可以测得系统的吞吐量是x（每时间单位的任务数），由Little's law得，
n=x*(z+r)。可以算得r=n/x - z。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
密西西比河的流速大概是5mile每小时或120mile每天，Passaic River应该是
200miles每天。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
软盘有1.44Mbytes，
</p>

<p>
一秒中最少可以打1byte，最多10bytes，也就是每分钟最少60bytes和最多600bytes，它们的几何平均是200byte，认为大约每分钟打字200byte，
1.44*10<sup>6</sup>/200=7200 minutes。
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">5</h3>
<div class="outline-text-3" id="text-2-3">
<p>
证明72法则。
</p>

<p>
若（1+x%）<sup>N</sup> = 2，证明x*N约等于72
</p>

<p>
(1+x%)<sup>N</sup>=2 ==&gt; N*ln(1+x%)=ln2
</p>

<p>
对ln(1+x)泰勒展开是ln(1+x) = x-(x<sup>2</sup>)/2 + (x<sup>3</sup>)/3 + &#x2026;
</p>

<p>
N*ln(1+x%)=ln2 ==&gt; N*x = ln2 * 100 = 69.3
</p>

<p>
因为忽略了-(x<sup>2</sup>)/2这个项，所以N*x约等于72。
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">6</h3>
<div class="outline-text-3" id="text-2-4">
<p>
72/1.33=54, 所以到2052年人口是2倍，就是5.9×2=11.8 billion。那么2050年大约就是11.5 billion。
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">10</h3>
<div class="outline-text-3" id="text-2-5">
<p>
估算城市的死亡率。
</p>

<p>
假定大家平均生命是70年，根据Little's law，那么每年的死亡率就是1/70=1.4%的城市人口。
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">11</h3>
<div class="outline-text-3" id="text-2-6">
<p>
证明利特尔法则(Little's law)。
</p>

<img src="/images/blog/2014/programmingpearls/column7_11.jpg" title="'column7_11'" >

<p>
时间T进入个数为N(T)，那么到达速率 &lambda;(T) = N(T)/T;
</p>

<p>
时间T离开个数为C(T)，那么离开速率 X = C(T)/T;
</p>

<p>
系统中，时间T中堆积的个数平均为阴影部分A(T),那么平均等待的个数为L(T) =
A(T)/T;
</p>

<p>
时间T离开个数为C(T)，时间T中堆积的个数A(T)，那么每个的等待时间是
W(T)=A(T)/C(T)。
</p>

<p>
可以得到L(T)=C(T)W(T),均衡系统&lambda;(T)=C(T),即L(T)=&lambda;(T)W(T)。
</p>

<p>
完善的数学证明这里：
<a href="http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf">http://www.columbia.edu/~ks20/stochastic-I/stochastic-I-LL.pdf</a>
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">12</h3>
<div class="outline-text-3" id="text-2-7">
<p>
美国报纸说25美分的硬币平均寿命是30年。你如何检测这个声明？
</p>

<p>
硬币制造厂每年平均最小为每个人制造1枚25美分的硬币，最多不会超过100枚，那么几何平均就是10枚，加入它的平均寿命是30年，那么平均每人就有300枚25
美分的硬币在手里，算上手头，家里抽屉，公司抽屉所有的25美分，应该不会超过300枚，所以这个声明的数字有点偏高。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Pearls: Column3]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/13/column3/"/>
    <updated>2014-05-13T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/13/column3</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book notes</h2>
<div class="outline-text-2" id="text-1">
<p>
主旨是：don't wirte a big program when a little one will do.
</p>

<!-- more -->

<p>
一些原则：
</p>
<ol class="org-ol">
<li>重构重复的代码到数组。
</li>
<li>封装复杂的结构。
</li>
<li>尽可能使用高级工具。
</li>
<li>让数据来构建程序。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Problems</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>建立一张税收表格，包括1.这个一行数据范围的最低收入; 2.税收的基本费用; 和3.税收比率。
</li>
<li>用给定税收，二分搜索所处范围，也就是表格的哪一栏。用公式算出税收。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">3</h3>
<div class="outline-text-3" id="text-2-2">
<p>
编写标语函数，输入一个大写字母，输出一个字符数组，该字符数组用字符图形方式描绘该字母
</p>

<ol class="org-ol">
<li>用一个定义的模板语言为每个字母定义标语的格式，存入一个table中;
</li>
<li>写一个对这个自定义模板语言的解析程序，把它解析成打印标语;
</li>
<li>输入一个单词，直接读取table相应的模板格式，用解析程序解析。
</li>
</ol>

<p>
如字母I如下，可以把它编码成：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 lines 9 X
6 lines 3 blank 3 X 3 blank
3 lines 9 X
</pre>
</div>
<p>
或更简化：
</p>
<div class="org-src-container">

<pre class="src src-sh">3 9 X
6 3 b 3 x 3 b
3 9 x
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
         x  x  x         
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
x  x  x  x  x  x  x  x  x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">4</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Date</span> {
  <span style="color: #87cefa;">Date</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month_in</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_in</span>) {
    year = year_in;
    month = month_in;
    day = day_in;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>;
};

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMonthDays</span>[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">KDaysOfWeek</span> = 7;
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">YearDays</span> {
  <span style="color: #eedd82;">kNormYearDays</span> = 365,
  <span style="color: #eedd82;">kLeapYearDays</span> = 366,
};

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsLeapYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">year</span>) {
  <span style="color: #00ffff;">if</span> ((year % 400 == 0) ||
      (((year % 4) == 0) &amp;&amp; (year % 100) != 0)) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MonthDaysOfYear</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = kMonthDays[month];
  <span style="color: #00ffff;">if</span> (month == 2 &amp;&amp; IsLeapYear(year)) {
    days++;
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysOfYear</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  days += date.day;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt; date.month; ++i) {
    days += MonthDaysOfYear(date.year, i);
  }
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DaysBetween</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_pre</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date_next</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year_</span> = date_pre.year; year_ &lt; date_next.year; ++year_) {
    days += (IsLeapYear(year_) ? kLeapYearDays : kNormYearDays);
  }
  days += DaysOfYear(date_next);
  days -= DaysOfYear(date_pre);
  <span style="color: #00ffff;">return</span> days;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintCalendar</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; &amp;<span style="color: #eedd82;">calendar</span>) {
  printf(<span style="color: #ffa07a;">"Sun Mon Tue Wed Thu Fri Sat\n"</span>);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; KDaysOfWeek - calendar[0].size(); ++i) {
    printf(<span style="color: #ffa07a;">"    "</span>);
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; calendar.size(); ++i) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = 0; j &lt; calendar[i].size(); ++j) {
      printf(<span style="color: #ffa07a;">"%-4d"</span>, calendar[i][j]);
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DayOfWeek</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> &amp;<span style="color: #eedd82;">date</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">kFirstDate</span>(1900, 1, 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Mon</span>
  <span style="color: #00ffff;">return</span> (DaysBetween(kFirstDate, date) % 7 + 1);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">CalendarOfMonth</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">calendar</span>) {
  <span style="color: #98fb98;">Date</span> <span style="color: #eedd82;">first_of_month</span>(year, month, 1);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day_of_week</span> = DayOfWeek(first_of_month);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; MonthDaysOfYear(year, month); ++i) {
    temp.push_back(i);
    <span style="color: #00ffff;">if</span> ((day_of_week + i) % KDaysOfWeek == 6) {
      calendar-&gt;push_back(temp);
      temp.clear();
    }
  }
  printf(<span style="color: #ffa07a;">"Year:%d Month:%d\n"</span>, year, month);
  PrintCalendar(*calendar);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">5</h3>
<div class="outline-text-3" id="text-2-4">
<p>
查找后缀连字符的连接。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">kHyphWords</span>[] = {<span style="color: #ffa07a;">"et-ic"</span>, <span style="color: #ffa07a;">"al-is-tic"</span>, <span style="color: #ffa07a;">"s-tic"</span>, <span style="color: #ffa07a;">"p-tic"</span>, <span style="color: #ffa07a;">"-lyt-ic"</span>,
                      <span style="color: #ffa07a;">"ot-ic"</span>, <span style="color: #ffa07a;">"an-tic"</span>, <span style="color: #ffa07a;">"n-tic"</span>, <span style="color: #ffa07a;">"c-tic"</span>, <span style="color: #ffa07a;">"at-ic"</span>,
                      <span style="color: #ffa07a;">"h-nic"</span>, <span style="color: #ffa07a;">"n-ic"</span>, <span style="color: #ffa07a;">"m-ic"</span>, <span style="color: #ffa07a;">"l-lic"</span>, <span style="color: #ffa07a;">"b-lic"</span>,
                      <span style="color: #ffa07a;">"-clic"</span>, <span style="color: #ffa07a;">"l-ic"</span>, <span style="color: #ffa07a;">"h-ic"</span>, <span style="color: #ffa07a;">"f-ic"</span>, <span style="color: #ffa07a;">"d-ic"</span>,
                      <span style="color: #ffa07a;">"-bic"</span>, <span style="color: #ffa07a;">"a-ic"</span>, <span style="color: #ffa07a;">"-mac"</span>, <span style="color: #ffa07a;">"i-ac"</span>};

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">string</span>&gt; *<span style="color: #eedd82;">reverse_hyphs</span> = <span style="color: #7fffd4;">NULL</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ReverseHypenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">reverse_word</span>) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">kHypen</span> = <span style="color: #ffa07a;">'-'</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span> = strlen(word) - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0, j = 0; i &lt;= len; ++i) {
    <span style="color: #00ffff;">if</span> (word[len - i] == kHypen)
      <span style="color: #00ffff;">continue</span>;
    reverse_word[j++] = word[len - i];
  }
  reverse_word[j] = <span style="color: #ffa07a;">'\0'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RerverseWord</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">string</span> *<span style="color: #eedd82;">reverse_word</span>) {
  *reverse_word = word;
  reverse(reverse_word-&gt;begin(), reverse_word-&gt;end());
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PreProcessHyphenation</span>() {
  <span style="color: #00ffff;">if</span> (reverse_hyphs != <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span>;
  } <span style="color: #00ffff;">else</span> {
    reverse_hyphs = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">vector</span>&lt;string&gt;();
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = <span style="color: #00ffff;">sizeof</span>(kHyphWords) / <span style="color: #00ffff;">sizeof</span>(kHyphWords[0]);
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kMaxLen</span> = 10;
      <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">reverse_word</span>[kMaxLen];
      ReverseHypenation(kHyphWords[i], reverse_word);
      reverse_hyphs-&gt;push_back(<span style="color: #98fb98;">string</span>(<span style="color: #eedd82;">reverse_word</span>));
    }
  }
}

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsBeginWith</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">begin_letter</span>) {
  <span style="color: #00ffff;">if</span> (word.size() &lt; begin_letter.size()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; begin_letter.size(); ++i) {
    <span style="color: #00ffff;">if</span> (begin_letter[i] != word[i]) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">FindHyphenation</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">word</span>) {
  PreProcessHyphenation();
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">reverse_word</span>;
  RerverseWord(word, &amp;reverse_word);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; reverse_hyphs-&gt;size(); ++i) {
    <span style="color: #00ffff;">if</span> (IsBeginWith(reverse_word, reverse_hyphs-&gt;at(i))) {
      <span style="color: #00ffff;">return</span> string(kHyphWords[i]);
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>;
}
</pre>
</div>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
