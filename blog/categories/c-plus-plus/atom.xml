<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | (learn&think)]]></title>
  <link href="http://dreamrunner.org/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://dreamrunner.org/"/>
  <updated>2014-07-06T18:36:08+08:00</updated>
  <id>http://dreamrunner.org/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[High Resolution Time]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/24/high-resolution-time/"/>
    <updated>2014-06-24T20:19:36+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/24/high-resolution-time</id>
    <content type="html"><![CDATA[<p>在不同的平台有繁多的 Time API，如何选用精准的高精度 Time 函数来做
performance benchmarking 呢？</p>

<h2 id="wall-clock-time-vs-cpu-time">Wall-clock time VS CPU time</h2>
<p>先理解一些时间的概念。明白不同时间 API 测量的是什么时间。</p>

<p><a href="http://en.wikipedia.org/wiki/Wall-clock_time">Wall-clock time</a>,顾名思
义，墙上的钟，代表一个任务从开始到完成所经历的时间。它包含 3 部分：CPU 的
时间，I/O 的时间和通信延迟的时间。但 wall-clock 很少是正确的时钟来使用，
因为它随着时区，和 daylightsaving 改变，或与 NTP 同步。而这些特性没有一个
是有益的，如果你用它来调度任务或做 performance benchmarking。它仅仅如名
字所言，墙上的一个时钟。</p>

<p><a href="http://en.wikipedia.org/wiki/CPU_time">CPU time</a> 仅仅统计一个任务从开
始到完成在 CPU 上所花的时间。CPU time 主要包括 User time（在 user space 所花
时间）和 System time（在 kernel space 所花时间）。</p>

<p>以并行程序为例，CPU time 就是所有 CPU 在这个程序所花的时间总和，
Wall-clock time 在这种情况可能时间相对短，它只统计任务开始到结束所花时
间。</p>

<!-- more -->

<h2 id="api-f1">不同时钟 API 对比<sup id="fnref:f1"><a href="#fn:f1" rel="footnote">1</a></sup></h2>
<p>对于不同的时钟 API,主要分析如下特性：</p>

<ol>
  <li>API 测试的是什么时间？（real, user, system，CPU or wall-clock)</li>
  <li>API 的精度？(s, ms, µs, or faster?)</li>
  <li>多久时间这个时钟数字会返转？或有什么策略避免它？</li>
  <li>时钟是 monotonic 的，还是它会随着系统时间改变（比如 NTP，time zone，
daylight saving time, by the user, etc)?</li>
</ol>

<p>Linux 和 OS X 的主要时钟 API：</p>

<ul>
  <li><a href="http://linux.die.net/man/2/time">time()</a>返回系统的 wall-clock，精度
到秒。</li>
  <li><a href="http://linux.die.net/man/3/clock">clock()</a>返回 user 和 systime 总共的时
间.现在标准要求<code>CLOCKS_PER_SEC</code>是<code>1000000</code>,使精度最多达到
1µs.<code>clock_t</code>类型平台相关(The range and precision of times
representable in clock_t and time_t are implementation-defined.) 它
wrap around 一旦达到最大值.(通常是 32 位的类型,那么~2^32 ticks 后,还是比
较长的时间.)</li>
  <li><a href="http://linux.die.net/man/3/clock_gettime">clock_gettime(CLOCK_MONOTONIC,..)</a>
提供纳秒级的精确度并且是单调的.它的秒和纳秒是分开存储的,所以,任何的
wrap around 将很多年才发生一次.它是个不错的时钟,但 OS X 平台上没有.</li>
  <li><a href="http://linux.die.net/man/2/getrusage">getrusage</a> 返回独立的 user 和
system 时间,并且不会 wrap around.精确达到 1 µs,</li>
  <li><a href="http://linux.die.net/man/2/gettimeofday">gettimeofday</a> 返回一个
wall-clock 时间并达到µs 精度.但是精度不能保证,因为<a href="http://www.lehman.cuny.edu/cgi-bin/man-cgi?gettimeofday+3">依赖于硬件</a>.</li>
  <li><a href="https://developer.apple.com/library/mac/qa/qa1398/_index.html">mach_absolute_time()</a>
是 OS X 平台的高精度(ns)计时的一个选择.ns 以 64 位 unsigned integer 存储,实
际使用 wrap around 不是大问题,移植性是问题.</li>
</ul>

<p>Window 的高精度时钟：</p>

<p><a href="http://msdn.microsoft.com/en-us/library/ms644905(VS.85).aspx">QueryPerformanceFrequency()</a>
和
<a href="http://msdn.microsoft.com/en-us/library/ms644904(v=VS.85).aspx">QueryPerformanceCounter()</a>.
QueryPerformanceFrequency() 返回计数的频率,QueryPerformanceCounter()返
回当前计数值.和 Linux 中 CLOCK_MONOTONIC 一样,它是一个稳定并单调递增计数器,精
准达到纳秒级,并且不会 wrap around.</p>

<p>更多参考:</p>

<ul>
  <li><a href="https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time">gettimeofday() should never be used to measure time</a></li>
  <li><a href="http://tdistler.com/2010/06/27/high-performance-timing-on-linux-windows">High-performance Timing on Linux / Windows</a></li>
</ul>

<h2 id="high-resolution-time">不同平台 High Resolution Time</h2>

<h3 id="linux">Linux</h3>
<p>使用
<a href="http://linux.die.net/man/3/clock_gettime">clock_gettime(CLOCK_MONOTONIC,..)</a>
作为 High Resolution Time,编译需加上参数<code>-lrt</code>,实例代码如下:</p>

<p>``` c clock_gettime.c
#include <time.h>
#include <stdio.h /></time.h></p>

<p>void GetMonotonicTime(struct timespec *ts) {
  clock_gettime(CLOCK_MONOTONIC, ts);
}</p>

<p>double GetElapsedTime(struct timespec *before, struct timespec *after) {
  double delta_s = after-&gt;tv_sec - before-&gt;tv_sec;
  double delta_ns = after-&gt;tv_nsec - before-&gt;tv_nsec;
  return delta_s * 1e9 + delta_ns;
}</p>

<p>int main(int argc, char *argv[]) {
  struct timespec before, after;
  GetMonotonicTime(&amp;before);
  double sum = 0.0;
  unsigned int i;
  for (i = 1; i &lt; 100; ++i) {
    sum += 1.0 / i;
  }
  GetMonotonicTime(&amp;after);
  printf(“the elapsed time=%e ns\n”, GetElapsedTime(&amp;before, &amp;after));
  return 0;
}
```</p>

<p>除了<code>clock_gettime()</code>高精度时钟外,还有相对应的高精度的睡眠函数
<a href="http://pubs.opengroup.org/onlinepubs/000095399/functions/clock_nanosleep.html">clock_nanosleep</a>,
实例代码如下:</p>

<p>``` c clock_nanosleep.c
#include <time.h /></p>

<p>int main(int argc, char *argv[])
{
  struct timespec sleep_time;
  sleep_time.tv_sec = 0;
  sleep_time.tv_nsec = 100;
  clock_nanosleep(CLOCK_REALTIME, 0, &amp;sleep_time, NULL);
  return 0;
}
```</p>

<h3 id="os-x">OS X</h3>

<h3 id="clockgettime">使用<code>clock_get_time</code></h3>
<p>``` c clock_get_time.c
#include <time.h>
#include <stdio.h>
#include &lt;mach/clock.h&gt;
#include &lt;mach/mach.h&gt;</stdio.h></time.h></p>

<p>void GetMonotonicTime(struct timespec *ts) {
  clock_serv_t cclock;
  mach_timespec_t mts;
  host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &amp;cclock);
  clock_get_time(cclock, &amp;mts);
  mach_port_deallocate(mach_task_self(), cclock);
  ts-&gt;tv_sec = mts.tv_sec;
  ts-&gt;tv_nsec = mts.tv_nsec;
}</p>

<p>double GetElapsedTime(struct timespec *before, struct timespec *after) {
  double delta_s = after-&gt;tv_sec - before-&gt;tv_sec;
  double delta_ns = after-&gt;tv_nsec - before-&gt;tv_nsec;
  return delta_s * 1e9 + delta_ns;
}</p>

<p>int main(int argc, char *argv[]) {
  struct timespec before, after;
  GetMonotonicTime(&amp;before);
  double sum = 0.0;
  unsigned int i;
  for (i = 1; i &lt; 100; ++i) {
    sum += 1.0 / i;
  }
  GetMonotonicTime(&amp;after);
  printf(“the elapsed time=%e ns\n”, GetElapsedTime(&amp;before, &amp;after));
  return 0;
}
```</p>

<h3 id="machabsolutetime">使用<code>mach_absolute_time</code></h3>
<p><code>c mach_absolute_time.c
int main(int argc, char *argv[]) {
    uint64_t        start;
    uint64_t        end;
    uint64_t        elapsed;
    Nanoseconds     elapsedNano;
    start = mach_absolute_time();
    double sum = 0.0;
    unsigned int i;
    for (i = 1; i &lt; 100; ++i) {
        sum += 1.0 / i;
    }
    end = mach_absolute_time();
    elapsed = end - start;
    // Convert to nanoseconds
    elapsedNano = AbsoluteToNanoseconds( *(AbsoluteTime *) &amp;elapsed );
}
</code></p>

<h3 id="windows">Windows</h3>
<p>``` c++ query_performance.cc
#include <iostream>
#include <windows.h> 
using namespace std;</windows.h></iostream></p>

<p>int main()
{
    LARGE_INTEGER frequency;
    LARGE_INTEGER start, end;
    double elapsedTime;</p>

<pre><code>// get ticks per second
QueryPerformanceFrequency(&amp;frequency);

QueryPerformanceCounter(&amp;start);

//do someting
double sum = 0.0;
unsigned int i;
for (i = 1; i &lt; 100; ++i) {
    sum += 1.0 / i;
}

QueryPerformanceCounter(&amp;end);

// compute and print the elapsed time in millisec
elapsedTime = (end.QuadPart - start.QuadPart) * 1000.0 / frequency.QuadPart;
cout &lt;&lt; elapsedTime &lt;&lt; " ms.\n";
return 0; } ```
</code></pre>

<div class="footnotes">
  <ol>
    <li id="fn:f1">
      <p>http://stackoverflow.com/questions/12392278/measure-time-in-linux-getrusage-vs-clock-gettime-vs-clock-vs-gettimeofday<a href="#fnref:f1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Last Thing D Needs总结]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie/"/>
    <updated>2014-06-01T16:24:47+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#initialization">Initialization</a></li>
  <li><a href="#type-deduction">Type Deduction</a></li>
  <li><a href="#inheritance">Inheritance</a></li>
  <li><a href="#computational-complexity">Computational Complexity</a></li>
  <li><a href="#apis">APIs</a></li>
  <li><a href="#specifications">Specifications</a></li>
  <li><a href="#essential-and-accidental-complexity">Essential and Accidental Complexity</a></li>
</ul>

<p><a href="http://www.amazon.com/gp/product/0321334876?ie=UTF8&amp;tag=aristeia.com-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321334876">Effective C++</a>
系列的作者 <a href="http://www.aristeia.com/">Scott Meyers</a> 在 Dconf 中 <a href="http://www.ustream.tv/recorded/47947981">The Last Thing D Needs</a> 聊了些 C++的
特性，稍微总结一下。</p>

<h2 id="initialization">Initialization</h2>

<p><code>c++ Initialization
int x1;         // unknown, initial(pay for it)
int x2;         // (at global scope) 0, no run time cost
static int x3;  // 0, static initialization
int *px = new int;  // heap memory, unknown, has run time cost
{
    int x4;    // unknown, has run time cost 
}
int a1[100];   // unknown
int a2[100];   // (at global scope) 0
static int a3[100];  // 0
std::vector&lt;int&gt; v(100);  // 0, use run time cost
</code></p>

<!-- more -->

<h2 id="type-deduction">Type Deduction</h2>
<p>``` c++ Type Deduction
const int cx = 0;
auto my_cx1 = cx;          // int, new independent value
decltype(cx) my_cx2 = cx;  // const int, standard said</p>

<p>template<typname t="">
void f1(T param);
f1(cx);                    // T's type, int, same rules with auto</typname></p>

<p>template<typename t="">
void f2(T&amp; param);
f2(cx);                   //T's type, const int, reference a chunk of memory, preserve the const</typename></p>

<p>template<typename t="">
void f3(T&amp;&amp; param);
f3(cx);                  //T's type, const int&amp;, perfect argument forwarding, a special rule</typename></p>

<p>const int cx = 0;
auto lam= [cx] {cx = 10;};       //error!
class UpToTheCompiler {
private:
  ??? cx;                      //const int
  …
};</p>

<p>const int cx = 0;
auto lam= [cx = cx] {cx = 10;};     //error!
class UpToTheCompiler {
private:
  ??? cx;                          //int (but acts like const int)
  …
public:
  void operator() const
  {cx = 0;}
};</p>

<p>const int cx = 0;
auto lam1= [cx = cx] mutable {cx = 10;};     //error!
auto lam2= <a href="">cx = cx</a> mutable {cx = 10;};     //correct
class UpToTheCompiler {
private:
  ??? cx;                          //int (but acts like int)
  …
};
```</p>

<p>For
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const int cx = 0;</span></code></pre></td></tr></table></div></figure></notextile></div>
type deduction for cx yields:</p>

<style>
table,th,td
{
border:1px solid black;
}
</style>

<table border="1" style="width:500px">
<tr>
<th> Context </th>
<th> Type </th>
</tr>

<tr>
<td> auto </td>
<td> int </td>
</tr>

<tr>
<td> decltype </td>
<td>  const int</td>
</tr>

<tr>
<td> template(T parameter)  </td>
<td> int </td>
</tr>

<tr>
<td> template(T&amp; parameter)  </td>
<td> const int </td>
</tr>

<tr>
<td> template(T&amp;&amp; parameter)  </td>
<td> const int&amp; </td>
</tr>

<tr>
<td> lambda (by-value capture) </td>
<td> const int  </td>
</tr>

<tr>
<td> lambda (int capture) </td>
<td>  int</td>
</tr>
</table>

<p>``` c++ Type Deduction
//all do the same thing
int x1 = 0;
int x2(0);
int x3 = {0};
int x4 {0};</p>

<p>auto x1 = 0;  // int
auto x2(0);   // int
auto x3 = {0};// initializer_list<int>
auto x4 {0};  // initializer_list<int /></int></p>

<p>template <typname t="">
void f(T param);
f({0});       // error! "{0}" has no type
```</typname></p>

<h2 id="inheritance">Inheritance</h2>
<p>``` c++ inheritance
class Base {
public:
  void doBaseWork();
};
class Derived : public Base {
public:
  void doDerivedWord() {
    doBaseWord();               //ok
  }
};</p>

<p>template <typename t="">
class Base {
public:
  void doBaseWork();
};
template <typename t="">
class Derived : public Base<t> {
public:
  void doDerivedWord() {
    doBaseWord();               //no compile, later specialized version
  }
};</t></typename></typename></p>

<p>template &lt;&gt;
class Base<int> ();  // no doBasework</int></p>

<p>Derived<int> d;
d.doDerivedWord();  // fail
```</int></p>

<p>In essence, the <strong>One Definition Rule</strong> states that the same entity should have the exact same definition throughout an application, otherwise the effects are undefined.</p>

<p>The fundamental problem is that the code that doesn’t see the specialized version of your class template member function might still compile, is likely to link, and sometimes might even run. This is because in the absence of (a forward declaration of) the explicit specialization, the non-specialized version kicks in, likely implementing a generic functionality that works for your specialized type as well.</p>

<h2 id="computational-complexity">Computational Complexity</h2>
<p>``` c++ computational Complexity
std::vector<int> v;
...
std::sort(v.begin(), v.end());   // O(nlogn)</int></p>

<p>std::list<int> li;
...
std::sort(li.begin(), li.end());  // not compile, list doesnot have random access iterator</int></p>

<p>auto it1 =
std::binary_search(v.begin(), v.end(), 10);  // O(logn)</p>

<p>auto it2 =
std::binary_search(li.begin(), li.end(), 10);  // O(n), officially(number of compares): O(logn)
```</p>

<h2 id="apis">APIs</h2>

<p><code>c++ example
std::set&lt;int&gt; si;
...
si.erase(14);    // eliminate all 14s from si
</code></p>

<ul>
  <li>set             –&gt;  erase</li>
  <li>multiset        –&gt;     erase</li>
  <li>map             –&gt;     erase</li>
  <li>multimap        –&gt;     erase</li>
  <li>unordered_set   –&gt;     erase</li>
  <li>unordered_multiset –&gt;  erase</li>
  <li>unordered_map      –&gt;  erase</li>
  <li>unordered_multimap –&gt;  erase</li>
  <li>list               –&gt;  remove</li>
  <li>forward_list       –&gt;  remove</li>
</ul>

<p>Sorts can be stable or unstable. Which are guaranteed to be stable?
* sort –&gt; not guaranteed
* stable_sort  –&gt; guaranteed
* list::sort –&gt; guaranteed</p>

<h2 id="specifications">Specifications</h2>
<p>Five sequence containers:</p>

<ul>
  <li>array –&gt; No</li>
  <li>deque –&gt; Yes</li>
  <li>forward_list  –&gt; No(fulfill of 1 of 16)</li>
  <li>list  –&gt; Yes</li>
  <li>vector – &gt; Yes</li>
</ul>

<h2 id="essential-and-accidental-complexity">Essential and Accidental Complexity</h2>
<p>Essential Complexity: due to inherent design tensions.</p>

<ul>
  <li>Simplicity and regularity vs expressiveness.</li>
  <li>Abstraction and portability vs efficiency.</li>
  <li>New approaches vs compatibility with legacy systems.</li>
  <li>Expressiveness vs ability to issue good diagnostics.</li>
</ul>

<p><em>Essential Complexity</em></p>

<p><code>c++ Point
struct Point {
  int x, y;
};
</code>
What is the type of Point::x?</p>

<p><code>c++ Point
Point p;
const Point &amp;cp = p;
</code>
What is the type of cp.x?</p>

<p>C++ soluction:</p>

<p><code>c++
decltype(cp.x) = int
decltype((cp.x)) = const int&amp;
</code></p>

<p><code>c++ inheritance
template &lt;typename T&gt;
class Base {
public:
  void doBaseWork();
};
template &lt;typename T&gt;
class Derived : public Base&lt;T&gt; {
public:
  void doDerivedWord() {
    doBaseWrd();               //okay?
  }
};
</code></p>

<p>Assume typo and diagnose now?</p>

<ul>
  <li>Wrong if later specialization offers doBaseWrk.</li>
</ul>

<p>Assume later specialization and defer lookup until instantiation?</p>

<ul>
  <li>If typo, imposes diagnostics for library errors on clients.</li>
</ul>

<p>C++ solution:</p>

<ul>
  <li>Template author has control
    <ul>
      <li>doBaseWrk() -&gt; lookup name when parsing template.</li>
      <li>this-&gt;doBaseWrk() -&gt; lookup name when instantiating template.</li>
    </ul>
  </li>
</ul>

<p><em>Accidental Complexity</em></p>

<ul>
  <li>ints are sometimes initialized to 0.</li>
  <li>By-value lambda capture somtimes retains the constness of what’s captured.</li>
  <li>mutable lambdas must declare a parameter list, but non-mutable lambdas don’t</li>
  <li>Braced initializers (e.g.”{0}”) sometimes have a type.</li>
  <li>Computation complexity guarantees usually meaningful.</li>
  <li>Elimination all container elements with a given value usually means
calling <code>erase</code>.</li>
  <li><code>sort</code> is sometimes stable.</li>
  <li>Container “requirements” are sometimes required.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gflags 简明使用]]></title>
    <link href="http://dreamrunner.org/blog/2014/03/09/gflags-jian-ming-shi-yong/"/>
    <updated>2014-03-09T11:53:54+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/03/09/gflags-jian-ming-shi-yong</id>
    <content type="html"><![CDATA[<h2 id="section">简介</h2>
<p>Google 的 gflags 是一套命令行参数处理的开源库。比 getopt 更方便，更功能强大，从 C++的库更好的支持 C++（如 C++的 string 类型）。包括 <a href="https://code.google.com/p/gflags/">C++的版本</a>和 <a href="https://code.google.com/p/python-gflags/">python 的版本</a>。 这里只针对 C++版本，python 版本的使用类似。主要内容参考与翻译自官方文档：http://gflags.googlecode.com/svn/trunk/doc/gflags.html</p>

<p>你能从<a href="/downloads/code/2014/cmake_gflags_example.zip">这里下载</a>本文章的源代码工程。</p>

<!-- more -->

<h2 id="example-">example 源代码</h2>
<p>先看 example 源代码，然后逐步介绍。</p>

<p>``` c++ example.cc
#include &lt;gflags/gflags.h&gt;</p>

<p>DEFINE_bool(big_menu, true, “Include ‘advanced’ options in the menu listing”);
DEFINE_string(languages, “english,french,german”, “comma-separated list of languages to offer in the ‘lang’ menu”);</p>

<p>int main(int argc, char **argv) {
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</p>

<p>cout « “argc=” « argc « endl;
  if (FLAGS_big_menu) {
    cout « “big menu is ture” « endl;
  } else {
    cout « “big menu is flase” « endl;
  }</p>

<p>cout « “languages=” « FLAGS_languages « endl;
  return 0;
}
```</p>

<h3 id="section-1">运行程序</h3>
<ul>
  <li>直接运行</li>
</ul>

<p><code>bash run
  ➜  bin  ./sample 
  argc=1
  big menu is ture
  languages=english,french,german
</code>
* help 命令</p>

<p>``` bash run
  ➜  bin  ./sample –help
  sample: Warning: SetUsageMessage() never called</p>

<p>Flags from /home/shougang/workspace/drive/Google/cmake_cpp_gflags/src/sample.cc:
    -big_menu (Include ‘advanced’ options in the menu listing) type: bool
      default: true
    -languages (comma-separated list of languages to offer in the ‘lang’ menu)
      type: string default: “english,french,german”</p>

<p>Flags from src/gflags.cc:
    -flagfile (load flags from file) type: string default: “”
  ………</p>

<p>➜  bin  ./sample –helpshort 
  sample: Warning: SetUsageMessage() never called</p>

<p>Flags from /home/shougang/workspace/drive/Google/cmake_cpp_gflags/src/sample.cc:
    -big_menu (Include ‘advanced’ options in the menu listing) type: bool
      default: true
    -languages (comma-separated list of languages to offer in the ‘lang’ menu)
      type: string default: “english,french,german”
```</p>

<h2 id="section-2">在程序里定义参数</h2>
<p>### 包含头文件</p>

<p><code>c++ header_file
 #include &lt;gflags/gflags.h&gt;
</code></p>

<h3 id="gflag-">利用 gflag 提供的宏定义参数</h3>
<p>该宏的 3 个参数分别为命令行参数名，参数默认值，参数的帮助信息。</p>

<p><code>c++ define_flags
DEFINE_bool(big_menu, true, "Include 'advanced' options in the menu listing");
DEFINE_string(languages, "english,french,german", "comma-separated list of languages to offer in the 'lang' menu");
</code>
gflags 暂时支持如下参数的类型：</p>

<p><code>sh supported_types
DEFINE_bool: boolean
DEFINE_int32: 32-bit integer
DEFINE_int64: 64-bit integer
DEFINE_uint64: unsigned 64-bit integer
DEFINE_double: double
DEFINE_string: C++ string
</code></p>

<h2 id="section-3">访问参数</h2>

<p>通过 FLAGS_name 像正常变量一样访问标志参数。在这个程序中，通过
<code>FLAGS_big_menu</code>和<code>FLAGS_languages</code>访问它们。</p>

<h2 id="section-4">不同文件访问参数</h2>

<p>如果想再另外一个不是定义这个参数的文件访问这个参数的话，以参数
<code>FLAGS_big_menu</code>为例，用宏<code>DECLARE_bool(big_menu）</code>来声明引入这个参数。
这个宏相当于做了<code>extern FLAGS_big_menu</code>.</p>

<h2 id="section-5">整合一起，初始化所有参数</h2>

<p>定义号参数后，最后要告诉执行程序去处理命令行传入的参数，使得
<code>FLAGS_*</code>参数们得到正确赋值。</p>

<p>通常就是再<code>main()</code>函数中调用;</p>

<p><code>c++ set_up_flag
google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
</code>
<code>argc</code>和<code>argv</code>就是 main 的入口参数，因为这个函数会改变他们的值，所以都是
以指针传入。</p>

<p>第三个参数被称为<code>remove_flags</code>。如果它是<code>true</code>,<code>ParseCommandLineFlags</code>会
从<code>argv</code>中移除标识和它们的参数，相应减少<code>argc</code>的值。然后 argv 只保留命令
行参数。</p>

<p>相反，<code>remove_flags</code>是<code>false</code>,<code>ParseCommandLineFlags</code>会保留<code>argc</code>不变，
但将会重新调整它们的顺序，使得标识再前面。</p>

<p>Note: <code>./sample --big_menu=false arg1</code>中再<code>big_menu</code>是标识，<code>false</code>是
它的参数，<code>arg1</code>是命令行参数。</p>

<h2 id="section-6">命令行设置参数</h2>
<p>gflags 提供多种命令行设置参数。</p>

<p><code>string</code>和<code>int</code>之类，可以用如下方式：</p>

<p><code>bash set_languages
app_containing_foo --languages="chinese,japanese,korean"
app_containing_foo -languages="chinese,japanese,korean"
app_containing_foo --languages "chinese,japanese,korean"
app_containing_foo -languages "chinese,japanese,korean"
</code>
对于<code>boolean</code>的标识来说，用如下方式:</p>

<p><code>bash set_boolean
app_containing_foo --big_menu
app_containing_foo --nobig_menu
app_containing_foo --big_menu=true
app_containing_foo --big_menu=false
</code></p>

<p>和<code>getopt()</code>一样，<code>--</code>将会终止标识的处理。所以在<code>foo -f1 1 -- -f2 2</code>中，
<code>f1</code>被认为是一个标识，但<code>f2</code>不会。</p>

<h2 id="section-7">特殊标识</h2>

<p><code>bash special_flags
--help  显示文件中所有标识的完整帮助信息
--helpfull  和-help 一样，
--helpshort  只显示当前执行文件里的标志
--helpxml  以 xml 凡是打印，方便处理
--version  打印版本信息，由 google::SetVersionString()设定
--flagfile  -flagfile=f 从文件 f 中读取命令行参数
...
</code>
具体见：http://gflags.googlecode.com/svn/trunk/doc/gflags.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++测试驱动开发与单元测试实例]]></title>
    <link href="http://dreamrunner.org/blog/2014/03/08/C%2B%2B%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/"/>
    <updated>2014-03-08T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/03/08/C++测试驱动开发与单元测试实例</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 测试驱动开发基础</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 测试驱动开发</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<a href="http://en.wikipedia.org/wiki/Test-driven_development">测试驱动开发(TDD)</a>是一种软件开发流程，依赖于重复如下一小段开发周期：
</p>
<ol class="org-ol">
<li>开发者定义一个初始将失败的自动测试用例，这个用例用来实现需要的改进或新的功能;
</li>
<li>写出最小的代码来通过此测试;
</li>
<li><a href="http://en.wikipedia.org/wiki/Code_refactoring">重构</a>这段新代码来符合规范。
</li>
</ol>

<p>
TDD 有它自身的
<a href="http://en.wikipedia.org/wiki/Test-driven_development#Benefits">优点</a>与
<a href="http://en.wikipedia.org/wiki/Test-driven_development#Vulnerabilities">缺点</a>
</p>

<!-- more -->

<p>
TDD 的一个周期可以总结如下:<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
<ol class="org-ol">
<li>快速加一个测试
</li>
<li>运行所有测试，然后发现新测试失败
</li>
<li>修改代码，让新测试通过
</li>
<li>运行所有测试并都通过
</li>
<li>重构代码
</li>
</ol>

<img src="/images/blog/2014/Test-driven_development.PNG" title="'TDD'" >
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 单元测试与其框架</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<a href="http://en.wikipedia.org/wiki/Unit_testing">单元测试(unit testing)</a>是测试一小段独立代码其是否正确的一种方法。
</p>

<p>
单元测试的目标是隔离程序的每个部件并证明这些单个部件是正确的。一个单元测
试提供了代码片断需要满足的严密的规约。因此，单元测试带来了一些益处：
</p>
<ol class="org-ol">
<li>尽早找出问题。在 TDD 开发中，一般单元测试程序先写与代码。
</li>
<li>适应变更。单元测试允许程序员在未来重构代码时，确保代码依然工作正确。
</li>
<li>简化集成。单元测试消除程序单元的不可靠，适合于自底向上的测试方法。通
过先测试程序部件再测试部件组装，使集成测试变得更加简单。
</li>
<li>文档记录。单元测试提供了系统的一种文档记录。借助于查看单元测试提供
的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元
的基础 API。
</li>
<li>表达设计。在测试驱动开发的软件实践中，单元测试可以取代正式的设计。
每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。
</li>
</ol>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 单元测试的框架</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
为了简单与系统化单元测试过程，基本借助于单元测试框架。如今基本任何编程
语言都有几套自身的单元测试框架。而且广泛使用的框架都是<a href="http://en.wikipedia.org/wiki/XUnit">属于 xUnit 家族</a>
（CppUnit, JUnit, PyUnit, and etc.)。xUnit 系的框架易于使用，提供一套自
动化测试的方案。所有的 xUint 框架拥有如下的基本元件框架：
</p>
<ul class="org-ul">
<li>Assertions。验证程序某一结果。
</li>
<li>Test case（测试用例）。包含某个功能的多个 Assertions。
</li>
<li>Test suites（测试套件）。包含多个相关的测试用例。
</li>
<li>Test fixtures（测试夹具）。提供测试开始时执行数据或状态的初始化，结
束时执行数据或状态的清理工作。
</li>
<li>同时包括 Test runner，Test execution 和 Test result formatter。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 模仿对象</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如
果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。
</p>

<p>
在下面的情形，可能使用模拟对象来代替真实对象更好:
</p>
<ul class="org-ul">
<li>真实对象的行为是不确定的（例如，当前的时间或当前的温度）；
</li>
<li>真实对象很难搭建起来；
</li>
<li>真实对象的行为很难触发（例如，网络错误）；
</li>
<li>真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；
</li>
<li>真实对象可能还不存在或之后会改动；
</li>
<li>真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。
</li>
</ul>

<p>
模拟对象具有和要模拟的真实对象的相同的接口，可以让调用该接口的对象不知
道在使用真实对象还是模拟对象。现有的许多模拟对象框架允许程序员指定模拟
对象上的哪些方法，将按照什么顺序被调用，以及传入什么参数，将返回什么值。
这样，复杂对象（例如网络套接字）的行为将可以使用模拟对象来模拟，允许程
序员来发现被测对象在可能各种存在的状态是否响应正确。
</p>

<p>
典型的流程基本如下：
</p>
<ol class="org-ol">
<li>指定你需要测试的类的接口
</li>
<li>根据接口，用某个模拟框架来创建一个模拟类
</li>
<li>接下来就如单元测试一样，建立测试用例，用这个模拟对象代替实际的对象。
一般按照如下进行：
<ul class="org-ul">
<li>首先创建模拟类实例
</li>
<li>针对模拟类，设置它的预期的行为。也就是那个方法被会被调用，数据返
回什么对于特定调用等。
</li>
<li>针对模拟类的行为，调用并判断预期的结果是否符合实际要求。
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 如何组织测试实例</h3>
<div class="outline-text-3" id="text-1-3">
<p>
应该为所有外部可以访问的函数创建单元测试：没有定义为 static 的自由函数，
类里的公共函数。单元测试应该涵盖函数的主要运行路径，包括不同的分支，循
环等。必须处理细小的，边缘情况，提供错误或随即的数据，使得你能测试你的
错误处理功能。
</p>

<p>
如何写好单元测试（比如每个测试只做一件事，测试需要短小而简洁等），需要
好好设计与思考，比较好的单元测试指南<a href="http://geosoft.no/development/unittesting.html">这里</a>.
</p>

<p>
把很多个测试用例组合到一个大的函数中，是否更好提供代码的可读性与提高它
的简洁性呢。并不是，这样做并不好，参考<a href="http://www.boost.org/doc/libs/1_45_0/libs/test/doc/html/utf/user-guide/test-organization.html">这里</a>.
</p>

<p>
代码的可测试性同样依赖于代码的设计上。很多时候很难写好单元测试，是因为
要测试的功能隐藏在很多个接口里，或存在很多的互相依赖以致很难正确初始化
它们。基本的代码设计原则是：
</p>
<ul class="org-ul">
<li>代码需要松耦合——类或函数越少的依赖越好;
</li>
<li>避免设计复杂的大函数，尽量一个函数做一件事情;
</li>
<li>尽量减少公共接口。
</li>
</ul>

<p>
更多的模式设计原则在
<a href="http://googletesting.blogspot.hk/2008/08/by-miko-hevery-so-you-decided-to.html">Google Test Blog</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 面向 C++的测试实例</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 面向 C++的单元测试</h3>
<div class="outline-text-3" id="text-2-1">
<p>
使用 GTest 做单元测试和使用 Gmock 做模拟类测试。
</p>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 面向 C++的单元测试和 GTest 实践</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
现在有很多 C++的<a href="http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C.2B.2B">单元测试框架</a>。最受欢迎的是<a href="https://code.google.com/p/googletest/">Google C++ Testing Framework</a>
和<a href="http://www.boost.org/doc/libs/1_55_0/libs/test/doc/html/index.html">Boost.Test</a>。 两者有很多相似之处，这里针对 Google Testing Framework 展
开一个简单的实例。整个代码可以在<a href="https://github.com/shishougang/cpp_test_examples">github 下载</a>。
</p>

<p>
Google C++ Testing Framework 提供比较完善的文档，现在更新到 V1.7：
</p>
<ul class="org-ul">
<li><a href="https://code.google.com/p/googletest/wiki/V1_7_Primer">入门</a>
</li>
<li><a href="https://code.google.com/p/googletest/wiki/V1_7_Samples">例子</a>
</li>
<li><a href="https://code.google.com/p/googletest/wiki/V1_7_AdvancedGuide">高级指南</a>
</li>
<li><a href="https://code.google.com/p/googletest/wiki/V1_7_FAQ">FAQ</a>
</li>
</ul>

<p>
使用 Google C++ Testing Framework 基本流程：
</p>
<ol class="org-ol">
<li>建立要测试类或函数的单元测试文件，一般命名 <code>name_unittest.cc</code>, 包含
   <code>&lt;gtest/gtest.h&gt;</code> 头文件；
</li>
<li>针对类或函数的功能，建立相对应的测试用例，一般就是一大堆的 assertion，
检验希望得到的返回值是否正确；
</li>
<li>编译后，链接 GTest 相应的库 <code>gtest gtest_main</code> ；
</li>
<li>运行单元测试程序，或输出测试结果，或直接查看
</li>
</ol>
</div>

<div id="outline-container-sec-2-1-1-1" class="outline-5">
<h5 id="sec-2-1-1-1"><span class="section-number-5">2.1.1.1</span> 使用 Google Test 提供的第一个实例</h5>
<div class="outline-text-5" id="text-2-1-1-1">
<p>
<code>sample1.c</code> 有两个需要测试的函数：
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Factorial</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = 1;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1; i &lt;= n; i++) {
    result *= i;
  }

  <span style="color: #00ffff;">return</span> result;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Returns true iff n is a prime number.</span>
<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsPrime</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Trivial case 1: small numbers</span>
  <span style="color: #00ffff;">if</span> (n &lt;= 1) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Trivial case 2: even numbers</span>
  <span style="color: #00ffff;">if</span> (n % 2 == 0) <span style="color: #00ffff;">return</span> n == 2;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Now, we have that n is odd and n &gt;= 3.</span>

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Try to divide n by every odd number i, starting from 3</span>
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 3; ; i += 2) {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">We only have to try i up to the squre root of n</span>
    <span style="color: #00ffff;">if</span> (i &gt; n/i) <span style="color: #00ffff;">break</span>;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Now, we have i &lt;= n/i &lt; n.</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If n is divisible by i, n is not prime.</span>
    <span style="color: #00ffff;">if</span> (n % i == 0) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">n has no integer factor in the range (1, n), and thus is prime.</span>
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>
</div>

<p>
创建它的一个单元测试文件 <code>sample1_unittest.c</code> 。
单元测试文件清晰的设计了各个测试。
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">FactorialTest</span>, <span style="color: #98fb98;">Negative</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This test is named "Negative", and belongs to the "FactorialTest"</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">test case.</span>
  EXPECT_EQ(1, Factorial(-5));
  EXPECT_EQ(1, Factorial(-1));
  EXPECT_GT(Factorial(-10), 0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;TechnicalDetails&gt;</span>
  <span style="color: #ff7f24;">//</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXPECT_EQ(expected, actual) is the same as</span>
  <span style="color: #ff7f24;">//</span>
  <span style="color: #ff7f24;">//   </span><span style="color: #ff7f24;">EXPECT_TRUE((expected) == (actual))</span>
  <span style="color: #ff7f24;">//</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">except that it will print both the expected value and the actual</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">value when the assertion fails.  This is very helpful for</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">debugging.  Therefore in this case EXPECT_EQ is preferred.</span>
  <span style="color: #ff7f24;">//</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">On the other hand, EXPECT_TRUE accepts any Boolean expression,</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and is thus more general.</span>
  <span style="color: #ff7f24;">//</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;/TechnicalDetails&gt;</span>
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests factorial of 0.</span>
<span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">FactorialTest</span>, <span style="color: #98fb98;">Zero</span>) {
  EXPECT_EQ(1, Factorial(0));
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests factorial of positive numbers.</span>
<span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">FactorialTest</span>, <span style="color: #98fb98;">Positive</span>) {
  EXPECT_EQ(1, Factorial(1));
  EXPECT_EQ(2, Factorial(2));
  EXPECT_EQ(6, Factorial(3));
  EXPECT_EQ(40320, Factorial(8));
}


<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests IsPrime()</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests negative input.</span>
<span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">IsPrimeTest</span>, <span style="color: #98fb98;">Negative</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This test belongs to the IsPrimeTest test case.</span>

  EXPECT_FALSE(IsPrime(-1));
  EXPECT_FALSE(IsPrime(-2));
  EXPECT_FALSE(IsPrime(INT_MIN));
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests some trivial cases.</span>
<span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">IsPrimeTest</span>, <span style="color: #98fb98;">Trivial</span>) {
  EXPECT_FALSE(IsPrime(0));
  EXPECT_FALSE(IsPrime(1));
  EXPECT_TRUE(IsPrime(2));
  EXPECT_TRUE(IsPrime(3));
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Tests positive input.</span>
<span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">IsPrimeTest</span>, <span style="color: #98fb98;">Positive</span>) {
  EXPECT_FALSE(IsPrime(4));
  EXPECT_TRUE(IsPrime(5));
  EXPECT_FALSE(IsPrime(6));
  EXPECT_TRUE(IsPrime(23));
}
</pre>
</div>

<p>
编译并运行单元测试程序[下面说如何把 GTest 框架融合进自己的工程里]
</p>

<div class="org-src-container">

<pre class="src src-sh">Running main() from gtest_main.cc
[==========] Running 6 tests from 2 test cases.
[----------] Global test environment set-up.
[----------] 3 tests from FactorialTest
[ RUN      ] FactorialTest.Negative
[       OK ] FactorialTest.Negative (0 ms)
[ RUN      ] FactorialTest.Zero
[       OK ] FactorialTest.Zero (0 ms)
[ RUN      ] FactorialTest.Positive
[       OK ] FactorialTest.Positive (0 ms)
[----------] 3 tests from FactorialTest (0 ms total)

[----------] 3 tests from IsPrimeTest
[ RUN      ] IsPrimeTest.Negative
[       OK ] IsPrimeTest.Negative (0 ms)
[ RUN      ] IsPrimeTest.Trivial
[       OK ] IsPrimeTest.Trivial (0 ms)
[ RUN      ] IsPrimeTest.Positive
[       OK ] IsPrimeTest.Positive (0 ms)
[----------] 3 tests from IsPrimeTest (0 ms total)

[----------] Global test environment tear-down
[==========] 6 tests from 2 test cases ran. (0 ms total)
[  PASSED  ] 6 tests.
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> 如何把 GTest 融合进你的 CMake 工程里</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
<a href="https://code.google.com/p/googletest/wiki/V1_7_FAQ#Why_is_it_not_recommended_to_install_a_pre-compiled_copy_of_Goog">GTest 文档并不建议使用提前编译好复制的 GTest</a>, 因为如果你编译 Google Test
和你的测试代码使用不同的编译标志，他们可能会看到不同定义但是相同的类或
函数或变量（比如：因为使用 <code>#if</code> 在 Google Test 中）。当程序链接起来，连
接器可能并不能捕捉到错误（因为在 C++标准中并没有要求捕捉这样的违规),那
么当它们链接起来后，程序在运行时会产生一些不可预期的行为，使得非常难调
试。
</p>

<p>
所以这里我们把 Google Test 的源代码直接融合进我们的 CMake 工程里，让它一起
编译，并把测试用例添加入 <code>make test</code> , 具体见<a href="https://github.com/shishougang/cpp_test_examples">github</a>。
</p>

<ol class="org-ol">
<li>把 gtest 的工程放在我们工程的 thirdparty 文件里。
</li>
<li>定义 gtest 的 library 和包含其目录编译它
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">SET</span> (MAINFOLDER ${<span style="color: #eedd82;">PROJECT_SOURCE_DIR</span>})
<span style="color: #87cefa;">add_subdirectory</span>(${<span style="color: #eedd82;">MAINFOLDER</span>}/thirdparty/gtest)
<span style="color: #b0c4de;">set</span>(GTEST_ROOT ${<span style="color: #eedd82;">MAINFOLDER</span>}/thirdparty/gtest)
<span style="color: #b0c4de;">set</span>(GTEST_INCLUDE_DIR ${<span style="color: #eedd82;">GTEST_ROOT</span>}/include)
<span style="color: #b0c4de;">set</span>(GTEST_LIBRARIES gtest gtest_main)
<span style="color: #87cefa;">include_directories</span>(${<span style="color: #eedd82;">GTEST_INCLUDE_DIR</span>})
<span style="color: #87cefa;">include</span>(gtest)
</pre>
</div>

<ol class="org-ol">
<li>编译单元测试时链接 gtest 的 lib
</li>
</ol>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Define an executable and adds a test for it using the most basic libraries</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Args:</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">name  - name of test. Must have a source file in test/&lt;name&gt;.cc</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">...   - optional list of additional library dependencies</span>
<span style="color: #00ffff;">function</span>(project_test name)
  add_executable(${<span style="color: #eedd82;">name</span>} test/${<span style="color: #eedd82;">name</span>}.cc)
  <span style="color: #00ffff;">foreach</span> (lib <span style="color: #ffa07a;">"${ARGN}"</span>)
    target_link_libraries(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">lib</span>})
  endforeach()
  target_linK_libraries(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">GTEST_LIBRARIES</span>})
  add_test(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">EXECUTABLE_OUTPUT_PATH</span>}/${<span style="color: #eedd82;">name</span>})
<span style="color: #87cefa;">endfunction</span>()

<span style="color: #00ffff;">if</span> (build_tests)
  project_test(sample1_unittest sample1)
<span style="color: #87cefa;">endif</span>()
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> GMock 实践</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
现在针对Ｃ＋＋的模拟框架有：<a href="https://code.google.com/p/googlemock/"> Google C++ mocking framework</a>, <a href="http://www.assembla.com/wiki/show/hippomocks">HippoMocks</a>,
<a href="https://code.google.com/p/amop/">AMOP</a>, <a href="http://sourceforge.net/apps/mediawiki/turtle/index.php?title=Turtle">Turtle</a> 等。其中 Google mocking framework 比较完善并持续维护，我们
将使用它。
</p>

<p>
Google mocking framework 有完善的文档，在其
<a href="https://code.google.com/p/googlemock/w/list">wiki 页面</a>。现在的 Mocking 版本里已经包括 Google C++ Testing Framework，不
需要分别编译和安装。
</p>

<p>
使用 Google Mocking Framework 基本流程：
</p>
<ol class="org-ol">
<li>对所给类创建它的一个模拟对象。使用提供的很多宏来定义需要模拟的函数，
也提供了一个工具 <code>gmock_gen.py</code> 在 Google Mock 的目录
<code>scripts/generator/</code> 下， 用它自动生成模拟类的定义。
</li>
<li>对你的模拟类，创建相应的测试用例。一般流程是：
<ul class="org-ul">
<li>创建模拟类，使用提供的宏或函数，针对不同的场景，设置模拟类接口相
应的行为，比如调用多少次，返回什么值等等
</li>
<li>有了这个模拟类，测试需要用到它的接口或功能。创建相应的测试用例
</li>
</ul>
</li>
</ol>
</div>
<div id="outline-container-sec-2-1-3-1" class="outline-5">
<h5 id="sec-2-1-3-1"><span class="section-number-5">2.1.3.1</span> 需要模拟的源文件</h5>
<div class="outline-text-5" id="text-2-1-3-1">
<p>
现在有一个简单的 Offset 类，其中有一个虚函数接口 <code>virtual int
DoSetOffset(int offset) = 0;</code> ，暂时没有创建继承类来实现这个接口，先用
Gmock 模拟这个接口（必须是虚函数才能被覆盖模拟它）行为来做到单元测试这
个类。
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">sample.h</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MyOffset</span>{
 <span style="color: #7fffd4;">public</span>:
  <span style="color: #eedd82;">MyOffset</span>() {}
  virtual ~MyOffset() {}

  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Set the offsest</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">SetOffset</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>);

  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Returns the current offset</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>() <span style="color: #00ffff;">const</span> { <span style="color: #00ffff;">return</span> offset_; }

 protected:
  <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">   * Set the offset</span>
<span style="color: #ff7f24;">   *</span>
<span style="color: #ff7f24;">   * This method is called by the public SetOffset() method.</span>
<span style="color: #ff7f24;">   </span><span style="color: #ff7f24;">*/</span>
  virtual <span style="color: #98fb98;">int</span> DoSetOffset(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>) = 0;

 <span style="color: #7fffd4;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset_</span>; 
};
</pre>
</div>

<p>
函数 <code>int SetOffset(int offset);</code> 是外部接口，内部调用虚函数 <code>int
DoSetOffset(int offset)</code>
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">sample.c</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">MyOffset</span>::SetOffset(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>) {
  <span style="color: #00ffff;">if</span> (offset &lt; 0) {
    offset_ = -1;
    <span style="color: #00ffff;">return</span> -1;
  }
  offset_ = DoSetOffset(offset);
  <span style="color: #00ffff;">return</span> offset_;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3-2" class="outline-5">
<h5 id="sec-2-1-3-2"><span class="section-number-5">2.1.3.2</span> 利用 GMock 创建模拟类</h5>
<div class="outline-text-5" id="text-2-1-3-2">
<p>
在单元测试文件（ <code>sample_test.cc</code> ）里包含 GMock 和 GTest 的头文件
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;gmock/gmock.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;gtest/gtest.h&gt;</span>
</pre>
</div>

<p>
创建模拟类：
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MockMyOffset</span> : public MyOffset {
 <span style="color: #7fffd4;">public</span>:
  <span style="color: #eedd82;">MockMyOffset</span>() {}
  virtual ~MockMyOffset() {}

  MOCK_METHOD1(DoSetOffset, <span style="color: #98fb98;">int</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">offset</span>));
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3-3" class="outline-5">
<h5 id="sec-2-1-3-3"><span class="section-number-5">2.1.3.3</span> 配置模拟类的行为并创建测试用例</h5>
<div class="outline-text-5" id="text-2-1-3-3">
<p>
有了模拟类，配置模拟类中的函数的行为，并利用 GTest 做结果验证：
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #87cefa;">TEST</span>(<span style="color: #98fb98;">MyOffsetTest</span>, <span style="color: #98fb98;">SetOffset</span>) {
  <span style="color: #98fb98;">MockMyOffset</span> <span style="color: #eedd82;">my_offset</span>;
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#24403;DoSetOffset&#30340;&#36827;&#20837;&#21442;&#25968;&#26159;10,&#23601;&#36820;&#22238;&#19968;&#27425;10 </span><span style="color: #ff7f24;">*/</span>
  EXPECT_CALL(my_offset, DoSetOffset(10)).WillOnce(Return(10));
  EXPECT_EQ(10, my_offset.SetOffset(10));
  EXPECT_EQ(10, my_offset.offset());

  EXPECT_CALL(my_offset, DoSetOffset(5)).WillOnce(Return(5));
  EXPECT_EQ(5, my_offset.SetOffset(5));
  EXPECT_EQ(5, my_offset.offset());

  EXPECT_CALL(my_offset, DoSetOffset(20)).WillOnce(Return(1));
  EXPECT_EQ(1, my_offset.SetOffset(20));
  EXPECT_EQ(1, my_offset.offset());

  EXPECT_CALL(my_offset, DoSetOffset(10)).WillOnce(Return(-1));
  EXPECT_EQ(-1, my_offset.SetOffset(10));
  EXPECT_EQ(-1, my_offset.offset());
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3-4" class="outline-5">
<h5 id="sec-2-1-3-4"><span class="section-number-5">2.1.3.4</span> 编译并运行单元测试</h5>
<div class="outline-text-5" id="text-2-1-3-4">
<div class="org-src-container">

<pre class="src src-sh">&#10140;  bin  ./sample_test 
Running main() from gtest_main.cc
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from MyOffsetTest
[ RUN      ] MyOffsetTest.SetOffset
[       OK ] MyOffsetTest.SetOffset (0 ms)
[----------] 1 test from MyOffsetTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (0 ms total)
[  PASSED  ] 1 test.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> 如何把 GMock 融合进你的 CMake 工程里</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
和 GTest 一样，同样我们把包含 GTest 的 GMock 融合进我们的 CMake 工程里，和我们
工程一同编译。<a href="https://github.com/shishougang/cpp_test_examples">源文件</a>。
</p>


<ol class="org-ol">
<li>把 gmock 的工程放在我们工程的 thirdparty 文件里。
</li>
<li>定义 gtest 和 gmock 的 library 和包含其目录编译它
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #b0c4de;">set</span>(GMOCK_ROOT ${<span style="color: #eedd82;">MAINFOLDER</span>}/thirdparty/gmock)
<span style="color: #87cefa;">add_subdirectory</span>(${<span style="color: #eedd82;">GMOCK_ROOT</span>})
<span style="color: #b0c4de;">set</span>(GMOCK_INCLUDE_DIR ${<span style="color: #eedd82;">GMOCK_ROOT</span>}/include)
<span style="color: #b0c4de;">set</span>(GMOCK_LIBRARIES gmock)
<span style="color: #87cefa;">include_directories</span>(${<span style="color: #eedd82;">GMOCK_INCLUDE_DIR</span>})
 include(gmock)
  <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">gtest</span>
<span style="color: #b0c4de;">set</span>(GTEST_ROOT ${<span style="color: #eedd82;">GMOCK_ROOT</span>}/gtest)
<span style="color: #b0c4de;">set</span>(GTEST_INCLUDE_DIR ${<span style="color: #eedd82;">GTEST_ROOT</span>}/include)
<span style="color: #b0c4de;">set</span>(GTEST_LIBRARIES gtest gtest_main)
<span style="color: #87cefa;">include_directories</span>(${<span style="color: #eedd82;">GTEST_INCLUDE_DIR</span>})
</pre>
</div>

<ol class="org-ol">
<li>编译单元测试时链接 gtest 和 gmock 的 lib
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Define an executable and adds a test for it using the most basic libraries</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Args:</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">name  - name of test. Must have a source file in test/&lt;name&gt;.cc</span>
<span style="color: #ff7f24;">#    </span><span style="color: #ff7f24;">...   - optional list of additional library dependencies</span>
<span style="color: #00ffff;">function</span>(project_test name)
  add_executable(${<span style="color: #eedd82;">name</span>} test/${<span style="color: #eedd82;">name</span>}.cc)
  <span style="color: #00ffff;">foreach</span> (lib <span style="color: #ffa07a;">"${ARGN}"</span>)
    target_link_libraries(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">lib</span>})
  endforeach()
  target_linK_libraries(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">GTEST_LIBRARIES</span>})
  target_linK_libraries(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">GMOCK_LIBRARIES</span>})
  add_test(${<span style="color: #eedd82;">name</span>} ${<span style="color: #eedd82;">EXECUTABLE_OUTPUT_PATH</span>}/${<span style="color: #eedd82;">name</span>})
<span style="color: #87cefa;">endfunction</span>()

<span style="color: #00ffff;">if</span> (build_tests)
  project_test(sample_test sample)
<span style="color: #87cefa;">endif</span>()
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 其他资料</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Books:</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Kent Beck. Test-driven development: By example;
</li>
<li>David Astels. Test Driven Development: A Practical Guide;
</li>
<li>Robert C. Martin. Clean Code: A Handbook of Agile Software Craftsmanship (this book is mostly for Java developers);
</li>
<li>Michael Feathers. Working Effectively with Legacy Code;
</li>
<li>Martin Fowler, Kent Beck, John Brant, William Opdyke, Don Roberts. Refactoring: Improving the Design of Existing Code;
</li>
<li>Steve McConnell, Code Complete, 2ed 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Online resources:</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/tagged/unit-testing">Unit testing topic at StackOverflow</a>;
</li>
<li><a href="http://googletesting.blogspot.com/">Google Testing Blog</a>;
</li>
<li>Wiki at <a href="http://c2.com/cgi/wiki?UnitTest">c2.com</a>;
</li>
<li><a href="http://www.lenholgate.com/blog/2004/05/practical-testing.html">Practical Testing</a> — series of blog posts on testing.
</li>
<li><a href="http://alexott.net/en/cpp/CppTestingIntro.html">Boost.Test and GMock Tutorial</a>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://en.wikipedia.org/wiki/Test-Driven_Development_by_Example">http://en.wikipedia.org/wiki/Test-Driven_Development_by_Example</a>
</p></div>


</div>
</div>
]]></content>
  </entry>
  
</feed>
