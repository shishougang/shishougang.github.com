<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design Pattern | (learn&think)]]></title>
  <link href="http://shishougang.github.com/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-05-03T14:39:23+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二: 观察者模式(Observer)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/"/>
    <updated>2014-05-03T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/03/浅谈设计模式2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
有一个气候观测应用，包括三部分：
</p>
<ol class="org-ol">
<li>气候站(WeatherStation):物理设备用来采集实际天气数据;
</li>
<li>气候数据对象(WeatherData)追踪来自气候站的数据和更新显示;
</li>
<li>给用户现在气候情况的显示(xxDisplay)
</li>
</ol>

<p>
现在气候收集这3个数据：温度，湿度和气压。有3种不同的显示：现在的天气情况，天气统计信息和天气预测信息。
</p>

<p>
直观的话是在 <code>WeatherData</code> 类里的 <code>measurementsChanged()</code> 里直接调用不同显示器的 <code>update()</code> 来更新数据，如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">WeatherData</span>::<span style="color: #87cefa;">measurementsChanged</span>() {
currentConditionsDisplay.update(temp_, humidity_, pressure_);
statisticsDisplay.update(temp_, humidity_, pressure_);
forecastDisplay.update(temp_, humdity_, pressure_);
</pre>
</div>

<p class="info">
1. WeatherData和Display比较紧的耦合。在函数内直接使用实例，每次增加或较少Display都要在这个函数内修改。<br />
2. 以具体实例来编码，使得不能动态的添加和减少显示元素，唯有修改这段代码
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 观察者模式(Observer)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在对象间，定义一对多的依赖关系，那么当这一个对象改变状态时，所有它的依赖对象得到自动通知和更新。
</p>
<img src="/images/blog/2014/observer/subject_observer.jpeg">
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这里一对多的依赖关系，我们把这单一的对象称为目标对象(Subject)，而所有依赖于它的称为观察者对象(Observer)。分别定义Subject和Observer的对象。
<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/observer">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 目标对象(Subject)接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<ol class="org-ol">
<li>先建立好目标对象;
</li>
<li>然后观察者对象可以动态调用 <code>registerObserver</code> 来加入目标对象的更新列表内，调用 <code>registerObserver</code> 来从目标对象更新列表中移出;
</li>
<li>目标对象通过 <code>notifyObservers</code> 通知和更新观察者列表
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Subject</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">registerObserver</span>(<span style="color: #98fb98;">Observer</span> *<span style="color: #eedd82;">o</span>) = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">removeObserver</span>(<span style="color: #98fb98;">Observer</span> *<span style="color: #eedd82;">o</span>) = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notifyObservers</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 观察者对象(Observer)接口</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
观察者对象(Observer)接口只需要一个更新功能，使得目标对象通过
<code>notifyObservers</code> 分别调用观察者的 <code>update</code> 函数来更新参数。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Observer</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">update</span>(<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">temp</span>, <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">humdity</span>, <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">pressure</span>) = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 整合起来</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">WeatherData</span> *<span style="color: #eedd82;">weather_data</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">WeatherData</span>();
<span style="color: #98fb98;">CurrentConditionsDisplay</span> *<span style="color: #eedd82;">current_display</span> =
    <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">CurrentConditionsDisplay</span>(weather_data);
<span style="color: #98fb98;">StatisticsDisplay</span> *<span style="color: #eedd82;">statistics_display</span> =
    <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">StatisticsDisplay</span>(weather_data);
<span style="color: #98fb98;">ForecastDisplay</span> *<span style="color: #eedd82;">forecast_display</span> =
    <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ForecastDisplay</span>(weather_data);

weather_data-&gt;setMeasurements(80, 65, 30.4f);
weather_data-&gt;setMeasurements(82, 70, 29.2f);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 总的框架</h4>
<div class="outline-text-4" id="text-2-2-4">
<img src="/images/blog/2014/observer/whole_structure.jpeg">
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 观察者模式(Observer)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="/images/blog/2014/observer/observer_structure.jpg">
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>目标（Subject）
<ol class="org-ol">
<li>知道它的观察者。任意多的观察者对象可以观察一个目标对象。
</li>
<li>提供一个附加和分离观察者对象的接口。
</li>
</ol>
</li>
<li>观察者（Observer）
<ol class="org-ol">
<li>为在目标中得到改变通知的对象定义一个更新接口。
</li>
</ol>
</li>
<li>具体目标（ConcreteSubject）
<ol class="org-ol">
<li>存储具体观察对象感兴趣的状态。
</li>
<li>当状态改变时，发送更新给它的观察对象。
</li>
</ol>
</li>
<li>具体观察者（ConcreteObserver)
<ol class="org-ol">
<li>维持一个具体目标对象的引用。
</li>
<li>存储要和目标保持一致的状态。
</li>
<li>实现观察者更新接口来使得它的状态与目标保持一致。
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>当一个抽象类有2个方面，一个依赖另外一个。把这些不同的方面封装成独立的对象来让你独立的改变和复用他们。
</li>
<li>当改变一个对象需要改变其他的对象们，而且你不知道有多少对象需要改变
</li>
<li>当一个对象需要能通知其他对象们，但不需要对这些对象们做任何假定。也就是说，你不想这些对象紧耦合。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>不可预期的更新。因为观察对象们不知道各自的存在，他们会忽略改变目标的最终代价。一个在目标（subject）看似无害的操作可能造成观察者和依赖它们的观察者的级联式更新。而且，没有很好定义或维护的依赖准则经常导致虚假的更新，这些都很难去追踪。

<p>
简单的更新协议没有提供任何细节关于 <b>什么</b> 会在目标内改变的事实加重了这个问题。没有附加的协议来帮助观察者发现什么改变了，它们可能必须努力的去推测这些改变。
</p>
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式一: 策略模式(Strategy)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
    <updated>2014-05-03T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/03/浅谈设计模式1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
有一个模拟鸭子的应用完成。这个应用可以仿真鸭子的各种活动，比如游泳，鸣叫，飞等等。能马上想到的模式设计如下：
</p>

<img src="/images/blog/2014/strategy/duck1.jpeg">

<p>
一个基类 <code>Duck</code> 定义Duck的一些特性，子类继承它的特性，并覆盖它的部分特性。至此没什么问题。子类共同拥有父类的特性，消除了代码的重复性。
</p>

<p>
然后想让 <code>Duck</code> 具有有 <code>fly()</code> 的特性，把它加到父类中，相应的不同
duck(子类）如果不具备 或 <code>fly()</code> 或 <code>quack</code> 的特性,那么就去覆盖父类相应的特性。
</p>

<img src="/images/blog/2014/strategy/duck2.jpeg">
<img src="/images/blog/2014/strategy/duck3.jpeg">
<img src="/images/blog/2014/strategy/duck4.jpeg">

<p class="info">
每增加一个不同的子类 duck，如果没有父类相应的特性都要去覆盖它，很冗余。
</p>

<p>
那么如果把不变的特性继续放在基类 <code>Duck</code> 里，而把变化的特性拿出来做成独立的接口呢？
</p>
<img src="/images/blog/2014/strategy/duck5.jpeg">

<p class="info">
1. 增加代码的冗余性，每个子类duck都要去实现部分相同的特性;2. 想更改一个相同的 fly() 特性，要在相应的所有子类都修改
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 策略模式(Strategy)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
定义一组算法，分别封装每一个，并使它们能互换。策略模式(Strategy)使得对象独立的变化使用这组算法。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
如何使得不同子类的duck，<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/strategy">参考代码</a>。
</p>
<ol class="org-ol">
<li>具有自己的行为特性;
</li>
<li>能复用代码，不同的duck能共享相同行为特性代码，不造成代码的冗余;
</li>
<li>易于后期特性的更改，不会造成修改一个行为特性，要修改很多处，并易于扩张的新的行为特性
</li>
</ol>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 分离出那些变化的行为</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
这里 <code>fly()</code> 和 <code>quack()</code> 行为在不同duck类中变化。 把它们做成一个话的接口(面向接口编程而不是实现)。C++中定义一个虚类，其他不同的行为类继承这个类并实现这个虚类中的虚函数接口（Java是实现这个接口）。基本如下：
</p>

<img src="/images/blog/2014/strategy/duck_behavior.jpeg">

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FlyBehavior</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">FlyBehavior</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">fly</span>() = 0;
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FlyNoWay</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">FlyBehavior</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">FlyNoWay</span>() {}
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">FlyNoWay</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">fly</span>();
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FlyWithWings</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">FlyBehavior</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">FlyWithWings</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">fly</span>();
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 整合到Duck类里</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
关键处在：现在Duck委托（delegate）它的 <code>flying</code> 和 <code>quacking</code> 行为，而不是直接使用类或子类里它们的方法。
</p>

<img src="/images/blog/2014/strategy/duck_class.jpeg">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duck</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Duck</span>(<span style="color: #98fb98;">void</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Duck</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">display</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swim</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_fly_behavior</span>(<span style="color: #98fb98;">FlyBehavior</span> *<span style="color: #eedd82;">fly_behavior</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_quack_behavior</span>(<span style="color: #98fb98;">QuackBehavior</span> *<span style="color: #eedd82;">quack_behavior</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">performFly</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">performQuack</span>();
 <span style="color: #00ffff;">protected</span>:
  <span style="color: #98fb98;">FlyBehavior</span> *<span style="color: #eedd82;">fly_behavior_</span>;
  <span style="color: #98fb98;">QuackBehavior</span> *<span style="color: #eedd82;">quack_behavior_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 子类Duck各自拥有自己的行为，并用 <code>set_xx_behavior</code> 动态改变行为</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">DecoyDuck</span>::<span style="color: #87cefa;">DecoyDuck</span>() {
  fly_behavior_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FlyNoWay</span>;
  quack_behavior_ = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">MuteQuack</span>;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c++">model-&gt;performFly();
model-&gt;set_fly_behavior(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FlyRocketPowered</span>);
model-&gt;performFly();
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 总的框架</h4>
<div class="outline-text-4" id="text-2-2-4">
<img src="/images/blog/2014/strategy/duck_summarize.jpeg">
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 策略模式(Strategy)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="/images/blog/2014/strategy/strategy_structure.jpg">
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>策略类（Strategy)
声明一个所有算法都支持的公共接口。场景(Context)利用这个接口来调用具体策略类（ConcreteStrategy）实现的算法。
</li>
<li>具体策略类（ConcreteStrategy)
用策略类接口实现自己的酸饭。
</li>
<li>场景（Context）
<ol class="org-ol">
<li>被具体策略对象配置。
</li>
<li>维持一个策略对象的引用。
</li>
<li>可能定义一个让策略对象获取它的数据的接口。
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用策略模式当
</p>
<ol class="org-ol">
<li>很多相关的类只是不同于它们的行为。策略提供了一种能使用多种行为中一种来配置类的方法。
</li>
<li>当你需要一种算法的不同变体。比如，你可能定义一组算法来发表达不同时间/空间的权衡。当这些变体实现为一个算法的类层次时，能使用策略模式。
</li>
<li>算法使用用户不应但知道的数据。使用策略模式来避免暴露复杂，于算法相关的数据结构。
</li>
<li>一个类定义了很多行为，而这些行为有许多条件分支语句在它们的行为中。与其很多条件分支，把相关的条件分支移出到它们各自的策略类中。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ol class="org-ol">
<li>用户必须意识不同的策略。这个模式的潜在缺点是，用户在使用不同策略前，必须知道如何的不同。实现问题可能暴露给用户。所以你使用策略模式仅当行为的变体于用户相关。
</li>
<li>Strategy和Context之间的通信开销。Strategy的接口被所有具体策略类所共有，无论这些类实现的算法简单还是复杂。所以会这样，一些具体策略类不会使用所有通过这个接口传递给他们的信息，简单的具体策略类可能根本用不到任何信息。这意味着，有时候当Context创建和初始化的参数将永远得不到使用。如果这是个问题，你将需要在Strategy和Context之间进行更紧密的耦合。
</li>
<li>增加策略类。各种策略类增加了应用的对象数量。有时，你可以将策略类实现为让Context共享的无状态对象来减少这开销。任何潜在的状态由Context
维持，当调用Strategy时，把它传递过去。共享的策略类不应该在每次调用间维持状态。
</li>
</ol>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <updated>2014-05-03T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/03/浅谈设计模式</id>
    <content type="html"><![CDATA[<p>
读完GOF的<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?ie=UTF8&amp;qid=1394635442&amp;sr=8-1&amp;keywords=Design+Patterns">Design Patterns: Elements of Reusable Object-Oriented
Software</a>和图文并茂的<a href="http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124/ref=sr_1_2?ie=UTF8&amp;qid=1394635442&amp;sr=8-2&amp;keywords=Design+Patterns">Head First Design Patterns</a>，一时并不是那么快消化和理解，所以试着用自己的语言总结一下。
</p>

<p>
《Design Patterns》在Introduction章中"如何选一种模式设计"一节中给出了一张表格，5个创建模式（Abstract Factory; Builder; Factory Method;
Prototype; Singleton)，7个结构模式(Adapter; Bridge; Compose;
Decorator; Facade; Flyweight; Proxy)和11个行为模式（Chain of
Responsibility; Command; Interpreter; Iterator; Mediator; Memento;
Observer; State; Strategy; Template Method; Visitor)。
</p>

<!-- more -->

<p>
设计模式提倡：
</p>
<ol class="org-ol">
<li>面向接口编程而不是实现；
</li>
<li>使用组合优于继承;
</li>
<li>程序模块低耦合,高内聚
</li>
<li>独立出变化部分，适应后期变化
</li>
</ol>

<p>
设计模式并不是只局限OO中，主要理解设计模式的思想，但它也引入了一定的复杂度，不要烂用设计模式，宗旨是写简单而清晰的代码。
</p>

<p>
The best way to learn to write simple code is to write simple code!
Patterns, like all forms of compexity, should be avoided until they
are absolutely necessary. That's the first thing beginners need to
learn. Not the last thing.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
所有例子的代码在<a href="https://github.com/shishougang/DesignPattern-CPP">这里</a>。
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://blog.codinghorror.com/head-first-design-patterns/">http://blog.codinghorror.com/head-first-design-patterns/</a>
</p></div>


</div>
</div>
]]></content>
  </entry>
  
</feed>
