<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | (learn&think)]]></title>
  <link href="http://shishougang.github.com/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-05-29T21:48:41+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 2]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/29/The-Algorithm-Design-Manual2/"/>
    <updated>2014-05-29T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/29/The-Algorithm-Design-Manual2</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
<p>
Our two most important tools are (1) the RAM model of
computation and (2) the asymptotic analysis of worst-case complexity.
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
What value is returned by the following function? Express your answer
as a function of n. Give the worst-case running time using the Big Oh
notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">mystery</span>(n)
      <span style="color: #b0c4de;">r</span>:=0
      <span style="color: #00ffff;">for</span> i:=1 to n-1 do
          <span style="color: #00ffff;">for</span> j:=i+1 to n do
              <span style="color: #00ffff;">for</span> k:=1 to j do
                  <span style="color: #b0c4de;">r</span>:=r+1
       <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>

$$
\begin{align}
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\sum_{k=1}^{j}1 = 
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}j =
\sum_{i=1}^{n-1}(\sum_{j=1}^{n}j - \sum_{j=1}^{i}j) = \newline 
\sum_{i=1}^{n-1}(\frac{n(n+1)}{2} - \frac{i(i+1)}{2} = 
\frac{1}{2}\sum_{i=1}^{n-1}(n^2+n-i^2-i) = \newline 
\frac{1}{2}((n-1)n^2+(n-1)n-(\frac{n(n+1)(2n+1)}{6}-n^2)-(\frac{n(n+1)}{2}-n))
\end{align}
$$

<p>
Time: O(n<sup>3</sup>)
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">pesky</span>(n)
      <span style="color: #b0c4de;">r</span>:=0
      <span style="color: #00ffff;">for</span> i:=1 to n do
          <span style="color: #00ffff;">for</span> j:=1 to i do
              <span style="color: #00ffff;">for</span> k:=j to i+j do
                  <span style="color: #b0c4de;">r</span>:=r+1
      <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>

\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}


<p>
Time: O(n<sup>3</sup>).
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00ffff;">function</span> <span style="color: #87cefa;">prestiferous</span>(n)
       <span style="color: #b0c4de;">r</span>:=0
       <span style="color: #00ffff;">for</span> i:=1 to n do
           <span style="color: #00ffff;">for</span> j:=1 to i do
               <span style="color: #00ffff;">for</span> k:=j to i+j do
                   <span style="color: #00ffff;">for</span> l:=1 to i+j-k do
                       <span style="color: #b0c4de;">r</span>:=r+1
       <span style="color: #00ffff;">return</span>(<span style="color: #b0c4de;">r</span>)
</pre>
</div>


\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}


<p>
Time: O(n<sup>4</sup>).
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">19</h3>
<div class="outline-text-3" id="text-2-4">
\begin{align}
(1/3)^n &lt; 6 &lt; loglogn &lt; logn = lnn &lt; (logn)^2 &lt; n^\frac{1}{3}+logn &lt; \sqrt{n}
 \newline 
 &lt; \frac{n}{logn} &lt; n &lt; nlogn &lt; n^2 = n^2+logn &lt; n^3 &lt; n-n^3+7n^5 &lt; (3/2)^2 
 \newline 
= 2^n &lt; n!
\end{align}
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">34</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Assume that Christmas hasndays. Exactly how many presents did my “true
love” send me? (Do some research if you do not understand this
question.)
</p>

<p>
假设一共有ｎ天，每i天收到的礼物数是： 
</p>

\begin{align}
p_i = \sum_{k=1}^{i}k
\end{align}


<p>
总的礼物数：
</p>

\begin{align}
\sum_{i=1}^{n} p_i = \sum_{i=1}^{n}\sum_{k=1}^{i}k=\frac{n^3+3n^2+2n}{6}
\end{align}
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">43</h3>
<div class="outline-text-3" id="text-2-6">
<p>
You are given a set S of n numbers. You must pick a subset S' of k
numbers from S such that the probability of each element of S
occurring in S' is equal (i.e., each is selected with probability k /
n). You may make only one pass over the numbers. What if n is unknown?
</p>

<p>
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Reservoir%20Sampling.html">Reservoir sampling issue</a>.
</p>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">44</h3>
<div class="outline-text-3" id="text-2-7">
<p>
We have 1,000 data items to store on 1,000 nodes. Each node can store
copies of exactly three different items. Propose a replication scheme
to minimize data loss as nodes fail. What is the expected number of
data entries that get lost when three random nodes fail?
</p>

<p>
不考虑RAID的XOR做法这里。
</p>

<p>
1000个数据做3份拷贝，如何做3份拷贝呢？
</p>

<ol class="org-ol">
<li>随机的3个点失败只损失一个数据
</li>
</ol>
<p>
3份拷贝以相邻一格的方式存储，如下
</p>
<div class="org-src-container">

<pre class="src src-sh">nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data1000 data1    data2 ..  data999
copy3:   data999  data1000 data1 ..  data998
</pre>
</div>

随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000, 每种组合丢失一个数据
所以丢失数据期望 $1000 / \binom{1000}{3} = 6.01804e-06$ 

<ol class="org-ol">
<li>随机的3个点失败损失3个数据
</li>
</ol>
<p>
每3个点共享3个拷贝点，如下
</p>
<div class="org-src-container">

<pre class="src src-sh">nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data3    data1    data2 ..  data999
copy3:   data2    data3    data1 ..  data998
</pre>
</div>

随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000/3, 每种组合丢失3个数据，
所以丢失数据期望 $1000/3×3 / \binom{1000}{3} = 6.01804e-06$ 
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">45</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Consider the following algorithm to find the minimum element in an
array of numbers . One extra variable tmp is allocated to hold the
current minimum value. Start from <code>A[0]</code>; "tmp" is compared against
<code>A[1], A[2], , A[N]</code> in order. When <code>A[i] &lt; tmp, tmp = A[i]</code>. What is the
expected number of times that the assignment operation tmp = A[i] is
performed?
</p>

<p>
期望的次数是第ｎ个元素是最小值的概率的总和。ｎ个元素平均分布，任意元素是最小值的概率是1/ｎ。
</p>

<p>
<code>E(n) = E(n-1) +1/n， E[1] = 1</code>
</p>


\begin{align}
E(n) = \sum_{i=1}^{n}\frac{1}{i} \approx lnn
\end{align}
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">46</h3>
<div class="outline-text-3" id="text-2-9">
<p>
You have a 100-story building and a couple of marbles. You must
identify the lowest floor for which a marble will break if you drop it
from this floor. How fast can you find this floor if you are given an
infinite supply of marbles? What if you have only two marbles?
</p>

<ol class="org-ol">
<li>无限个玻璃球，采用二分搜索法，celing(log100) = 7. 最快7次。
</li>
<li>如果只有2个玻璃球
</li>
</ol>
<p>
n个球时在总楼层r中某个楼层x抛，两种情况： 1.破碎，剩下的总楼层x-1用剩下的n-1个球; 2.没破碎，剩下的总楼层r-x用n个球
</p>

<p>
如此把问题分解成小问题。如下代码求得最快的次数为14。其中一条最坏情况：
9&#x2013;&gt;22&#x2013;&gt;34&#x2013;&gt;45&#x2013;&gt;55&#x2013;&gt;64&#x2013;&gt;72&#x2013;&gt;79&#x2013;&gt;85&#x2013;&gt;90&#x2013;&gt;94&#x2013;&gt;97&#x2013;&gt;99
</p>


<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Drop Marbles</span>
<span style="color: #ff7f24;">   n: num of marbles</span>
<span style="color: #ff7f24;">   r: num of floors</span>
<span style="color: #ff7f24;">   drop_qeq: the drop sequence</span>
<span style="color: #ff7f24;">   marble_drop: minimum number of trails needed to find the critical floor in</span>
<span style="color: #ff7f24;">   worst case</span>
<span style="color: #ff7f24;">   marble_drop[n][r] = 1 + min{max(marble_drop[n-1][x-1], marble[n][r-x]) :</span>
<span style="color: #ff7f24;">   x in {1,2,...,r}}</span>
<span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">DropMarbles</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">drop_seq</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">marble_drop</span>[n+1][r+1];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (j = 0; j &lt;= r; ++j) {
    marble_drop[1][j] = j;
  }
  <span style="color: #00ffff;">for</span> (i = 0; i &lt;= n; ++i) {
    marble_drop[i][1] = 1;
    marble_drop[i][0] = 0;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_sofar</span>;
  <span style="color: #00ffff;">for</span> (i = 2; i &lt;= n; ++i) {
    <span style="color: #00ffff;">for</span> (j = 2; j &lt;= r; ++j) {
      marble_drop[i][j] = <span style="color: #7fffd4;">numeric_limits</span>&lt;<span style="color: #98fb98;">int</span>&gt;::max();
      <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 1; x &lt;= j; ++x) {
        min_sofar = 1 + max(marble_drop[i-1][x-1], marble_drop[i][j-x]);
        <span style="color: #00ffff;">if</span> (min_sofar &lt; marble_drop[i][j]) {
          marble_drop[i][j] = min_sofar;
          drop_seq[i][j] = x;
        }
      }
    }
  }
  <span style="color: #00ffff;">return</span> marble_drop[n][r];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">47</h3>
<div class="outline-text-3" id="text-2-10">
<p>
You are given 10 bags of gold coins. Nine bags contain coins that each
weigh 10 grams. One bag contains all false coins that weigh one gram
less. You must identify this bag in just one weighing. You have a
digital balance that reports the weight of what is placed on it.
</p>

<p>
一共10袋bag1-10, 分别从bag1中取1个金币，bag2中取2个金币……bag10中取10
个金币，称重总的重量W。如果每个金币都是10grams的话，所以金币总重量是550。N=550-W。得到缺失的重量，也是bag的号数，所以bagN中含有错误金币。
</p>
</div>
</div>
<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">48</h3>
<div class="outline-text-3" id="text-2-11">
<p>
You have eight balls all of the same size. Seven of them weigh the
same, and one of them weighs slightly more. How can you find the ball
that is heavier by using a balance and only two weighings?
</p>

<p>
8==&gt; 3,3,2
</p>

<ol class="org-ol">
<li>称重3和3两组
</li>
<li>若不同，选出重的一组，3==&gt; 1,1,1 称重1和1,不同，那么重的就是，相同，另外个是。
</li>
<li>若相同，2==&gt;1,1，称重1和1,重的就是
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">49</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Suppose we start with n companies that eventually merge into one big
company. How many different ways are there for them to merge?
</p>

1. 2个公司(a,b)时，合并只有一种方法[ab]
2. 当有n个公司时，如何把它用n-1个公司表示，f(n)=f(n-1)g(n)
3. n个公司第一步从中选择两个公司合并，连带合并后的新公司一共n-1个公司，
   化简到n-1个公司表示。
4. n个选2个的组合个数是： $\binom{1000}{2}=n(n-1)/2$

<p>
所以
</p>

<p>
f(n) = &sum;<sub>i=2</sub><sup>n</sup>\frac{i(i-1)}{2} = \frac{n!(n-1)!}{2<sup>n-2</sup>}
</p>
</div>
</div>

<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">50</h3>
<div class="outline-text-3" id="text-2-13">
<p>
A Ramanujam number can be written two different ways as the sum of two
cubes&#x2014;i.e., there exist distinct a, b, c, and d such that a3 + b3 =
c3 + d3. Generate all Ramanujam numbers where a,b,c,d &lt; n.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindEqual</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &amp;<span style="color: #eedd82;">num_cube</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">high</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> &amp;<span style="color: #eedd82;">sum</span>,
               <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; *<span style="color: #eedd82;">res</span>) {
  <span style="color: #00ffff;">if</span> (low &gt;= high) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  i = low;
  j = high;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">add</span>;
  <span style="color: #00ffff;">while</span> (i &lt; j) {
    add = num_cube[i] + num_cube[j];
    <span style="color: #00ffff;">if</span> (add == sum) {
      res-&gt;push_back(i);
      res-&gt;push_back(j);
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
    }
    <span style="color: #00ffff;">if</span> (add &gt; sum) {
      --j;
    } <span style="color: #00ffff;">else</span> {
      ++i;
    }
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RamanujamNum</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; &gt; *<span style="color: #eedd82;">res</span>) {
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">num_cube</span>(n);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    num_cube[i] = i*i*i;
  }
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">ram_num</span>;
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">find</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n - 1; ++i) {
    <span style="color: #00ffff;">for</span> (j = i + 3; j &lt; n; ++j) {
      find = FindEqual(num_cube, i+1, j-1, num_cube[i] + num_cube[j], &amp;ram_num);
      <span style="color: #00ffff;">if</span> (find) {
        ram_num.push_back(i);
        ram_num.push_back(j);
        res-&gt;push_back(ram_num);
        ram_num.clear();
      }
    }
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">51</h3>
<div class="outline-text-3" id="text-2-14">
<p>
Six pirates must divide $300 dollars among themselves. The division is
to proceed as follows. The senior pirate proposes a way to divide the
money. Then the pirates vote. If the senior pirate gets at least half
the votes he wins, and that division remains. If he doesn't, he is
killed and then the next senior-most pirate gets a chance to do the
division. Now you have to tell what will happen and why (i.e., how
many pirates survive and how the division is done)? All the pirates
are intelligent and the first priority is to stay alive and the next
priority is to get as much money as possible.
</p>

<p>
从后往前推
</p>
<ul class="org-ul">
<li>2个海盗，(1, 2) &#x2014;&gt; (0, 300)
</li>
<li>3个海盗，(1, 2, 3) &#x2014;&gt; (1, 0, 299)
</li>
<li>4个海盗，(1, 2, 3, 4) &#x2014;&gt; (0, 1, 0, 299)
</li>
<li>5个海盗，(1, 2, 3, 4, 5) &#x2014;&gt; (1, 0, 1, 0, 298)
</li>
<li>6个海盗，(1, 2, 3, 4, 5, 6) &#x2014;&gt; (0, 1, 0, 1, 298)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">52</h3>
<div class="outline-text-3" id="text-2-15">
<p>
Reconsider the pirate problem above, where only one indivisible dollar
is to be divided. Who gets the dollar and how many are killed?
</p>

<ul class="org-ul">
<li>2: (1, 2) &#x2014;&gt; (0, 1)
</li>
<li>3: (1, 2, 3) &#x2014;&gt; （1, 0, 0)
</li>
<li>4: (1, 2, 3, 4) &#x2014;&gt; (0, 0, 1, 0)
</li>
<li>5: dead
</li>
<li>6: (1, 2, 3, 4, 5, 6) &#x2014;&gt; (0, 0, 0, 1, 0, 0)
</li>
</ul>
<p>
要至少一半的同意，间隔要有一半的人会死去才会同意之前那个人，所以之后每
2+2<sup>K</sup> (K&gt;=1)的海盗才能活。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithm Design Manual Chapter 1]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/26/The-Algorithm-Design-Manual1/"/>
    <updated>2014-05-26T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/26/The-Algorithm-Design-Manual1</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Combinatorial Objects</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Permutations - arrangements, or orderings, of items ("arrangement"
"tour" "ordering" or "sequence" )
</li>
<li>Subsets - selections from a set of items ("cluster" "collection"
"committee" "group" "packaging" or "selection")
</li>
<li>Trees - hierarchical relationships between items ("hierarchy"
"dominance relationship" "ancestor/descendant relationship" or
"taxonomy")
</li>
<li>Graphs - relationships between arbitrary pairs of objects ("network"
"circuit" "web" or "relationship")
</li>
<li>Points - locations in some geometric space ("sites" "positions" or
"locations.)
</li>
<li>Polygons - regions in some geometric spaces ("shapes" "regions" or
"boundaries")
</li>
<li>Strings - sequences of characters or patterns. ("text" "characters"
"patterns" or "labels")
</li>
</ul>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Recursive Objects</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Big things that are made from smaller things of exactly the same type
as the big thing. A decomposition rule describes how to get smaller
things from big things.
</p>

<p>
As all combinatorial objects above are recursive objects here are a
few possible decompositon rules for them:
</p>

<ul class="org-ul">
<li>Permutations - Deleting the first/last element of a permutation
</li>
<li>Subsets - Deleting an element n if present
</li>
<li>Trees - Deleting the root (results in a set of subtrees), deleting a
leaf (a smaller tree)
</li>
<li>Graphs - Deleting a vertex, dividing vertices to groups
</li>
<li>Point - divide them to groups
</li>
<li>Polygons - Inserting any internal chord between two nonadjacent vertices
</li>
<li>Strings - Deleting a character (first or last)
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1-28.</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Write a function to perform integer division without using either
the / or * operators. Find a fast way to do it.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">DivideCore</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">quot</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">rem</span>) {
  rem = m;
  quot = 0;
  <span style="color: #00ffff;">while</span> (rem &gt;= n) {
    rem -= n;
    quot++;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Divide</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">quot</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">rem</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mult_n</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_n</span>;
  <span style="color: #00ffff;">while</span> (m % n == 0) {
    last_n = n;
    n = n + n;
    mult_n++;
  }
  DivideCore(m, n, quot, rem);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; mult_n; ++i) {
    quot = quot + quot;
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">1-29.</h3>
<div class="outline-text-3" id="text-2-2">
<p>
There are 25 horses. At most, 5 horses can race together at a time.
You must determine the fastest, second fastest, and third fastest
horses. Find the minimum number of races in which this can be done.
</p>

<p>
7次。
</p>

<ol class="org-ol">
<li>5次：25匹分成5组，比赛5次，得到前5名。
</li>
<li>6次：前5名比赛一次。因为只要得到前3名，这里剔除5名中的2名，剩下的3
匹按比赛排名所在组为G1，G2，G3。
</li>
<li>7次：G3组只能去角逐第3名，派第一名G31,G2组只能去角逐第2,3名，派第一，二名，G21和G22。G1组G11已经是第一名，去角逐第2,3名，派G12,G13。最后
G12,G13，G21，G22和G31，得到第二，三名。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">1-30.</h3>
<div class="outline-text-3" id="text-2-3">
<p>
How many piano tuners are there in the entire world?
</p>

<p>
需要把问题分解：1.世界有多少架钢琴;2.每位钢琴调音师能调多少台钢琴。
</p>

<p>
估算世界有多少架钢琴，需要知道：
</p>
<ol class="org-ol">
<li>世界的人口。
</li>
<li>拥有钢琴的人口比例。
</li>
<li>拥有钢琴的学校，教堂等场所的数量。
</li>
</ol>

<p>
估算每位钢琴调音师能调多少台钢琴，需要知道：
</p>
<ol class="org-ol">
<li>每架钢琴平均多久需要调音一次。
</li>
<li>对钢琴调音需要多长时间。
</li>
<li>调音师的工作时间。
</li>

<li>世界人口70亿，70×10<sup>9</sup> 。
</li>
<li>人口中弹奏乐器的人约占10%（肯定大于1%,小于100%），其中最多10%的人弹奏钢琴，而其中拥有钢琴的比例为2%-3%，约人口总数2×10<sup>-3</sup> 。每
5000-10000个人有一座教堂，每座教堂有一架钢琴，每500-1000个学生有一所学校，每所学校有一架钢琴，每人大约拥有3×10<sup>-3</sup> 架钢琴，所以钢琴数
70×10<sup>9</sup> × 3×10<sup>-3</sup> = 2.1 * 10<sup>8</sup> 。
</li>
<li>钢琴调音的频率低于每月一次但多于10年一次，估计为一年一次。
</li>
<li>调音所需时间多余30分钟，少于1天，估计为2小时。或钢琴有88个键，如果每个键花1分钟，需要1.5小时，若需2分钟，则需要3小时。
</li>
<li>每天工作8小时，每周5天，每年工作50周，得出8×5×50=2000小时。2000小时能调音大学1000架钢琴。
</li>
<li>2.1 * 10<sup>8</sup> / 1000 = 2.1 × 10<sup>5</sup> 个调音师。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">1-31.</h3>
<div class="outline-text-3" id="text-2-4">
<p>
How many gas stations are there in the United States?
</p>

<p>
分解问题成：
</p>
<ol class="org-ol">
<li>每天大约有多少辆汽车去加油。
</li>
<li>每天一个加油站能给多少辆汽车加油。
</li>

<li>美国人口总数约300×10<sup>6</sup> , 一家平均有2辆车左右，所以一共有车辆
150×10<sup>6</sup> ，每辆汽车每5天加油一次，一天有30×10<sup>6</sup> 辆车去加油。
</li>
<li>一个加油站平均每小时最少为1辆，最多100多辆汽车加油，取平均20-30辆每小时，一个加油站工作时间大概14小时（7am-9am），每个加油站每天平均大约为280辆车加油。
</li>
<li>30×10<sup>6</sup> / 280 = 1.07 × 10<sup>5</sup> 个加油站。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">1-32.</h3>
<div class="outline-text-3" id="text-2-5">
<p>
How much does the ice in a hockey rink weigh?
</p>

<p>
分解成：
</p>
<ol class="org-ol">
<li>冰的体积。
</li>
<li>冰的密度。
</li>
</ol>

<p>
做如下估算：
1.冰场的长度：70m;
2.冰场的宽度：30m;
3.冰的厚度：10cm=0.1;
4.冰的密度与水相当，估算1000kg/m<sup>3</sup> .
</p>

<p>
V = 70 * 30 * 0.1 = 210 m<sup>3</sup>
W = 210 *1000 = 210，000kg
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">1-33.</h3>
<div class="outline-text-3" id="text-2-6">
<p>
How many miles of road are there in the United States?
</p>

<p>
美国近似是一个矩形，高1000mile和长3000mile。美国大部分地区是乡村，道路比较稀疏，平均下来可以把美国想成一个网状的道路结构，每隔1mile一条道路，最后如下网格，1000条3000mile和3000条1000mile的路，总的6,000,000mile的路。
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">1-34.</h3>
<div class="outline-text-3" id="text-2-7">
<p>
On average, how many times would you have to flip open the Manhattan
phone book at random in order to find a specific name?
</p>


<p>
假设电话本有1000页，也就是500个翻面。
</p>

<p>
简单答案：翻到正确页的概率是1/500。
</p>

<p>
复杂点答案：上面没有考虑不断翻页，会翻到相同的页面。翻到错误页面的概率是499/500，N次后的错误概率是（499/500）<sup>N</sup> ,所以N次后的正确页面概率是P=1-
（499/500）<sup>N</sup> 。
</p>

<p>
那么：
N=1  P = 0.002
N=2  P = 0.004
&#x2026;
N=1150 P = 0.89999
</p>

<p>
达到90%的概率，所以需要1150翻页。
</p>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
