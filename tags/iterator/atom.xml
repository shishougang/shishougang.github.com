<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Iterator | (learn&think)]]></title>
  <link href="http://shishougang.github.com/tags/iterator/atom.xml" rel="self"/>
  <link href="http://shishougang.github.com/"/>
  <updated>2014-05-10T23:34:20+08:00</updated>
  <id>http://shishougang.github.com/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式十一: 迭代器模式(Iterator)]]></title>
    <link href="http://shishougang.github.com/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://shishougang.github.com/blog/2014/05/04/浅谈设计模式11</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
为了提高市场竞争力，早餐店(Pancake House)和午餐店（Diner）合并了。如下整合他们的菜单让服务员使用。
</p>

<p>
<code>PancakeHouseMenu</code> 类使用 <code>vector</code> 来维护它的菜单，它认为使用 <code>vector</code>
可以很容易的扩展自己的菜单。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PancakeHouseMenu</span> {
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">menu_items_</span>;
};
</pre>
</div>

<p>
<code>DinerMenu</code> 类使用数组来维护它的菜单，它认为使用数组能控制菜单数目和更快速的添加菜单。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DinerMenu</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kMaxItems</span> = 6 };
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">number_of_items_</span>;
  MenuItem *menu_items_[kMaxItems];
};
</pre>
</div>

<p>
那么 <code>Waitress</code> 类需要使用两个循环分别访问它们的菜单来打印整个菜单。但问题是：
</p>
<ul class="org-ul">
<li>面向菜单的具体实现来编码而不是接口。
</li>
<li>如果增加一个新的餐厅类，就需要另外一个循环，代码冗余，不易扩展。
</li>
<li><code>Waitress</code> 需要知道每个餐厅类是如何内部表示它的菜单，破坏了它们的封装。
</li>
<li>如果餐厅类改变存储菜单的方式，比如由数组变成Hashtable，那么
  <code>Waitress</code> 需要很大的改动。
</li>
</ul>

<p>
如何设计使得避免这些问题呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 迭代器模式(Iterator)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
提供一种方法来序列访问一个聚合对象的元素，而不暴露它底层的实现。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
使用迭代起模式，分别创建餐厅类的迭代器类实现迭代起的抽象统一接口，餐厅类利用这个各自的迭代器类创建它的迭代器实例让调用者使用，调用者只需要这个迭代器实例就可以访问它的所有菜单。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/iterator">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义迭代器抽象接口</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Iterator</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>() = 0;
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 实现 <code>DinerMenu</code> 的迭代器类 <code>DinerMenuIterator</code></h4>
<div class="outline-text-4" id="text-2-2-2">
<img src="/images/blog/2014/iterator/dinermenu_iterator.jpeg">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DinerMenuIterator</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kMaxItems</span> = 6 };
  <span style="color: #87cefa;">DinerMenuIterator</span>(<span style="color: #98fb98;">MenuItem</span> **<span style="color: #eedd82;">items</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">DinerMenuIterator</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">MenuItem</span> **<span style="color: #eedd82;">items_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">position_</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #7fffd4;">DinerMenuIterator</span>::<span style="color: #87cefa;">hasNext</span>() {
  <span style="color: #00ffff;">if</span> (position_ &gt;= kMaxItems || items_[position_] == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">void</span>* <span style="color: #7fffd4;">DinerMenuIterator</span>::<span style="color: #87cefa;">next</span>() {
  <span style="color: #98fb98;">MenuItem</span>* <span style="color: #eedd82;">menu_item</span> = items_[position_];
  position_++;
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #98fb98;">void</span>*&gt;(menu_item);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 实现 <code>PancakeHouseMenu</code> 的迭代器类 <code>PancakeHouseMenuIterator</code></h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PancakeHouseMenuIterator</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Iterator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">PancakeHouseMenuIterator</span>(<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">items</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">PancakeHouseMenuIterator</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">hasNext</span>();
  <span style="color: #98fb98;">void</span>* <span style="color: #87cefa;">next</span>();
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">MenuItem</span>*&gt; *<span style="color: #eedd82;">items_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">position_</span>;
};

<span style="color: #98fb98;">bool</span> <span style="color: #7fffd4;">PancakeHouseMenuIterator</span>::<span style="color: #87cefa;">hasNext</span>() {
  <span style="color: #00ffff;">if</span> (position_ &gt;= items_-&gt;size() || items_-&gt;at(position_) == <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
}

<span style="color: #98fb98;">void</span>* <span style="color: #7fffd4;">PancakeHouseMenuIterator</span>::<span style="color: #87cefa;">next</span>() {
  <span style="color: #98fb98;">MenuItem</span> *<span style="color: #eedd82;">menu_item</span> = items_-&gt;at(position_);
  position_++;
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">reinterpret_cast</span>&lt;<span style="color: #98fb98;">void</span>*&gt;(menu_item);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 定义餐厅类抽象接口</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
每个餐厅都要完成创建自己的迭代器实例。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Menu</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Menu</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">Iterator</span>* <span style="color: #87cefa;">createIterator</span>() = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> <code>DinerMenu</code> 实现创建迭代器实例</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">DinerMenu</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">DinerMenuIterator</span>(menu_items_);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> <code>PancakeHouseMenu</code> 实现创建迭代器实例</h4>
<div class="outline-text-4" id="text-2-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">Iterator</span>* <span style="color: #7fffd4;">PancakeHouseMenu</span>::<span style="color: #87cefa;">createIterator</span>() {
  <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PancakeHouseMenuIterator</span>(menu_items_);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> <code>Waitress</code> 使用迭代器打印菜单</h4>
<div class="outline-text-4" id="text-2-2-7">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Waitress</span>::<span style="color: #87cefa;">printMenu</span>() <span style="color: #00ffff;">const</span> {
  <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">pancake_iterator</span> = pancake_house_menu_-&gt;createIterator();
  <span style="color: #98fb98;">Iterator</span> *<span style="color: #eedd82;">diner_iterator</span> = diner_menu_-&gt;createIterator();

  cout &lt;&lt; <span style="color: #ffa07a;">"MENU\n----\nBREAKFAST"</span> &lt;&lt; endl;
  printMenu(pancake_iterator);
  cout &lt;&lt; <span style="color: #ffa07a;">"\nLUNCH"</span> &lt;&lt; endl;
  printMenu(diner_iterator);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-8" class="outline-4">
<h4 id="sec-2-2-8"><span class="section-number-4">2.2.8</span> 总的设计框架</h4>
<div class="outline-text-4" id="text-2-2-8">
<img src="/images/blog/2014/iterator/menu_structure.jpeg">
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 迭代器模式(Iterator)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="/images/blog/2014/iterator/iterator_structure.jpeg">
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>迭代器类（Iterator）定义一个接口来访问和遍历元素。
</li>
<li>具体迭代器类（ConcreteIterator）
<ol class="org-ol">
<li>实现迭代器接口。
</li>
<li>保存遍历聚合元素的当前位置
</li>
</ol>
</li>
<li>聚合类（Aggregate）定义一个接口来创建迭代器对象。
</li>
<li>具体聚合类（ConcreteAggregate）实现迭代器创建接口来返回相应具体迭代器的一个实例。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>访问一个聚合对象的内容，但却不想暴露它的内部实现。
</li>
<li>为聚合对象支持所有遍历方法。
</li>
<li>为遍历不同的聚合结构提供一种统一的接口（即，支持多态迭代化）。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
