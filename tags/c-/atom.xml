<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C++ | (learn&think)]]></title>
  <link href="http://dreamrunner.org/tags/c-/atom.xml" rel="self"/>
  <link href="http://dreamrunner.org/"/>
  <updated>2017-06-12T00:13:48+08:00</updated>
  <id>http://dreamrunner.org/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++11 Memory Model and Atomic]]></title>
    <link href="http://dreamrunner.org/blog/2017/06/11/C%2B%2B11-MemoryModel-Atomic/"/>
    <updated>2017-06-11T23:47:41+08:00</updated>
    <id>http://dreamrunner.org/blog/2017/06/11/C++11-MemoryModel-Atomic</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">C++11 Atomic</a></li>
<li><a href="#sec-2">Memory Model and Order</a></li>
<li><a href="#sec-3">More</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">C++11 Atomic<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-1">
<p>
C++11 Atomic可简单分为4部分:
</p>
<ol class="org-ol">
<li><code>atomic</code> 类
</li>
<li>对 <code>atomic</code> 类型的操作函数
</li>
<li><code>atomic_flag</code> 类
</li>
<li>内存序列同步相关操作
</li>
</ol>


<!-- more -->
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><code>atomic</code> 类</h3>
<div class="outline-text-3" id="text-1-1">
<p>
主要分为四种模板类:
</p>
<ol class="org-ol">
<li>基本 <code>std::atomic</code>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">T</span> &gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">atomic</span>;
</pre>
</div>
</li>
<li>整形(Integral)的特化
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">atomic</span>&lt;Integral&gt;;
</pre>
</div>
</li>
<li>bool的特化
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">bool</span>&gt;;
</pre>
</div>
</li>
<li>指针的特化
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">T</span> &gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">T</span>*&gt;;
</pre>
</div>
</li>
</ol>

<p>
bool和integral类型:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">std</span>::atomic_bool        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">bool</span>&gt;

<span style="color: #7fffd4;">std</span>::<span style="color: #eedd82;">atomic_char</span>        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">char</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_schar       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">signed</span> <span style="color: #98fb98;">char</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_uchar       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_short       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">short</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_ushort      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_int <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">int</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_long        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">long</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_ulong       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_llong       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_ullong      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_char16_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;char16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_char32_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;char32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_wchar_t     <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">wchar_t</span>&gt;
<span style="color: #7fffd4;">std</span>::atomic_int8_t      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint8_t     <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int16_t     <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint16_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int32_t     <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint32_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int64_t     <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint64_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_least8_t        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_least8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_least8_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_least8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_least16_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_least16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_least16_t      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_least16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_least32_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_least32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_least32_t      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_least32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_least64_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_least64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_least64_t      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_least64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_fast8_t <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_fast8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_fast8_t        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_fast8_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_fast16_t        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_fast16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_fast16_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_fast16_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_fast32_t        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_fast32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_fast32_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_fast32_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_int_fast64_t        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::int_fast64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uint_fast64_t       <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uint_fast64_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_intptr_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::intptr_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uintptr_t   <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uintptr_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_size_t      <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::size_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_ptrdiff_t   <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::ptrdiff_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_intmax_t    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::intmax_t&gt;
<span style="color: #7fffd4;">std</span>::atomic_uintmax_t   <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #7fffd4;">std</span>::uintmax_t&gt;
</pre>
</div>

<p>
基本模板类定义:
</p>
<div class="org-src-container">

<pre class="src src-sh">template &lt; class T &gt; struct atomic {
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) volatile;
    void store(T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst);
    T load(<span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) const volatile;
    T load(<span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) const;
    operator  T() const volatile;
    operator  T() const;
    T exchange(T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) volatile;
    T exchange(T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst);
    bool compare_exchange_weak(T &amp;, T, memory_order, memory_order) volatile;
    bool compare_exchange_weak(T &amp;, T, memory_order, memory_order);
    bool compare_exchange_strong(T &amp;, T, memory_order, memory_order) volatile;
    bool compare_exchange_strong(T &amp;, T, memory_order, memory_order);
    bool compare_exchange_weak(T &amp;, T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(T &amp;, T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst);
    bool compare_exchange_strong(T &amp;, T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(T &amp;, T, <span style="color: #eedd82;">memory_order</span> = memory_order_seq_cst);
    atomic() = default;
    constexpr atomic(T);
    atomic(const atomic &amp;) = delete;
    atomic &amp; <span style="color: #eedd82;">operator</span>=(const atomic &amp;) = delete;
    atomic &amp; <span style="color: #eedd82;">operator</span>=(const atomic &amp;) <span style="color: #eedd82;">volatile</span> = delete;
    T <span style="color: #eedd82;">operator</span>=(T) volatile;
    T <span style="color: #eedd82;">operator</span>=(T);
};
</pre>
</div>

<p>
Integral 特有的函数:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_add</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_add</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst);

<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_sub</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_sub</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst);

<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_and</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_and</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst);

<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_or</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_or</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst);

<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_xor</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #87cefa;">fetch_xor</span>(<span style="color: #98fb98;">integral</span>, memory_order = memory_order_seq_cst);

<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>(<span style="color: #98fb98;">int</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>(<span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>(<span style="color: #98fb98;">int</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>(<span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>() <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>();
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>() <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>();
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">+=</span>(<span style="color: #98fb98;">integral</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">+=</span>(<span style="color: #98fb98;">integral</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">-=</span>(<span style="color: #98fb98;">integral</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">-=</span>(<span style="color: #98fb98;">integral</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&amp;=</span>(<span style="color: #98fb98;">integral</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&amp;=</span>(<span style="color: #98fb98;">integral</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">|=</span>(<span style="color: #98fb98;">integral</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">|=</span>(<span style="color: #98fb98;">integral</span>);
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">^=</span>(<span style="color: #98fb98;">integral</span>) <span style="color: #00ffff;">volatile</span>;
<span style="color: #98fb98;">integral</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">^=</span>(<span style="color: #98fb98;">integral</span>);
</pre>
</div>

<p>
指针特有的函数
</p>
<div class="org-src-container">

<pre class="src src-c++">T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst);

T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) <span style="color: #00ffff;">volatile</span>;
T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst);

  T* <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">T</span>*) <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">T</span>*);
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>(<span style="color: #98fb98;">int</span>) <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>(<span style="color: #98fb98;">int</span>);
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>(<span style="color: #98fb98;">int</span>) <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>(<span style="color: #98fb98;">int</span>);
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>() <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">++</span>();
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>() <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">--</span>();
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">+=</span>(<span style="color: #98fb98;">ptrdiff_t</span>) <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">+=</span>(<span style="color: #98fb98;">ptrdiff_t</span>);
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">-=</span>(<span style="color: #98fb98;">ptrdiff_t</span>) <span style="color: #00ffff;">volatile</span>;
  <span style="color: #98fb98;">T</span>* <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">-=</span>(<span style="color: #98fb98;">ptrdiff_t</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><code>atomic</code> 类型的操作函数</h3>
<div class="outline-text-3" id="text-1-2">
<p>
除了 <code>atomic</code> 类的成员函数,也提供了对其操作的函数:
</p>

<ul class="org-ul">
<li><code>atomic_is_lock_free</code>: checks if the atomic type's operations are
lock-free
</li>
<li><code>atomic_store</code> and <code>atomic_store_explicit</code>: atomically replaces the
value of the atomic object with a non-atomic argument
</li>
<li><code>atomic_load</code> and <code>atomic_load_explicit</code>: atomically obtains the
value stored in an atomic object
</li>
<li><code>atomic_exchange</code> and <code>atomic_exchange_explicit</code>: atomically
replaces the value of the atomic object with non-atomic argument and
returns the old value of the atomic
</li>
<li><code>atomic_compare_exchange_weak</code>
<code>atomic_compare_exchange_weak_explicit</code>
<code>atomic_compare_exchange_strong</code>
<code>atomic_compare_exchange_strong_explicit</code>: atomically compares the
value of the atomic object with non-atomic argument and performs
atomic exchange if equal or atomic load if not
</li>
<li><code>atomic_fetch_add</code>
<code>atomic_fetch_add_explicit</code>: adds a non-atomic value to an atomic
object and obtains the previous value of the atomic 
</li>
<li><code>atomic_fetch_sub</code>
<code>atomic_fetch_sub_explicit</code>: subtracts a non-atomic value from an
atomic object and obtains the previous value of the atomic 
</li>
<li><code>atomic_fetch_and</code>
<code>atomic_fetch_and_explicit</code>: replaces the atomic object with the
result of logical AND with a non-atomic argument and obtains the
previous value of the atomic 
</li>
<li><code>atomic_fetch_or</code>
<code>atomic_fetch_or_explicit</code>: replaces the atomic object with the
result of logical OR with a non-atomic argument and obtains the
previous value of the atomic 
</li>
<li><code>atomic_fetch_xor</code>
<code>atomic_fetch_xor_explicit</code>: replaces the atomic object with the
result of logical XOR with a non-atomic argument and obtains the
previous value of the atomic 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><code>atomic_flag</code> 类</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<code>atomic_flag</code> 是一种原子布尔类型，不同于 <code>std::atomic&lt;bool&gt;</code>, 不提供load
或store操作,只支持两种操作， <code>test_and_set</code> 和 <code>clear</code> 。
</p>

<div class="org-src-container">

<pre class="src src-c++">atomic_flag() noexcept = <span style="color: #00ffff;">default</span>;
atomic_flag (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">atomic_flag</span>&amp;<span style="color: #eedd82;">T</span>) = <span style="color: #00ffff;">delete</span>;
</pre>
</div>

<p>
<code>std::atomic_flag</code> 只有默认构造函数，拷贝构造函数已被禁用. 一般使用
<code>ATOMIC_FLAG_INIT</code> 初始化为clear状态.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">内存序列同步相关操作</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li><code>memory_order</code>: defines memory ordering constraints for the given
atomic operation 
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">memory_order</span> {
    <span style="color: #eedd82;">memory_order_relaxed</span>,
    <span style="color: #eedd82;">memory_order_consume</span>,
    <span style="color: #eedd82;">memory_order_acquire</span>,
    <span style="color: #eedd82;">memory_order_release</span>,
    <span style="color: #eedd82;">memory_order_acq_rel</span>,
    <span style="color: #eedd82;">memory_order_seq_cst</span>
};
</pre>
</div>
</li>
<li><code>kill_dependency</code>: removes the specified object from the
<code>std::memory_order_consume</code> dependency tree
</li>
<li><code>atomic_thread_fence</code>: Establishes memory synchronization ordering
of non-atomic and relaxed atomic accesses, as instructed by order,
without an associated atomic operation.
</li>
<li><code>atomic_signal_fence</code>: Establishes memory synchronization ordering
of non-atomic and relaxed atomic accesses, as instructed by order,
between a thread and a signal handler executed on the same thread.
This is equivalent to std::atomic_thread_fence, except no CPU
instructions for memory ordering are issued. Only reordering of the
instructions by the compiler is suppressed as order instructs. 
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Memory Model and Order</h2>
<div class="outline-text-2" id="text-2">
<p>
在<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/">浅谈Memory Reordering</a>中提及编译开发者和处理器制造商遵循的中心内存排序准则是: 不能改变单线程程序的行为. 从而产生了:
</p>
<ul class="org-ul">
<li>Memory ordering at compile time: 编译优化造成
</li>
<li>Memory ordering at processor time: CPU允许乱序机器指令优化造成
</li>
</ul>

<p>
在多核多线程时代，当多线程共享某一变量时，不同线程对共享变量的读写就应该格外小心，不适当的乱序执行可能导致程序运行错误。所以必须对编译器和
CPU 作出一定的约束才能合理正确地优化你的程序，这个约束就是 <b>内存模型
(Memory Model)</b> .
</p>

<p>
或者说,程序转化成机器指令执行时并不按照之前的原始代码顺序执行,所以内存模型是程序员、编译器，CPU 之间的准则约束,遵守这一准则约束后,大家各自做优化, 从而尽可能提高程序的性能。
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Memory_model_(programming)">wiki上的Memory model</a>给出一个比较抽象的描述: In computing, a memory
model describes the interactions of threads through memory and their
shared use of the data.
</p>

<p>
C++11 中规定了 6 种访存次序(Memory Order)，如下：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">memory_order</span> {
    <span style="color: #eedd82;">memory_order_relaxed</span>,
    <span style="color: #eedd82;">memory_order_consume</span>,
    <span style="color: #eedd82;">memory_order_acquire</span>,
    <span style="color: #eedd82;">memory_order_release</span>,
    <span style="color: #eedd82;">memory_order_acq_rel</span>,
    <span style="color: #eedd82;">memory_order_seq_cst</span>
};
</pre>
</div>

<p>
上面C++11 Atomic涉及 <code>memory_order</code> 的接口, 默认值是
<code>std::memory_order_seq_cst</code> .
</p>

<p>
可以把上述6种访存次序(内存序)分为3类，顺序一致性模型
(<code>memory_order_seq_cst</code>)，Acquire-Release 模型
(<code>memory_order_consume</code>, <code>memory_order_acquire</code>,
<code>memory_order_release</code>, <code>memory_order_acq_rel</code>) 和 Relax 模型
(<code>memory_order_relaxed</code>). 
</p>

<ul class="org-ul">
<li><code>memory_order_relaxed</code>: all reorderings are okay<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</li>
<li><code>memory_order_acquire</code>: guarantees that subsequent loads are not
moved before the current load or any preceding loads.
</li>
<li><code>memory_order_release</code>: preceding stores are not moved past the
current store or any subsequent stores.
</li>
<li><code>memory_order_acq_rel</code>: combines the two previous guarantees.
</li>
<li><code>memory_order_consume</code>: potentially weaker form of
memory_order_acquire that enforces ordering of the current load
before other operations that are data-dependent on it (for instance,
when a load of a pointer is marked memory_order_consume, subsequent
operations that dereference this pointer won’t be moved before it
(yes, even that is not guaranteed on all platforms!).
</li>
<li><code>memory_order_scq_cst</code>: 是 <code>memory_order_acq_rel</code> 的加强版，除了有
<code>acq_rel</code> 语义，还保证是<a href="https://en.wikipedia.org/wiki/Sequential_consistency">sequencially-consistent</a>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">More</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><a href="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/zh/chapter8-Memory-Model/web-resources.md">C++ 多线程与内存模型资料汇总</a>
</li>
<li>Herb Sutter的talk
<ul class="org-ul">
<li><a href="https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2">Atomic Weapons 1</a>
</li>
<li><a href="https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2">Atomic Weapon 2</a>
</li>
</ul>
</li>
<li><a href="https://bartoszmilewski.com/2008/12/01/c-atomics-and-memory-ordering/">C++ atomics and memory ordering</a>
</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://en.cppreference.com/w/cpp/atomic">http://en.cppreference.com/w/cpp/atomic</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://bartoszmilewski.com/2008/12/01/c-atomics-and-memory-ordering/">https://bartoszmilewski.com/2008/12/01/c-atomics-and-memory-ordering/</a>
</p></div>


</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈C++11 multithreading programming]]></title>
    <link href="http://dreamrunner.org/blog/2014/08/25/C11-multithreading-programming/"/>
    <updated>2014-08-25T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/08/25/C11-multithreading-programming</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
上一篇<a href="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/">浅谈C++ Multithreading Programming</a>主要介绍时下规范好的C++使用
Pthread库和Boost Thread库实现C++多线程编程.这里主要谈谈正在规范的C++11
引入的Thread库和Atomic库,终于自带的C++库能支持高效并可移植的
Multithreading编程.分为2篇,这里先谈谈C++11的<a href="http://en.cppreference.com/w/cpp/thread">Thread的库</a> (并包含对
<a href="http://en.cppreference.com/w/c/thread">C的支持</a>), 后一篇谈谈
C++11的<a href="http://en.cppreference.com/w/cpp/atomic">Atomic操作的库</a>.
</p>

<p>
<a href="https://en.wikipedia.org/wiki/C++11">C++11</a>(之前被成为C++0x)是编程语言C++最新版本的标准.它由 <a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">ISO </a>在2011年8月
12日被批准替代<a href="https://en.wikipedia.org/wiki/C++03">C++03</a>. C++11标准正在规范中,从<a href="https://isocpp.org/std/the-standard">ISO页面</a> 可以知道如何获得进行中的草稿:
</p>
<ul class="org-ul">
<li><a href="https://isocpp.org/files/papers/N3690.pdf">下载最新进行的pdf版草稿(N3690)</a>
</li>
<li><a href="https://github.com/cplusplus/draft">从Github获取草稿的源文件</a>
</li>
</ul>

<p>
所以本文:
</p>
<ul class="org-ul">
<li>标准内容主要参考如上的N3690版本的C++11标准.
</li>
<li>使用的编译器是GCC4.8,<a href="https://gcc.gnu.org/gcc-4.8/cxx0x_status.html">关于GCC4.8支持C+11的情况</a>.
</li>
<li>源代码之类主要参考<a href="http://www.cplusplus.com/reference/multithreading/">cplusplus</a> 和 <a href="http://en.cppreference.com/w/">cppreference</a>.
</li>
</ul>

<p>
更多有关C++参考最后的<a href="#reference">其他资料</a>.
</p>

<!-- more -->
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Compile</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC编译支持C++11,使用编译选项 <code>-std=c++11</code> 或 <code>-std=gnu++11</code>, 前者关闭
GNU扩张支持.并加上 <code>-pthread</code> 选项.
</p>

<div class="org-src-container">

<pre class="src src-sh">g++ program.o -o program -std=c++11 -pthread
</pre>
</div>

<p>
如果漏掉 <code>-phtread</code> 选项,编译能通过,当运行出现如下错误:
</p>
<div class="org-src-container">

<pre class="src src-sh">terminate called after throwing an instance of <span style="color: #ffa07a;">'std::system_error'</span>
  what():  Enable multithreading to use std::thread: Operation not permitted
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Threads</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><code>&lt;thread&gt;</code> 概要</h3>
<div class="outline-text-3" id="text-3-1">
<p>
头文件是 <code>&lt;thread&gt;</code>, 分为两部分: <code>thread</code> 类和在namespace
<code>this_thread</code> 用来管理当前thread的函数.具体见之后的<a href="#thread_header">Header &lt;thread&gt; synopsis</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><code>thread::id</code> 类</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code>thread::id</code> 类型的对象为每个执行的线程提供唯一的标识,并为所有并不表示线程执行(默认构造的线程对象)的所有线程对象提供一个唯一的值.
</p>

<p>
<code>thread::id</code> 类没有特别的东西,主要提供方便比较或打印等运算符重载.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> {
 <span style="color: #00ffff;">public</span>:
  id() noexcept;
};
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">==</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">!=</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&lt;</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&lt;=</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&gt;</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #98fb98;">bool</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&gt;=</span>(<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">x</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">charT</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">traits</span>&gt;
<span style="color: #98fb98;">basic_ostream</span>&lt;<span style="color: #98fb98;">charT</span>, <span style="color: #98fb98;">traits</span>&gt;&amp;
<span style="color: #00ffff;">operator</span><span style="color: #87cefa;">&lt;&lt;</span> (<span style="color: #98fb98;">basic_ostream</span>&lt;<span style="color: #98fb98;">charT</span>, <span style="color: #98fb98;">traits</span>&gt;&amp; <span style="color: #eedd82;">out</span>, <span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">id</span>);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Hash support</span>
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">T</span>&gt; <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">hash</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">T</span>&gt; &lt;&gt; <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">hash</span>&lt;<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span>&gt;;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><code>thread</code> 类</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">types:</span>
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">id</span>;
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">construct/copy/destroy:</span>
  thread() noexcept;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt; <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args);
  ~<span style="color: #87cefa;">thread</span>();
  <span style="color: #87cefa;">thread</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  thread(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
  <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  thread&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">members:</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">thread</span>&amp;) noexcept;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">joinable</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">detach</span>();
  <span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">static members:</span>
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">hardware_concurrency</span>() noexcept;
};
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Constructs a thread object</h3>
<div class="outline-text-3" id="text-3-4">
<p>
从如上的 <code>thread</code> 类知道, 构造thread对象:
</p>
<ol class="org-ol">
<li>默认构造构造一个线程对象,但并不代表任何执行线程.
</li>
<li>移动构造从其他线程构造一个thread对象,并设置其他线程为默认构造状态.
</li>
<li>初始化构造创建一个新的thread对象并把它与执行线程相关联.复制/移动所有参数
<code>args..</code> 到thread可访问的内存通过如下函数:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">T</span>&gt;
<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;<span style="color: #98fb98;">T</span>&gt;::<span style="color: #98fb98;">type</span> <span style="color: #87cefa;">decay_copy</span>(<span style="color: #98fb98;">T</span>&amp;&amp; <span style="color: #eedd82;">v</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">forward</span>&lt;T&gt;(v);
}
</pre>
</div>
<p>
求值和复制/移动参数过程丢出的任何exceptions仅在当前线程丢出,不在新线程中.
</p>
<ol class="org-ol">
<li>复制构造复制构造被删除.线程不可被复制.
</li>
</ol>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;utility&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;functional&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread1Fun</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    cout &lt;&lt; <span style="color: #ffa07a;">"Thread 1 executing"</span> &lt;&lt; endl;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread2Fun</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span>&amp; <span style="color: #eedd82;">n</span>) {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Thread 2 executing\n"</span>;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLoops</span> = 5;
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">t1 is not a thread</span>
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t2</span>(Thread1Fun, kLoops + 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">pass by value</span>
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t3</span>(Thread2Fun, <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">ref</span>(<span style="color: #eedd82;">kLoops</span>));  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">pass by reference</span>
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t4</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">move</span>(<span style="color: #eedd82;">t3</span>));
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">t4 is now running f2(). t3 is no longer a thread</span>
  t2.join();
  t4.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">joinable</h3>
<div class="outline-text-3" id="text-3-5">
<p>
用来检查一个线程对象是否是正在执行的线程.若是,返回 <code>true</code>. 所以默认构造thread对象是不可joinable.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ThreadFun</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t</span>;
  cout &lt;&lt; <span style="color: #ffa07a;">"default construct, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; endl;

  t = <span style="color: #7fffd4;">std</span>::thread(ThreadFun);
  cout &lt;&lt; <span style="color: #ffa07a;">"initial construct, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; endl;
  t.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
结果:
</p>
<div class="org-src-container">

<pre class="src src-sh">default construct, joinable: 0
initial construct, joinable: 1
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><code>get_id</code></h3>
<div class="outline-text-3" id="text-3-6">
<p>
返回thread对象的 <code>std::thread::id</code> 值.
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ThreadFun</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(ThreadFun);
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">id_t1</span> = t1.get_id();
  cout &lt;&lt; <span style="color: #ffa07a;">"thread1's id: "</span> &lt;&lt; id_t1 &lt;&lt; endl;
  t1.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><code>native_handle</code></h3>
<div class="outline-text-3" id="text-3-7">
<p>
这个函数是implementation-defined. 它允许提供底层实现细节的访问.但实际使用它是non-portable. 
</p>

<p>
实例: 使用 <code>native_handle</code> 打开在POSIX系统上C++线程的实时调度.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstring&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">iomutex</span>;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ThreadFun</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_id</span>) {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
  <span style="color: #98fb98;">sched_param</span> <span style="color: #eedd82;">sch</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">policy</span>;
  pthread_getschedparam(pthread_self(), &amp;policy, &amp;sch);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(iomutex);
  cout &lt;&lt; <span style="color: #ffa07a;">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span style="color: #ffa07a;">" is executing at priority "</span>
       &lt;&lt; sch.sched_priority &lt;&lt; endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(ThreadFun, 1), <span style="color: #eedd82;">t2</span>(ThreadFun, 2);
  <span style="color: #98fb98;">sched_param</span> <span style="color: #eedd82;">sch</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">policy</span>;
  pthread_getschedparam(t1.native_handle(), &amp;policy, &amp;sch);
  sch.sched_priority = 20;
  <span style="color: #00ffff;">if</span> (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &amp;sch)) {
    cout &lt;&lt; <span style="color: #ffa07a;">"Failed to setschedparam: "</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::strerror(errno) &lt;&lt; endl;
  }
  t1.join();
  t2.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
使用Super User,结果:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ sudo ./test
Thread 1 is executing at priority 20
Thread 2 is executing at priority 0
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><code>hardware_concurrency</code> (static)</h3>
<div class="outline-text-3" id="text-3-8">
<p>
返回硬件支持的thread数.这个值仅作为参考.如果这个值不可计算或没有很多的定义,那么实现返回0.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span> = <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">thread</span>::hardware_concurrency();
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; num &lt;&lt; <span style="color: #ffa07a;">" concurrent threads are supported."</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">swap</h3>
<div class="outline-text-3" id="text-3-9">
<p>
<code>swap</code> 操作用来交换2个线程对象的底层句柄.有2种可选,thread类的成员函数和在std下的全局函数.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread1Fun</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread2Fun</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(Thread1Fun);
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t2</span>(Thread2Fun);
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;

    <span style="color: #7fffd4;">std</span>::swap(t1, t2);
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"after std::swap(t1, t2):"</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;

    t1.swap(t2);
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"after t1.swap(t2):"</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
    t1.join();
    t2.join();
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10">管理当前thread的函数</h3>
<div class="outline-text-3" id="text-3-10">
<p>
在thread的头文件中,加了一个新的namespace <code>this_thread</code> 用来包含一些管理操作当前thread的一些函数.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">yield</span>();
</pre>
</div>
<p>
重新调度线程的执行,让其他线程运行.具体行为依赖于实现,与OS的调度机制有关.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>();
</pre>
</div>
<p>
返回当前线程的 <code>thread::id</code> 类型的对象.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span> &gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sleep_for</span>( <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">sleep_duration</span> );
</pre>
</div>
<p>
阻塞当前线程的执行至少相对时间 <code>sleep_duration</code>.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span> &gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sleep_until</span>( <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>,<span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">sleep_time</span> );
</pre>
</div>
<p>
阻塞当前线程的执行直到绝对时间 <code>sleep_time</code> 到达.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;atomic&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctime&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">system_clock</span>;

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">atomic</span>&lt;<span style="color: #98fb98;">bool</span>&gt; <span style="color: #87cefa;">ready</span>(<span style="color: #7fffd4;">false</span>);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread1Fun</span>() {
  <span style="color: #00ffff;">while</span> (!ready) {
    <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::yield();
  }
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">id</span> = <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::get_id();
  cout &lt;&lt; <span style="color: #ffa07a;">"thread "</span> &lt;&lt; id &lt;&lt; <span style="color: #ffa07a;">"go to sleep"</span> &lt;&lt; endl;
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Thread2Fun</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #eedd82;">id</span> = <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::get_id();
  cout &lt;&lt; <span style="color: #ffa07a;">"thread "</span> &lt;&lt; id &lt;&lt; <span style="color: #ffa07a;">"is running"</span> &lt;&lt; endl;
  ready = <span style="color: #7fffd4;">true</span>;

  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">tt</span> = <span style="color: #7fffd4;">system_clock</span>::to_time_t(<span style="color: #7fffd4;">system_clock</span>::now());
  <span style="color: #00ffff;">struct</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">tm</span> *<span style="color: #eedd82;">ptm</span> = <span style="color: #7fffd4;">std</span>::localtime(&amp;tt);
  ptm-&gt;tm_sec += 2;
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_until(<span style="color: #7fffd4;">system_clock</span>::from_time_t(mktime(ptm)));
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(Thread1Fun);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t2</span>(Thread2Fun);
  t1.join();
  t2.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Mutual exclusion</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><code>&lt;mutex&gt;</code> 概要</h3>
<div class="outline-text-3" id="text-4-1">
<p>
头文件 <code>&lt;mutex&gt;</code> 分为: mutexes,locks和一些特殊函数. 
具体见之后的<a href="#mutex_header">Header &lt;mutex&gt; synopsis</a>.
</p>

<ul class="org-ul">
<li><b>Mutexes</b> 是<a href="#lockable_types">lockable types</a>,用来对关键区域代码访问保护: <a href="#mutex_class"><code>mutex</code></a>,
<a href="#recursive_mutex_class"><code>recursive_mutex</code></a>, <a href="#timed_mutex_class"><code>timed_mutex</code></a>, <a href="#recursive_timed_mutex_class"><code>recursive_timed_mutex</code></a>.
</li>
<li><b>Locks</b> 是用来管理mutex的对象,并对mutex的lifetime自我管理:<a href="#lock_guard_class"><code>lock_guard</code></a>, <a href="#unique_lock_class"><code>unique_lock</code></a>.
</li>
<li><b>Functions</b> 可以同时锁多个mutexes(<a href="#try_lock_func"><code>try_lock</code></a>, <a href="#lock_func"><code>lock</code></a>),并使某个函数只被调用一次(<a href="#call_once_func"><code>call_once</code></a>).
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Lockable types</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a id="lockable_types" name="lockable_types"></a>
</p>
<img src="/images/blog/2014/c++11/lockable_type.png" title="'lockable_type'" >

<p>
C++11为mutex定义了不同类型的要求,如上图的层次,往右要求逐渐加强.
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">BasicLockable</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
BasicLockable 概念描述了最少特性类型,也就是满足(若m是BasicLockable类型
):
</p>
<ul class="org-ul">
<li><code>m.lock()</code>
</li>
<li><code>m.unlock()</code>
</li>
</ul>

<p>
所以所有mutex都满足BasicLockable类型: <code>mutex</code>, <code>recursive_mutex</code>,
<code>timed_mutex</code>, <code>recursive_timed_mutex</code>, <code>unique_lock</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">Lockable</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Lockable 概念扩展了 BasicLockable 概念,并支持 <code>try_lock</code>. 
</p>

<p>
所以这些mutex满足Lockable类型: <code>mutex</code>, <code>recursive_mutex</code>,
<code>timed_mutex</code>, <code>recursive_timed_mutex</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">TimedLockable</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
TimedLockable 概念扩展了 Lockable 概念,并支持 <code>try_lock_for</code> 和
<code>try_lock_until</code>. 
</p>

<p>
所以这些mutex满足TimedLockable类型: <code>timed_mutex</code>,
<code>recursive_timed_mutex</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><code>mutex</code> 类</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<a id="mutex_class" name="mutex_class"></a>
<code>mutex</code> 类提供了一个不可递归的排它锁.基本接口可以从如下类中参考.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">mutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #98fb98;">constexpr</span> <span style="color: #87cefa;">mutex</span>() noexcept;
  ~<span style="color: #87cefa;">mutex</span>();
  <span style="color: #87cefa;">mutex</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">mutex</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
};
}
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>;

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_value</span> = 0;
<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Increase</span>() {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLoops</span> = 100;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kLoops; ++i) {
    count_mutex.lock();
    g_value++;
    count_mutex.unlock();
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 5;
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #7fffd4;">std</span>::thread&gt; <span style="color: #eedd82;">threads</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    threads.push_back(<span style="color: #7fffd4;">std</span>::thread(Increase));
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">auto</span> &amp;<span style="color: #eedd82;">thread</span> : threads) {
    thread.join();
  }
  cout &lt;&lt; <span style="color: #ffa07a;">"value = "</span> &lt;&lt; g_value &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><code>recursive_mutex</code> 类</h3>
<div class="outline-text-3" id="text-4-4">
<p>
<a id="recursive_mutex_class" name="recursive_mutex_class"></a>可递归的排它锁.如下基本接口如 <code>mutex</code> 基本一样.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">recursive_mutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">recursive_mutex</span>();
  ~<span style="color: #87cefa;">recursive_mutex</span>();
  <span style="color: #87cefa;">recursive_mutex</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">recursive_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">recursive_mutex</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">recursive_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>() noexcept;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
};
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><code>timed_mutex</code> 类</h3>
<div class="outline-text-3" id="text-4-5">
<p>
<a id="timed_mutex_class" name="timed_mutex_class"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">timed_mutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">timed_mutex</span>();
  ~<span style="color: #87cefa;">timed_mutex</span>();
  <span style="color: #87cefa;">timed_mutex</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">timed_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">timed_mutex</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">timed_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
};
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><code>recursive_timed_mutex</code> 类</h3>
<div class="outline-text-3" id="text-4-6">
<p>
<a id="recursive_timed_mutex_class" name="recursive_timed_mutex_class"></a>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">recursive_timed_mutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">recursive_timed_mutex</span>();
  ~<span style="color: #87cefa;">recursive_timed_mutex</span>();
  <span style="color: #87cefa;">recursive_timed_mutex</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">recursive_timed_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">recursive_timed_mutex</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">recursive_timed_mutex</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>() noexcept;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
};
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Mutex Exception safety</h3>
<div class="outline-text-3" id="text-4-7">
<p>
基本保证: 当exception被以上 mutex 的成员函数抛出时,这些mutex对象保持有效状态. 如果是 <code>lock</code> 操作被exception, lock不会被抛出exception的线程所拥有.
</p>

<p>
抛出的是一个 <code>system_error</code> exception, 导致的基本情况是:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="left" />

<col class="left" />

<col class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">exception 类型</th>
<th scope="col" class="left">error情况</th>
<th scope="col" class="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>system_error</code></td>
<td class="left"><code>errc::resource_deadlock_would_occur</code></td>
<td class="left">deadlock被检测到</td>
</tr>

<tr>
<td class="left"><code>system_error</code></td>
<td class="left"><code>errc::operation_not_permitted</code></td>
<td class="left">线程没有权利做这个操作</td>
</tr>

<tr>
<td class="left"><code>system_error</code></td>
<td class="left"><code>errc::device_or_resource_busy</code></td>
<td class="left">native handle已经被锁</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><code>lock_guard</code> 类</h3>
<div class="outline-text-3" id="text-4-8">
<p>
<a id="lock_guard_class" name="lock_guard_class"></a>
</p>

<p>
之前的mutex必须写明lock和unlock调用,如果在lock和unlock之间产生
exception,那么必须在exception处理中不能忘记处理unlock.当只是在一个关键区域内需要mutex保护,使用这样的mutex既不方便也容易忘记unlock而造成死锁.
</p>

<p>
引入对之前的mutex的封装后的 <code>lock_guard</code> 和 <code>unique_lock</code> ,提供易用性的 <a href="http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization">RAII-style</a> 机制来获取锁在一段区域内.
</p>

<p>
lock guard 是一个用来管理一个 mutex 对象,并保持锁住它的对象.
</p>

<p>
在构造时,mutex 对象被调用的线程锁住,然后在析构时,mutex 被解锁.它是最简单的lock,并且作为自动作用范围直到它的作用区域结束时特别有用.通过这种方法,它保证 mutex 对象得到解锁即使在exception被抛出时.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">lock_guard</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">Mutex</span> <span style="color: #98fb98;">mutex_type</span>;
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">lock_guard</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>);
  <span style="color: #87cefa;">lock_guard</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">adopt_lock_t</span>);
  ~<span style="color: #87cefa;">lock_guard</span>();
  <span style="color: #87cefa;">lock_guard</span>(lock_guard <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">lock_guard</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(lock_guard <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">pm</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">exposition only</span>
};
}
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdexcept&gt;</span>

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">mtx</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintEven</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>) {
  <span style="color: #00ffff;">if</span> (x % 2 == 0) {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #ffa07a;">" is even\n"</span>;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">throw</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">logic_error</span>(<span style="color: #ffa07a;">"not even"</span>));
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">PrintThreadEvenId</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>) {
  <span style="color: #00ffff;">try</span> {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lck</span>(mtx);
    PrintEven(id);
  } <span style="color: #00ffff;">catch</span> (<span style="color: #7fffd4;">std</span>::logic_error&amp;) {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"[exception caught]"</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">threads</span>[10];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    threads[i] = <span style="color: #7fffd4;">std</span>::thread(PrintThreadEvenId, i+1);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">auto</span>&amp; <span style="color: #eedd82;">th</span> : threads) {
    th.join();
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><code>unique_lock</code> 类</h3>
<div class="outline-text-3" id="text-4-9">
<p>
<a id="unique_lock_class" name="unique_lock_class"></a>
</p>

<p>
<code>unique_lock</code> 与上面的 <code>lock_guard</code> 基本差不多,同样是 <a href="http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization">RAII-style</a> 机制来获取锁在一段区域内的对象.
</p>

<p>
但 <code>lock_guard</code> 非常简单,只提供构造自动拥有锁和析构释放锁,如果需要一些其他的操作,那么就需要更复杂和接口更多的类来处理, <code>lock_guard</code> 能满足如此要求. 它类基本接口如下.
</p>
</div>

<div id="outline-container-sec-4-9-1" class="outline-4">
<h4 id="sec-4-9-1">class</h4>
<div class="outline-text-4" id="text-4-9-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">unique_lock</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">Mutex</span> <span style="color: #98fb98;">mutex_type</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">30.4.2.2.1, construct/copy/destroy:</span>
  unique_lock() noexcept;
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">unique_lock</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>);
  unique_lock(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">defer_lock_t</span>) noexcept;
  <span style="color: #87cefa;">unique_lock</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">try_to_lock_t</span>);
  <span style="color: #87cefa;">unique_lock</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">adopt_lock_t</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #87cefa;">unique_lock</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #87cefa;">unique_lock</span>(<span style="color: #98fb98;">mutex_type</span>&amp; <span style="color: #eedd82;">m</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  ~<span style="color: #87cefa;">unique_lock</span>();
  <span style="color: #87cefa;">unique_lock</span>(unique_lock <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">unique_lock</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(unique_lock <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  unique_lock(<span style="color: #98fb98;">unique_lock</span>&amp;&amp; <span style="color: #eedd82;">u</span>) noexcept;
  unique_lock&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">unique_lock</span>&amp;&amp; u) noexcept;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">30.4.2.2.2, locking:</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">30.4.2.2.3, modifiers:</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">unique_lock</span>&amp; <span style="color: #eedd82;">u</span>) noexcept;
  mutex_type *release() noexcept;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">30.4.2.2.4, observers:</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">owns_lock</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #00ffff;">explicit</span> <span style="color: #00ffff;">operator</span> <span style="color: #98fb98;">bool</span> () <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  mutex_type* mutex() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">mutex_type</span> *<span style="color: #eedd82;">pm</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">exposition only</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">owns</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">exposition only</span>
};
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">Mutex</span>&gt;&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">Mutex</span>&gt;&amp; <span style="color: #eedd82;">y</span>) noexcept;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-9-2" class="outline-4">
<h4 id="sec-4-9-2">Constructor</h4>
<div class="outline-text-4" id="text-4-9-2">
<p>
在<a href="#mutex_header">mutex header概要</a>中可以看到有不同的构造函数,其中一类 <code>unique_lock</code> 构造传入不同的类型:
</p>
<ul class="org-ul">
<li><code>defer_lock</code> : 不去获取mutex,只有要和mutex一样,手动去lock它.
</li>
<li><code>try_to_lock</code> : 相当于在构造时,调用 <code>try_lock</code>, 不阻塞,之后可通过成员函数 <code>bool owns_lock()</code> 或直接操作符 <code>explicit operator bool()
  const</code> 判断是否获取锁成功.
</li>
<li><code>adopt_lock_t</code> : 认为调用的线程已经占有这个锁m.已经占有这个锁了,为什么要去创建一个 <code>unique_lock</code> 去包含它呢? 因为可以利用 <code>unique_lock</code>
中途接手管理这个锁m, 比如想用 <a href="http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization">RAII-style</a> 机制管理它,使它exception
safe等.
</li>
</ul>

<p>
这些类型在源代码定义基本如下:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">defer_lock_t</span> { };
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">try_to_lock_t</span> { };
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">adopt_lock_t</span> { };
constexpr <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">defer_lock_t</span> <span style="color: #eedd82;">defer_lock</span> = <span style="color: #7fffd4;">std</span>::defer_lock_t();
constexpr <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">try_to_lock_t</span> <span style="color: #eedd82;">try_to_lock</span> = <span style="color: #7fffd4;">std</span>::try_to_lock_t();
constexpr <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">adopt_lock_t</span> <span style="color: #eedd82;">adopt_lock</span> = <span style="color: #7fffd4;">std</span>::adopt_lock_t();
</pre>
</div>

<p>
余下的构造:
</p>
<ul class="org-ul">
<li><code>unique_lock();</code> :仅仅创建一个 <code>nique_lock</code> 对象,不和任何mutex相关联.
</li>
<li><code>nique_lock(unique_lock&amp;&amp; other);</code> : 通过other的内容来构造
<code>nique_lock</code>  对像,使得other不和任何mutex相关连联.
</li>
<li><code>explicit unique_lock(mutex_type&amp; m);</code> : 通过 <code>m.lock()</code> 来构造与m相关联的 <code>unique_lock</code> 对象.
</li>
<li><code>unique_lock(mutex_type&amp; m, const std::chrono::duration&lt;Rep,Period&gt;&amp;
  timeout_duration);</code> : 通过 <code>m.try_lock_for(timeout_duration)</code> 来构造与m相关联的 <code>unique_lock</code> 对象.
</li>
<li><code>unique_lock( mutex_type&amp; m, const
  std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time);</code> : 通过
<code>m.try_lock_until(timeout_time)</code> 来构造与m相关联的 <code>unique_lock</code> 对象.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-9-3" class="outline-4">
<h4 id="sec-4-9-3">实例</h4>
<div class="outline-text-4" id="text-4-9-3">
<p>
利用 <code>defer_lock</code>, 不去获取 mutex, 只创建与它相关联的 <code>unique_lock</code> 对象,之后用 <code>lock()</code> 同时去获取两个锁,防止死锁.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Box</span> {
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Box</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>) : num_things{num} {}
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_things</span>;
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">m</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Transfer</span>(<span style="color: #98fb98;">Box</span> *<span style="color: #eedd82;">from</span>, <span style="color: #98fb98;">Box</span> *<span style="color: #eedd82;">to</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">don't actually take the locks yet</span>
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lock1</span>(from-&gt;m, <span style="color: #7fffd4;">std</span>::defer_lock);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lock2</span>(to-&gt;m, <span style="color: #7fffd4;">std</span>::defer_lock);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">lock both unique_locks without deadlock</span>
  <span style="color: #7fffd4;">std</span>::lock(lock1, lock2);
  from-&gt;num_things -= num;
  to-&gt;num_things += num;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors</span>
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #98fb98;">Box</span> <span style="color: #eedd82;">acc1</span>(100);
  <span style="color: #98fb98;">Box</span> <span style="color: #eedd82;">acc2</span>(50);
  cout &lt;&lt; <span style="color: #ffa07a;">"acc1 num = "</span> &lt;&lt; acc1.num_things &lt;&lt;
      <span style="color: #ffa07a;">" ,acc2 num = "</span> &lt;&lt; acc2.num_things &lt;&lt; endl;
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(Transfer, &amp;acc1, &amp;acc2, 10);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t2</span>(Transfer, &amp;acc2, &amp;acc1, 5);
  t1.join();
  t2.join();
  cout &lt;&lt; <span style="color: #ffa07a;">"after transfer: "</span> &lt;&lt; <span style="color: #ffa07a;">"acc1 num = "</span> &lt;&lt; acc1.num_things &lt;&lt;
      <span style="color: #ffa07a;">" ,acc2 num = "</span> &lt;&lt; acc2.num_things &lt;&lt; endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10"><code>lock_guard</code> VS <code>unique_lock</code></h3>
<div class="outline-text-3" id="text-4-10">
<p>
<code>lock_guard</code> 和 <code>unique_lock</code> 很大程序上很相似,都是 <a href="http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization">RAII-style</a> 机制来封装一个mutex的锁, <code>lock_guard</code> 可以说是 <code>unique_lock</code> 更严格并拥有限制的接口的版本.
</p>

<p>
如何合适的选择两者的使用呢? 如果 <code>lock_guard</code> 对于情况A足够,那么就使用它. 不仅仅是从效率(efficiency)考虑,更是从想要表达的功能(functionality)
考虑. 使用 <code>lock_guard</code> 不仅避免了不需要的其他接口的开销,更是对读代码者表达它的意图,你将永远都不需要解锁这个guard.
</p>

<p>
所以你先考虑使用 <code>lock_guard</code>, 除非你需要 <code>unique_lock</code> 的功能. 比如
<code>condition_variable</code> 就需要传入一个 <code>unique_lock</code> 对象.
</p>
</div>
</div>
<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11"><code>try_lock</code> 和 <code>lock</code></h3>
<div class="outline-text-3" id="text-4-11">
<p>
<a id="try_lock_func" name="try_lock_func"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lockable1</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lockable2</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LockableN</span>... &gt;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">try_lock</span>(<span style="color: #98fb98;">Lockable1</span>&amp; <span style="color: #eedd82;">lock1</span>, <span style="color: #98fb98;">Lockable2</span>&amp; <span style="color: #eedd82;">lock2</span>, LockableN&amp; lockn... );
</pre>
</div>

<p>
按对象lock1, lock2, &#x2026;, lockn 从头到尾的顺序尝试去获取每个锁. 如果某个 <code>try_lock</code> 失败, unlock 所有对象并返回. 返回值:
</p>
<ul class="org-ul">
<li>成功: -1.
</li>
<li>失败: 以0为起始点的获取锁失败的对象次序数(0对于lock1, 1对于lock2, ..).
</li>
</ul>
<p>
<a id="lock_func" name="lock_func"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lockable1</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lockable2</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LockableN</span>... &gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>( <span style="color: #98fb98;">Lockable1</span>&amp; <span style="color: #eedd82;">lock1</span>, <span style="color: #98fb98;">Lockable2</span>&amp; <span style="color: #eedd82;">lock2</span>, LockableN&amp; lockn... );
</pre>
</div>

<p>
占有传入的锁lock1, lock2, &#x2026;, lockn,使用 <b>防止死锁算饭</b> 来防止死锁.
</p>

<p>
对于传入对象按照不特定的顺序调用它们的成员函数 <code>lock</code> , <code>try_lock</code>,
<code>unlock</code> ,确保最后所有的锁被获取成功在函数返回时.
</p>
</div>
</div>
<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12"><code>call_once</code></h3>
<div class="outline-text-3" id="text-4-12">
<p>
<a id="call_once_func" name="call_once_func"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">once_flag</span>;
<span style="color: #00ffff;">template</span>&lt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Callable</span>, <span style="color: #00ffff;">class</span>... Args &gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>( <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>, <span style="color: #98fb98;">Callable</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args );
</pre>
</div>
<p>
为了让一段代码只被多个线程只执行一次, mutex 文件中中包含了这个保证只调用一次的接口.
</p>

<p>
<code>once_flag</code> 对象是辅助 <code>call_once</code> 的,作为多个线程共同执行这段的标识,
所以这些个线程必须传入同一个 <code>once_flag</code> 对象.
</p>

<p>
它并对 <b>exception</b> 做一定的处理,如果 <code>call_once</code> 执行的函数以exception
退出,那么exception会抛给调用者.这次已exception退出的执行并不算一次,之后其他函数仍可以继续调用它一次.
</p>

<p>
如下的实例, t1 和 t2线程抛出exception, t3仍然运行一次, t4无论是怎样,都得不到运行.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">once_flag</span> <span style="color: #eedd82;">flag</span>;

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">MayThrowFunction</span>(<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">do_throw</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">only one instance of this function can be run simultaneously</span>
  <span style="color: #00ffff;">if</span> (do_throw) {
    cout &lt;&lt; <span style="color: #ffa07a;">"throw"</span> &lt;&lt; endl;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">this message may be printed from 0 to 3 times</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">if function exits via exception, another function selected</span>
    <span style="color: #00ffff;">throw</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">exception</span>();
  }
  cout &lt;&lt; <span style="color: #ffa07a;">"once"</span> &lt;&lt; endl;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">printed exactly once, it's guaranteed that</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">there are no messages after it</span>
}

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">DoOnce</span>(<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">do_throw</span>) {
  <span style="color: #00ffff;">try</span> {
    <span style="color: #7fffd4;">std</span>::call_once(flag, MayThrowFunction, do_throw);
  }
  <span style="color: #00ffff;">catch</span> (...) {
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(DoOnce, <span style="color: #7fffd4;">true</span>);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t2</span>(DoOnce, <span style="color: #7fffd4;">true</span>);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t3</span>(DoOnce, <span style="color: #7fffd4;">false</span>);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t4</span>(DoOnce, <span style="color: #7fffd4;">true</span>);
  t1.join();
  t2.join();
  t3.join();
  t4.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Condition variables</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><code>&lt;condition_variable&gt;</code> 概要</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<code>&lt;condition_variable&gt;</code> 头文件主要包含两个 <code>condition_variable</code> 类, 一个全局函数.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable</span>;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable_any</span>;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all_at_thread_exit</span>(<span style="color: #98fb98;">condition_variable</span>&amp; <span style="color: #eedd82;">cond</span>, <span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt; <span style="color: #eedd82;">lk</span>);
<span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">cv_status</span> { <span style="color: #eedd82;">no_timeout</span>, <span style="color: #eedd82;">timeout</span> };
}
</pre>
</div>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><code>cv_status</code></h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Condition variables与mutex之类在等待timeout时,返回的不一样,mutex之类放回 <code>bool</code> 类型, 而Condition variables特意为它定义了 <code>enum</code> 类型:
<code>no_timeout</code> 和 <code>timeout</code>, 来判断等待是否成功.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">cv_status</span> { <span style="color: #eedd82;">no_timeout</span>, <span style="color: #eedd82;">timeout</span> };
</pre>
</div>

<ul class="org-ul">
<li><code>cv_status::no_timeout</code> The function returned without a timeout (i.e.,
it was notified).
</li>
<li><code>cv_status::timeout</code> The function returned because it reached its
time limit (timeout).
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><code>notify_all_at_thread_exit</code></h4>
<div class="outline-text-4" id="text-5-1-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all_at_thread_exit</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">condition_variable</span>&amp; <span style="color: #eedd82;">cond</span>,
                                <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::mutex&gt; <span style="color: #eedd82;">lk</span>);
</pre>
</div>
<p>
<code>&lt;condition_variable&gt;</code> 头文件中有这个函数,它提供机制notify其他线程在调用这个函数的线程退出时. 它相当于操作(并包括清理所有 <code>thread_local</code> 对象):
</p>
<div class="org-src-container">

<pre class="src src-c++">lk.unlock();
cond.notify_all();
</pre>
</div>

<p>
虽然可以在调用线程的最后同样调用如上两句代码,但意图没有表现出来,表明
cond的notify必须在线程退出时调用,后面维护者可能会在这之后继续添加代码.
<code>notify_all_at_thread_exit</code> 用一句调用替代两个调用,既不用在函数最后去调用它,而且表明它的意图.
</p>

<p>
它的操作流程如下:
</p>
<ol class="org-ol">
<li>之前获取的锁lk的拥有权被转移到cond的内部.
</li>
<li>当此线程退出时, cond被notified通过:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++">lk.unlock();
cond.notify_all();
</pre>
</div>

<p>
<b>Notes</b>
</p>
<ul class="org-ul">
<li>如果 <code>lk.mutex()</code> 没有被当前线程锁住,调用此函数导致undefined behavior.
</li>
<li>如果 <code>lk.mutex()</code> 的 mutex 不是其他线程使用来等待 condition variable
的同一个的话, 调用此函数导致undefined behavior.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><code>condition_variable</code> 类</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">condition_variable</span>();
  ~<span style="color: #87cefa;">condition_variable</span>();
  <span style="color: #87cefa;">condition_variable</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">condition_variable</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">condition_variable</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">condition_variable</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_one</span>() noexcept;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all</span>() noexcept;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">cv_status</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
                       <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
                  <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>,
                  <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">cv_status</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
                     <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
                <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>,
                <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
  <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">implementation</span>-defined native_handle_type; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
  <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">See 30.2.3</span>
};
}
</pre>
</div>
<p>
Condition Variable的基本概念可以从之前篇<a href="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/#sec-5-4">浅谈C++ Multithreading
 Programming</a>中获取.
</p>

<p>
<code>condition_variable</code> 类的 <code>void wait(unique_lock&lt;mutex&gt;&amp; lock,
Predicate pred);</code> 接口:
</p>
<ul class="org-ul">
<li>需要传入 <code>unique_lock</code>.
</li>
<li><code>pred</code> 函数, 如果predicate返回 <code>false</code> ,等待. 相当于:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">while</span> (!pred()) {
    wait(lock);
}
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;mutex&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;condition_variable&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">string</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">m</span>;
<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">condition_variable</span> <span style="color: #eedd82;">cv</span>;
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">data</span>;
<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">g_ready</span> = <span style="color: #7fffd4;">false</span>;
<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">g_processed</span> = <span style="color: #7fffd4;">false</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">WorkerThread</span>() {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Wait until main() sends data</span>
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(m);
    cv.wait(lk, []{<span style="color: #00ffff;">return</span> g_ready;});

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">after the wait, we own the lock.</span>
    cout &lt;&lt; <span style="color: #ffa07a;">"Worker thread is processing data"</span> &lt;&lt; endl;
    data += <span style="color: #ffa07a;">" after processing"</span>;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Send data back to main()</span>
    g_processed = <span style="color: #7fffd4;">true</span>;
    cout &lt;&lt; <span style="color: #ffa07a;">"Worker thread signals data processing completed"</span> &lt;&lt; endl;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Manual unlocking is done before notifying, to avoid</span>
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">that the waiting thread gets blocked again.</span>
    lk.unlock();
    cv.notify_one();
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">worker</span>(WorkerThread);
     data = <span style="color: #ffa07a;">"Example data"</span>;
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">send data to the worker thread</span>
    {
        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(m);
        g_ready = <span style="color: #7fffd4;">true</span>;
        cout &lt;&lt; <span style="color: #ffa07a;">"main() signals data ready for processing"</span> &lt;&lt; endl;
    }
    cv.notify_one();

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">wait for the worker</span>
    {
        <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(m);
        cv.wait(lk, []{<span style="color: #00ffff;">return</span> g_processed;});
    }
    cout &lt;&lt; <span style="color: #ffa07a;">"Back in main(), data = "</span> &lt;&lt; data &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
    worker.join();
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><code>condition_variable_any</code> 类</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable_any</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">condition_variable_any</span>();
  ~<span style="color: #87cefa;">condition_variable_any</span>();
  <span style="color: #87cefa;">condition_variable_any</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">condition_variable_any</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">condition_variable_any</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">condition_variable_any</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_one</span>() noexcept;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all</span>() noexcept;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>&gt;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">cv_status</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>,
                  <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">cv_status</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Lock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Predicate</span>&gt;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #98fb98;">Lock</span>&amp; <span style="color: #eedd82;">lock</span>, <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>,
                <span style="color: #98fb98;">Predicate</span> <span style="color: #eedd82;">pred</span>);
};
}
</pre>
</div>

<p>
<code>condition_variable_any</code> 是 <code>condition_variable</code> 的一个通用版,它可以等待任何满足 BasicLockable 要求Lock类型的对象.其他与 <code>condition_variable</code>
一样.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;condition_variable&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;

<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">condition_variable_any</span> <span style="color: #eedd82;">cv</span>;
<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">cv_m</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This mutex is used for three purposes:</span>
                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">1) to synchronize accesses to i</span>
                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2) to synchronize accesses to std::cout</span>
                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">3) for the condition variable cv</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_wait_val</span> = 0;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">WaitVal</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>) {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(cv_m);
  cout &lt;&lt; <span style="color: #ffa07a;">"thread "</span> &lt;&lt; id &lt;&lt; <span style="color: #ffa07a;">" Waiting... "</span> &lt;&lt; endl;
  cv.wait(lk, []{<span style="color: #00ffff;">return</span> g_wait_val == 1;});
  cout &lt;&lt; <span style="color: #ffa07a;">"...finished waiting,"</span> &lt;&lt; <span style="color: #ffa07a;">"thread "</span> &lt;&lt; id &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Signals</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
  {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(cv_m);
    cout &lt;&lt; <span style="color: #ffa07a;">"Notifying..."</span> &lt;&lt; endl;
  }
  cv.notify_all();
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">this_thread</span>::sleep_for(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::seconds(1));
  {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #eedd82;">lk</span>(cv_m);
    g_wait_val = 1;
    cout &lt;&lt; <span style="color: #ffa07a;">"Notifying again..."</span> &lt;&lt; endl;
  }
  cv.notify_all();
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>&lt;<span style="color: #7fffd4;">std</span>::thread&gt; <span style="color: #eedd82;">threads</span>;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 3; ++i) {
    threads.emplace_back(WaitVal, i);
  }
  threads.emplace_back(Signals);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">auto</span>&amp; <span style="color: #eedd82;">t</span> : threads) {
        t.join();
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><code>condition_variable</code> VS <code>condition_variable_any</code></h3>
<div class="outline-text-3" id="text-5-4">
<p>
引自N3690 §30.5[thread.condition]:
</p>

<p>
Class <code>condition_variable</code> provides a condition variable that can only
wait on an object of type <code>unique_lock&lt;mutex&gt;</code> , allowing maximum
efficiency on some platforms. Class <code>condition_variable_any</code> provides a
general condition variable that can wait on objects of user-supplied
lock types.
</p>

<p>
<code>condition_variable</code> 只与 <code>unique_lock&lt;mutex&gt;</code> 类型对象关联,在某些平台上,它可以更好的得到特定的优化,如果不需要
<code>condition_variable_any</code> 的灵活性, 选更高效的 <code>condition_variable</code> 对象使用.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Future</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><code>&lt;future&gt;</code> 概要</h3>
<div class="outline-text-3" id="text-6-1">
<p>
如果要异步的获取一个函数的运行结果, 可以创建一个线程,并利用Condition
varialbes 来同步线程间使得另外线程正确获取到这个结果. 但C++11的
<code>future</code> 库使得这一过程更方便, 它提供接口使程序在一个线程中获取一个在同一个或其他线程中运行的函数的结果(值或异常), (这些类使用并不限制在
multi-threaded 程序中,同样可以在 single-threaded 使用.
</p>

<p>
<a href="#future_header">future的概要</a>主要分为:
</p>
<ul class="org-ul">
<li>运行函数提供共享结果的Providers类: <code>promise</code> 和 <code>packaged_task</code> .
</li>
<li>获取共享结果的Futures类: <code>future</code> 和 <code>shared_future</code> .
</li>
<li>Error handling: <code>future_error</code> , <code>future_errc</code> 等.
</li>
<li>Providers提供函数: <code>async</code> .
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Error handling</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><code>future_error</code> 类</h4>
<div class="outline-text-4" id="text-6-2-1">
<img src="/images/blog/2014/c++11/future_error.png" title="'future_error'" >

<p>
<code>future_error</code> 类定义对future对象非法操作抛出异常的对象类型. 也就是专门为future库中接口出现异常提供特定的异常类.
</p>

<p>
从上图类图可知,这个类继承自 <a href="http://www.cplusplus.com/logic_error"><code>logic_error</code></a> , 并添加获取<a href="http://www.cplusplus.com/error_code"> <code>error_code</code></a> 的成员函数 <code>code</code> , 获取exception信息的 <code>what</code> 成员函数.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_error</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">logic_error</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">future_error</span>(<span style="color: #98fb98;">error_code</span> <span style="color: #eedd82;">ec</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">exposition only</span>
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">error_code</span>&amp; <span style="color: #87cefa;">code</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #87cefa;">what</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
};
}
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">error_code</span>&amp; <span style="color: #87cefa;">code</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">empty</span>;
  <span style="color: #00ffff;">try</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = empty.get();
  } <span style="color: #00ffff;">catch</span> (<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future_error</span>&amp; <span style="color: #eedd82;">e</span>) {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Caught a future_error with code \""</span> &lt;&lt; e.code()
              &lt;&lt; <span style="color: #ffa07a;">"\"\nMessage: \""</span> &lt;&lt; e.what() &lt;&lt; <span style="color: #ffa07a;">"\"\n"</span>;
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><code>future_errc</code></h4>
<div class="outline-text-4" id="text-6-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_errc</span> {
    <span style="color: #eedd82;">broken_promise</span>             = <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation-defined */</span>,
    <span style="color: #eedd82;">future_already_retrieved</span>   = <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation-defined */</span>,
    <span style="color: #eedd82;">promise_already_satisfied</span>  = <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation-defined */</span>,
    <span style="color: #eedd82;">no_state</span>                   = <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation-defined */</span>
};
</pre>
</div>

<p>
这个enum class定义了future抛出异常的<a href="http://en.cppreference.com/w/cpp/error/error_condition">error condition</a>. <code>future_errc</code> 的值可以用来创建 <code>error_condition</code> 对象, 并与 <code>future_error</code> 的成员函数
<code>code</code> 返回的值对比, 决定所抛出异常的类型.
</p>

<p>
所以 <code>&lt;future&gt;</code> 另外有两个函数提供它们之间的转换:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">error_code</span> <span style="color: #87cefa;">make_error_code</span>( <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future_errc</span> <span style="color: #eedd82;">e</span> );
<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">error_condition</span> <span style="color: #87cefa;">make_error_condition</span>( <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future_errc</span> <span style="color: #eedd82;">e</span> );
<span style="color: #00ffff;">template</span>&lt;&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">is_error_condition_enum</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future_errc</span>&gt; : <span style="color: #7fffd4;">std</span>::true_type;
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">prom</span>;

  <span style="color: #00ffff;">try</span> {
    prom.get_future();
    prom.get_future();
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">throws std::future_error with future_already_retrieved</span>
  }
  <span style="color: #00ffff;">catch</span> (<span style="color: #7fffd4;">std</span>::future_error&amp; e) {
    <span style="color: #00ffff;">if</span> (e.code() ==
        <span style="color: #7fffd4;">std</span>::make_error_condition(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">future_errc</span>::future_already_retrieved)) {
      <span style="color: #7fffd4;">std</span>::cerr &lt;&lt; <span style="color: #ffa07a;">"[future already retrieved]\n"</span>;
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #7fffd4;">std</span>::cerr &lt;&lt; <span style="color: #ffa07a;">"[unknown exception]\n"</span>;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><code>future_status</code></h4>
<div class="outline-text-4" id="text-6-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_status</span> {
    <span style="color: #eedd82;">ready</span>,
    <span style="color: #eedd82;">timeout</span>,
    <span style="color: #eedd82;">deferred</span>
};
</pre>
</div>

<p>
<code>future</code> 和 <code>shared_future</code> 类中属于wait类型的接口返回的状态.
</p>
<ul class="org-ul">
<li>deferred: 返回这个类型是因为共享状态(shared state)含有的一个deferred
函数.(见<a href="#async">async函数</a>)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4"><code>future_category</code></h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
用来识别future error种类.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">error_category</span>&amp; <span style="color: #87cefa;">future_category</span>();
</pre>
</div>

<p>
这个函数返回一个 <code>error_category</code> 类型的静态对象,拥有如下特性:
</p>
<ul class="org-ul">
<li>它的 <code>name</code> 成员函数返回指向字符串"future"的指针.
</li>
</ul>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">prom</span>;
  <span style="color: #00ffff;">try</span> {
    prom.get_future();
    prom.get_future();
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">throws a std::future_error of the future category</span>
  }
  <span style="color: #00ffff;">catch</span> (<span style="color: #7fffd4;">std</span>::future_error&amp; e) {
    <span style="color: #00ffff;">if</span> (e.code().category() == <span style="color: #7fffd4;">std</span>::future_category()) {
      <span style="color: #7fffd4;">std</span>::cerr &lt;&lt; <span style="color: #ffa07a;">"future_error of the future category thrown\n"</span>;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><code>template promise</code></h3>
<div class="outline-text-3" id="text-6-3">
<p>
模版类 promise 提供一种方便的方法存储一个值或异常,之后可以异步的被
future对象获取(同一个或其他线程).
</p>

<p>
promise对象在共享状态(shared state)存储值的操作 <b>synchronizes-with</b> 在其他函数中成功获取这个共享状态的返回值(如 <code>future::get</code> ).
</p>
</div>
<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1">class</h4>
<div class="outline-text-4" id="text-6-3-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">promise</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">promise</span>();
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Allocator</span>&gt;
  <span style="color: #87cefa;">promise</span>(<span style="color: #98fb98;">allocator_arg_t</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Allocator</span>&amp; <span style="color: #eedd82;">a</span>);
  promise(<span style="color: #98fb98;">promise</span>&amp;&amp; <span style="color: #eedd82;">rhs</span>) noexcept;
  <span style="color: #87cefa;">promise</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">promise</span>&amp; <span style="color: #eedd82;">rhs</span>) = <span style="color: #00ffff;">delete</span>;
  ~<span style="color: #87cefa;">promise</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">assignment</span>
  promise&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">promise</span>&amp;&amp; rhs) noexcept;
  <span style="color: #98fb98;">promise</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">promise</span>&amp; <span style="color: #eedd82;">rhs</span>) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">promise</span>&amp; <span style="color: #eedd82;">other</span>) noexcept;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">retrieving the result</span>
  <span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">R</span>&gt; <span style="color: #87cefa;">get_future</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">setting the result</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_value</span>(<span style="color: #98fb98;">see</span> <span style="color: #eedd82;">below</span> );
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_exception</span>(<span style="color: #98fb98;">exception_ptr</span> <span style="color: #eedd82;">p</span>);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">setting the result with deferred notification</span>
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_value_at_thread_exit</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">R</span>&amp; <span style="color: #eedd82;">r</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_value_at_thread_exit</span>(<span style="color: #98fb98;">see</span> <span style="color: #eedd82;">below</span> );
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_exception_at_thread_exit</span>(<span style="color: #98fb98;">exception_ptr</span> <span style="color: #eedd82;">p</span>);
};
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;&amp; <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Alloc</span>&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uses_allocator</span>&lt;<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;, <span style="color: #98fb98;">Alloc</span>&gt;;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><code>set_value</code> and <code>set_value_at_thread_exit</code></h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
<code>set_value</code> 接口存储值到shared state,并使state准备好.这个操作是原子性的. 而 <code>set_value_at_thread_exit</code> 接口如名字,调用后不会马上设置值到
shared state中,只在当前函数退出时.
</p>

<p>
使用 <code>get_future</code> 返回与它相关联同一个shared state的future对象.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;functional&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Print</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt;&amp; <span style="color: #eedd82;">fut</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">(synchronizes with getting the future)</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = fut.get();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"value: "</span> &lt;&lt; x &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">prom</span>;
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">fut</span> = prom.get_future();
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t1</span>(Print, <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">ref</span>(<span style="color: #eedd82;">fut</span>));
  prom.set_value(10);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">fulfill promise</span>
  t1.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-3" class="outline-4">
<h4 id="sec-6-3-3"><code>set_exception</code> and <code>set_exception_at_thread_exit</code></h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
这两个接口与上面 <code>set_value</code> 和  <code>set_value_at_thread_exit</code> 一样, 只是保存的是exception.
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">result</span>;

  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">t</span>([&amp;]{
      <span style="color: #00ffff;">try</span> {
        <span style="color: #00ffff;">throw</span> <span style="color: #7fffd4;">std</span>::runtime_error(<span style="color: #ffa07a;">"Example"</span>);
      } <span style="color: #00ffff;">catch</span>(...) {
        <span style="color: #00ffff;">try</span> {
          <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">store anything thrown in the promise</span>
          result.set_exception(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">current_exception</span>());
        } <span style="color: #00ffff;">catch</span>(...) {}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">set_exception() may throw too</span>
      }
    });

  <span style="color: #00ffff;">try</span> {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; result.get_future().get();
  } <span style="color: #00ffff;">catch</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">exception</span>&amp; <span style="color: #eedd82;">e</span>) {
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Exception from the thread: "</span> &lt;&lt; e.what() &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
  }
  t.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><code>template packaged_task</code></h3>
<div class="outline-text-3" id="text-6-4">
<p>
<code>packaged_task</code> 与 <code>promise</code> 类似,都是提供异步获取值的方法,不同是
<code>promise</code> 直接设置值, 而 <code>packaged_task</code> 封装一个可调用的元素,并把这个可调用任务的返回值异步到shared state中.
</p>
</div>
<div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1">class</h4>
<div class="outline-text-4" id="text-6-4-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">class</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">packaged_task</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">undefined</span>
<span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span>... ArgTypes&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">packaged_task</span>&lt;R(<span style="color: #eedd82;">ArgTypes</span>...)&gt; {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">construction and destruction</span>
  packaged_task() noexcept;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">packaged_task</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>);
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Allocator</span>&gt;
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">packaged_task</span>(<span style="color: #98fb98;">allocator_arg_t</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">Allocator</span>&amp; <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>);
  ~packaged_task();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">no copy</span>
  packaged_task(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">packaged_task</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">packaged_task</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">packaged_task</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">move support</span>
  packaged_task(<span style="color: #98fb98;">packaged_task</span>&amp;&amp; <span style="color: #eedd82;">rhs</span>) noexcept;
  packaged_task&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">packaged_task</span>&amp;&amp; rhs) noexcept;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">packaged_task</span>&amp; <span style="color: #eedd82;">other</span>) noexcept;
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">valid</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">result retrieval</span>
  <span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">R</span>&gt; <span style="color: #87cefa;">get_future</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">execution</span>
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span>(ArgTypes... );
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">make_ready_at_thread_exit</span>(ArgTypes...);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reset</span>();
};
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span>... ArgTypes&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">packaged_task</span>&lt;R(ArgTypes...)&gt;&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">packaged_task</span>&lt;R(ArgTypes...)&gt;&amp; <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Alloc</span>&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uses_allocator</span>&lt;<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">R</span>&gt;, <span style="color: #98fb98;">Alloc</span>&gt;;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-4-2" class="outline-4">
<h4 id="sec-6-4-2">construct and use</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
<code>packaged_task</code> 的创建与 <code>thread</code> 类似, 它可以:
</p>
<ul class="org-ul">
<li>Lambda表达式.
</li>
<li>Bind一个函数.
</li>
<li>直接传入函数.
</li>
</ul>

<p>
运行:
</p>
<ul class="org-ul">
<li>因为它重载了操作符 <code>()</code> , 可以直接运行如: <code>task()</code> .
</li>
<li>可以 <code>move</code> 给一个线程运行.
</li>
</ul>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cmath&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;functional&gt;</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">unique function to avoid disambiguating the std::pow overload set</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">FunPow</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>) {
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::pow(x, y);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TaskLambda</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">int</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>)&gt; <span style="color: #eedd82;">task</span>([](<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>) {
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::pow(a, b);
    });
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">result</span> = task.get_future();
  task(2, 9);
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"task_lambda:\t"</span> &lt;&lt; result.get() &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TaskBind</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">int</span>()&gt; <span style="color: #eedd82;">task</span>(<span style="color: #7fffd4;">std</span>::bind(FunPow, 2, 11));
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">result</span> = task.get_future();
  task();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"task_bind:\t"</span> &lt;&lt; result.get() &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">TaskThread</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">int</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>)&gt; <span style="color: #eedd82;">task</span>(FunPow);
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">result</span> = task.get_future();
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">task_td</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">move</span>(<span style="color: #eedd82;">task</span>), 2, 10);
  task_td.join();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"task_thread:\t"</span> &lt;&lt; result.get() &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  TaskLambda();
  TaskBind();
  TaskThread();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-4-3" class="outline-4">
<h4 id="sec-6-4-3">reset</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
<code>packaged_task</code> 的 <code>reset</code> 接口, 重置状态,舍弃之前运行的结果.相当于: <code>*this = packaged_task(std::move(f))</code> .
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cmath&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;thread&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">int</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>)&gt; <span style="color: #eedd82;">task</span>([](<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>) {
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::pow(a, b);
    });
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">result</span> = task.get_future();
    task(2, 9);
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"2^9 = "</span> &lt;&lt; result.get() &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;

    task.reset();
    result = task.get_future();
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">task_td</span>(<span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">move</span>(<span style="color: #eedd82;">task</span>), 2, 10);
    task_td.join();
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"2^10 = "</span> &lt;&lt; result.get() &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><code>template future</code> 类</h3>
<div class="outline-text-3" id="text-6-5">
<p>
模版类 <code>future</code> 是用来异步获取共享状态里的结果. <code>future</code> 类是独占的,不能与其他 <code>future</code> 共享异步的获取结果. 若要多个 <code>future</code> 共享异步结果,
使用之后的 <code>shared_future</code> 类.
</p>

<p>
有效的与共享状态相关联的future对象,由如下函数构造:
</p>
<ul class="org-ul">
<li><code>async</code> .
</li>
<li><code>promise::get_future</code> .
</li>
<li><code>package_task::get_future</code> .
</li>
</ul>

<p>
它的接口:
</p>
<ul class="org-ul">
<li><code>share</code> : 转换 shared state 从 *this 到一个 <code>shared_future</code> 对象.
</li>
<li><code>get</code> : 返回shared state的值, 若未准备好,调用者阻塞等待它准备好.
</li>
<li><code>wait</code> : 阻塞等待结果直到有效.
</li>
<li><code>wait_for</code> 和 <code>wait_until</code> : 等待一段时间, 并通过 <code>future_status</code> 判断等待后的状态.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future</span> {
 <span style="color: #00ffff;">public</span>:
  future() noexcept;
  future(<span style="color: #98fb98;">future</span> &amp;&amp;) noexcept;
  <span style="color: #87cefa;">future</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">future</span>&amp; <span style="color: #eedd82;">rhs</span>) = <span style="color: #00ffff;">delete</span>;
  ~<span style="color: #87cefa;">future</span>();
  <span style="color: #98fb98;">future</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">future</span>&amp; <span style="color: #eedd82;">rhs</span>) = <span style="color: #00ffff;">delete</span>;
  future&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">future</span>&amp;&amp;) noexcept;
  <span style="color: #98fb98;">shared_future</span>&lt;<span style="color: #98fb98;">R</span>&gt; <span style="color: #87cefa;">share</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">retrieving the value</span>
  see <span style="color: #98fb98;">below</span> <span style="color: #87cefa;">get</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">functions to check state</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">valid</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>() <span style="color: #00ffff;">const</span>;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">future_status</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>) <span style="color: #00ffff;">const</span>;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">future_status</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>) <span style="color: #00ffff;">const</span>;
};
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><code>template shared_future</code> 类</h3>
<div class="outline-text-3" id="text-6-6">
<p>
模版类 <code>shared_future</code> 与 <code>future</code> 基本一样, 不同就是多个
<code>shared_future</code> 对象可以共享异步结果.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">shared_future</span> {
 <span style="color: #00ffff;">public</span>:
  shared_future() noexcept;
  <span style="color: #87cefa;">shared_future</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">shared_future</span>&amp; <span style="color: #eedd82;">rhs</span>);
  shared_future(<span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">R</span>&gt;&amp;&amp;) noexcept;
  shared_future(<span style="color: #98fb98;">shared_future</span>&amp;&amp; <span style="color: #eedd82;">rhs</span>) noexcept;
  ~<span style="color: #87cefa;">shared_future</span>();
  <span style="color: #98fb98;">shared_future</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">shared_future</span>&amp; <span style="color: #eedd82;">rhs</span>);
  shared_future&amp; <span style="color: #00ffff;">operator</span>=(<span style="color: #98fb98;">shared_future</span>&amp;&amp; rhs) noexcept;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">retrieving the value</span>
  see <span style="color: #98fb98;">below</span> <span style="color: #87cefa;">get</span>() <span style="color: #00ffff;">const</span>;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">functions to check state</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">valid</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>() <span style="color: #00ffff;">const</span>;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
  <span style="color: #98fb98;">future_status</span> <span style="color: #87cefa;">wait_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>) <span style="color: #00ffff;">const</span>;
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
  <span style="color: #98fb98;">future_status</span> <span style="color: #87cefa;">wait_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>) <span style="color: #00ffff;">const</span>;
};
}
</pre>
</div>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;chrono&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">void</span>&gt; <span style="color: #eedd82;">ready_promise</span>, <span style="color: #eedd82;">t1_ready_promise</span>, <span style="color: #eedd82;">t2_ready_promise</span>;
  <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">shared_future</span>&lt;<span style="color: #98fb98;">void</span>&gt; <span style="color: #eedd82;">ready_future</span>(ready_promise.get_future());
  <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::high_resolution_clock&gt; <span style="color: #eedd82;">start</span>;

  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">fun1</span> = [&amp;]() -&gt; <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">double</span>, <span style="color: #7fffd4;">std</span>::milli&gt; {
    t1_ready_promise.set_value();
    ready_future.wait();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">waits for the signal from main()</span>
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #7fffd4;">high_resolution_clock</span>::now() - start;
  };

  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">fun2</span> = [&amp;]() -&gt; <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">double</span>, <span style="color: #7fffd4;">std</span>::milli&gt; {
    t2_ready_promise.set_value();
    ready_future.wait();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">waits for the signal from main()</span>
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #7fffd4;">high_resolution_clock</span>::now() - start;
  };

  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">result1</span> = <span style="color: #7fffd4;">std</span>::async(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">launch</span>::async, fun1);
  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">result2</span> = <span style="color: #7fffd4;">std</span>::async(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">launch</span>::async, fun2);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">wait for the threads to become ready</span>
  t1_ready_promise.get_future().wait();
  t2_ready_promise.get_future().wait();

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the threads are ready, start the clock</span>
  start = <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">chrono</span>::<span style="color: #7fffd4;">high_resolution_clock</span>::now();

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">signal the threads to go</span>
  ready_promise.set_value();

  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Thread 1 received the signal "</span>
            &lt;&lt; result1.get().count() &lt;&lt; <span style="color: #ffa07a;">" ms after start\n"</span>
            &lt;&lt; <span style="color: #ffa07a;">"Thread 2 received the signal "</span>
            &lt;&lt; result2.get().count() &lt;&lt; <span style="color: #ffa07a;">" ms after start\n"</span>;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7">template async 函数</h3>
<div class="outline-text-3" id="text-6-7">
<p>
<a id="async" name="async"></a>
模版函数 <code>asnyc</code> 异步运行函数f,并返回一个 <code>future</code> 对象来获取这个函数调用的结果.
</p>
</div>
<div id="outline-container-sec-6-7-1" class="outline-4">
<h4 id="sec-6-7-1">Launching policy for async</h4>
<div class="outline-text-4" id="text-6-7-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">launch</span> : <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">unspecified */</span> {
    async =    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">unspecified */</span>,
    deferred = <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">unspecified */</span>,
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation-defined */</span>
};
</pre>
</div>

<p>
函数 <code>async</code> 有不同的策略来运行函数:
</p>
<ul class="org-ul">
<li><code>launch::async</code> :创建一个新的线程来调用函数ｆ.
</li>
<li><code>launch::deferred</code> :调用函数f延迟(deferred)到返回的future的shared
state被访问时(wait或get).
</li>
<li><code>launch::async|launch::deferred</code> :函数自动选择策略运行.与系统的库实现有关.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-7-2" class="outline-4">
<h4 id="sec-6-7-2">async</h4>
<div class="outline-text-4" id="text-6-7-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span>... Args&gt;
<span style="color: #98fb98;">future</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">result_of</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;<span style="color: #98fb98;">F</span>&gt;::<span style="color: #98fb98;">type</span>(<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;Args&gt;::<span style="color: #98fb98;">type</span>...)&gt;::<span style="color: #98fb98;">type</span>&gt;
<span style="color: #87cefa;">async</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args);
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span>... Args&gt;
<span style="color: #98fb98;">future</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">result_of</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;<span style="color: #98fb98;">F</span>&gt;::<span style="color: #98fb98;">type</span>(<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;Args&gt;::<span style="color: #98fb98;">type</span>...)&gt;::<span style="color: #98fb98;">type</span>&gt;
<span style="color: #87cefa;">async</span>(<span style="color: #98fb98;">launch</span> <span style="color: #eedd82;">policy</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args);
</pre>
</div>

<p>
第一个接口没有 <code>policy</code> 作为传入参数, 相当于
<code>async(std::launch::async | std::launch::deferred, f, args...)</code>
</p>

<p>
实例:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">NOLINT</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;algorithm&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;numeric&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;future&gt;</span>

<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">RAIter</span>&gt;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ParallelSum</span>(<span style="color: #98fb98;">RAIter</span> <span style="color: #eedd82;">beg</span>, <span style="color: #98fb98;">RAIter</span> <span style="color: #eedd82;">end</span>) {
  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">len</span> = <span style="color: #7fffd4;">std</span>::distance(beg, end);
  <span style="color: #00ffff;">if</span> (len &lt; 1000)
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">std</span>::accumulate(beg, end, 0);

  <span style="color: #98fb98;">RAIter</span> <span style="color: #eedd82;">mid</span> = beg + len/2;
  <span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">handle</span> = <span style="color: #7fffd4;">std</span>::async(<span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">launch</span>::async,
                           <span style="color: #98fb98;">ParallelSum</span>&lt;<span style="color: #98fb98;">RAIter</span>&gt;, mid, end);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sum</span> = ParallelSum(beg, mid);
  <span style="color: #00ffff;">return</span> sum + handle.get();
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">v</span>(10000, 1);
    <span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"The sum is "</span> &lt;&lt; ParallelSum(v.begin(), v.end()) &lt;&lt; <span style="color: #ffa07a;">'\n'</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Header synopsis</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><code>&lt;thread&gt;</code></h3>
<div class="outline-text-3" id="text-7-1">
<p>
<a id="thread_header" name="thread_header"></a>
基本概要如下(§30.3 [thread.threads] of N3690):
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Header &lt;thread&gt; synopsis</span>
<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread</span>;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">thread</span>&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">thread</span>&amp; <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">this_thread</span> {
<span style="color: #7fffd4;">thread</span>::<span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>() noexcept;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">yield</span>() noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sleep_until</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">abs_time</span>);
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Rep</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Period</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sleep_for</span>(<span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">duration</span>&lt;<span style="color: #98fb98;">Rep</span>, <span style="color: #98fb98;">Period</span>&gt;&amp; <span style="color: #eedd82;">rel_time</span>);
}
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><code>&lt;mutex&gt;</code></h3>
<div class="outline-text-3" id="text-7-2">
<p>
<a id="mutex_header" name="mutex_header"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Header &lt;mutex&gt; synopsis</span>
<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">mutex</span>;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">recursive_mutex</span>;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">timed_mutex</span>;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">recursive_timed_mutex</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">defer_lock_t</span> { };
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">try_to_lock_t</span> { };
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">adopt_lock_t</span> { };
constexpr <span style="color: #98fb98;">defer_lock_t</span> <span style="color: #eedd82;">defer_lock</span> { };
constexpr <span style="color: #98fb98;">try_to_lock_t</span> <span style="color: #eedd82;">try_to_lock</span> { };
constexpr <span style="color: #98fb98;">adopt_lock_t</span> <span style="color: #eedd82;">adopt_lock</span> { };
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">lock_guard</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">unique_lock</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Mutex</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">Mutex</span>&gt;&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">Mutex</span>&gt;&amp; <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">L1</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">L2</span>, <span style="color: #00ffff;">class</span>... L3&gt; <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">try_lock</span>(<span style="color: #98fb98;">L1</span>&amp;, <span style="color: #98fb98;">L2</span>&amp;, L3&amp;...);
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">L1</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">L2</span>, <span style="color: #00ffff;">class</span>... L3&gt; <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>(<span style="color: #98fb98;">L1</span>&amp;, <span style="color: #98fb98;">L2</span>&amp;, L3&amp;...);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">once_flag</span> {
  <span style="color: #98fb98;">constexpr</span> <span style="color: #87cefa;">once_flag</span>() noexcept;
  <span style="color: #87cefa;">once_flag</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">once_flag</span>&amp;) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">once_flag</span>&amp;) = <span style="color: #00ffff;">delete</span>;
};
<span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Callable</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>, <span style="color: #98fb98;">Callable</span> <span style="color: #eedd82;">func</span>, Args&amp;&amp;... args);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><code>&lt;future&gt;</code></h3>
<div class="outline-text-3" id="text-7-3">
<p>
<a id="future_header" name="future_header"></a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span> {
<span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_errc</span> {
<span style="color: #eedd82;">broken_promise</span> = implementation-defined ,
<span style="color: #eedd82;">future_already_retrieved</span> = implementation-defined ,
<span style="color: #eedd82;">promise_already_satisfied</span> = implementation-defined ,
<span style="color: #eedd82;">no_state</span> = implementation-defined
};
<span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">launch</span> : <span style="color: #98fb98;">unspecified</span> {
<span style="color: #eedd82;">async</span> = unspecified ,
<span style="color: #eedd82;">deferred</span> = unspecified ,
<span style="color: #eedd82;">implementation</span>-defined
};
<span style="color: #00ffff;">enum</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_status</span> {
<span style="color: #eedd82;">ready</span>,
<span style="color: #eedd82;">timeout</span>,
<span style="color: #eedd82;">deferred</span>
};
<span style="color: #00ffff;">template</span> &lt;&gt; <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">is_error_code_enum</span>&lt;<span style="color: #98fb98;">future_errc</span>&gt; : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">true_type</span> { };
<span style="color: #98fb98;">error_code</span> <span style="color: #87cefa;">make_error_code</span>(<span style="color: #98fb98;">future_errc</span> <span style="color: #eedd82;">e</span>) noexcept;
<span style="color: #98fb98;">error_condition</span> <span style="color: #87cefa;">make_error_condition</span>(<span style="color: #98fb98;">future_errc</span> <span style="color: #eedd82;">e</span>) noexcept;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">error_category</span>&amp; <span style="color: #87cefa;">future_category</span>() noexcept;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future_error</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">promise</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&amp;&gt;;
<span style="color: #00ffff;">template</span> &lt;&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">void</span>&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;&amp; <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;&amp; <span style="color: #eedd82;">y</span>) noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Alloc</span>&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uses_allocator</span>&lt;<span style="color: #98fb98;">promise</span>&lt;<span style="color: #98fb98;">R</span>&gt;, <span style="color: #98fb98;">Alloc</span>&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">R</span>&amp;&gt;;
<span style="color: #00ffff;">template</span> &lt;&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">future</span>&lt;<span style="color: #98fb98;">void</span>&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">shared_future</span>;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">shared_future</span>&lt;<span style="color: #98fb98;">R</span>&amp;&gt;;
<span style="color: #00ffff;">template</span> &lt;&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">shared_future</span>&lt;<span style="color: #98fb98;">void</span>&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span>&gt; <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">packaged_task</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">undefined</span>
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span>... ArgTypes&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">packaged_task</span>&lt;R(<span style="color: #eedd82;">ArgTypes</span>...)&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>&gt;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">packaged_task</span>&lt;R(ArgTypes...)&gt;&amp;, <span style="color: #98fb98;">packaged_task</span>&lt;R(ArgTypes...)&gt;&amp;) noexcept;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">R</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Alloc</span>&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uses_allocator</span>&lt;<span style="color: #98fb98;">packaged_task</span>&lt;<span style="color: #98fb98;">R</span>&gt;, <span style="color: #98fb98;">Alloc</span>&gt;;
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span>... Args&gt;
<span style="color: #98fb98;">future</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">result_of</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;<span style="color: #98fb98;">F</span>&gt;::<span style="color: #98fb98;">type</span>(<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;Args&gt;::<span style="color: #98fb98;">type</span>...)&gt;::<span style="color: #98fb98;">type</span>&gt;
<span style="color: #87cefa;">async</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args);
<span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span>... Args&gt;
<span style="color: #98fb98;">future</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">result_of</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;<span style="color: #98fb98;">F</span>&gt;::<span style="color: #98fb98;">type</span>(<span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">decay</span>&lt;Args&gt;::<span style="color: #98fb98;">type</span>...)&gt;::<span style="color: #98fb98;">type</span>&gt;
<span style="color: #87cefa;">async</span>(<span style="color: #98fb98;">launch</span> <span style="color: #eedd82;">policy</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, Args&amp;&amp;... args);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">其他资料</h2>
<div class="outline-text-2" id="text-8">
<p>
<a id="reference" name="reference"></a>
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Books</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>Scott Meyers的<a href="http://www.artima.com/shop/overview_of_the_new_cpp"> Overview of the New C++ (C++11/14)</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Online resources</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>Scott Meyers的<a href="http://www.aristeia.com/C++11/C++11FeatureAvailability.htm">Summary of C++11 Feature Availability in gcc and MSVC</a>
</li>
<li><a href="http://en.cppreference.com/w/cpp">C++11 on cppreference</a>
</li>
<li><a href="http://www.cplusplus.com/reference/multithreading/">C++11 on cplusplus</a>
</li>
<li>Bjarne Stroustrup的<a href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/C++11">C++11 Wiki</a>
</li>
<li><a href="https://github.com/cplusplus/draft">C++ standards drafts on GitHub</a>
</li>
<li><a href="http://en.cppreference.com/w/c/thread">C documentation</a> for Thread support library
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈C++ multithreading programming]]></title>
    <link href="http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/"/>
    <updated>2014-08-07T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
随着多核CPU随处可见,多线程(multithreading)可以被用来实现并行,提高CPU的利用率和性能显著的提高.掌握多线程编程也成为现代实现软件的基本要求技能之一.<a href="https://computing.llnl.gov/tutorials/parallel_comp/">Introduction to Parallel Computing</a>详细的介绍了 Parallel Computing;
为什么使用它;Parallel Computing的分类;Parallel Computing的limits和
costs; Parallel Computing的程序模型;如何设计Parallel程序等.
</p>

<p>
这里先介绍多线程的概念,多线程中涉及的基本概念,然后用实例介绍Pthread库的使用,并介绍Google Code中如何把它封装成C++类,最后介绍可移植并大量使用的
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread库</a>.
</p>

<p>
还有一些其他的Thread库:
</p>
<ul class="org-ul">
<li><a href="http://openmp.org/wp/">OpenMP</a> 是一个可移植的接口,在共享内存的多处理器上实现fork-join并行.
OpenMP的tutorial:<a href="https://computing.llnl.gov/tutorials/openMP/">这里</a> 和 <a href="http://vergil.chemistry.gatech.edu/resources/programming/OpenMP.pdf">这里</a>,
</li>
<li><a href="http://omniorb.sourceforge.net/omni42/omnithread.html">OMNI Thread</a>为C++提供Thread操作的.
</li>
<li><a href="http://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries">其他multithreading libraries</a>.
</li>
</ul>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Thread</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">定义</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A <b>thread</b> is defined as an independent stream of instructions that can
be scheduled to run as such by the operating system.所以它是在程序中独立于其他代码可由操作系统调度的一段指令.
</p>

<p>
那么是操作系统是如何具体实现这一独立性呢?
</p>

<p>
要理解thread,必须先明白process.进程由操作系统创建来运行相应的程序,进程包含程序资源和程序执行状态的信息.以Linux的进程为例包含:
</p>
<ul class="org-ul">
<li>Process ID, process group ID, user ID, and group ID
</li>
<li>Environment
</li>
<li>Working directory
</li>
<li>Program instructions
</li>
<li>Registers
</li>
<li>Stack
</li>
<li>Heap
</li>
<li>File descriptors
</li>
<li>Signal actions
</li>
<li>Shared libraries
</li>
<li>Inter-process communication tools (such as message queues, pipes,
semaphores, or shared memory).
</li>
</ul>

<img class="center" src="/images/blog/2014/c++_multithreaing/process_thread.png">

<p>
Thread使用Process的资源,并且能成为独立的元件被操作系统调度,是因为它仅重复那些使得它们能成为独立运行代码的必要资源.Thread维护它自己如下的信息:
</p>
<ul class="org-ul">
<li>Stack pointer
</li>
<li>Registers
</li>
<li>Scheduling properties (such as policy or priority)
</li>
<li>Set of pending and blocked signals
</li>
<li>Thread specific data.
</li>
</ul>

<p>
与Process比较,Thread可以总结如下:
</p>
<ul class="org-ul">
<li>Thread相当于一个lightweight的Process,拥有如ID,properties等相似信息,
但仅仅包含能使得它独立运行的信息即可.
</li>
<li>信息包含的不同,与需要复制大量信息来创建Process比,Thread的创建比较快捷.
</li>
<li>独立的Processes不共享任何信息.每个Process运行在独立的地址空间.Threads共享所在Process的资源,全局变量和文件描述符.
</li>
<li>Threads可以直接与所在同一Process的Threads通信.而Processes必须使用
inter-process communication(IPC)来通信.
</li>
<li>因为Threads的资源共享性,增加并行操作资源的难度,需要引入Thread同步机制来达到资源并行性.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">一些术语</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Posix Thread基本模型如下图,一些有关其中Thread的术语:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/threads_model.png">

<ul class="org-ul">
<li><b>Lightweight Process(LWP)</b> 可以被认为虚拟的CPU,在系统中通常LWP的个数大于实际CPU个数.Thread库通过与LWP沟通来调度thread.LWP也通常被称为
kernel threads.
</li>
<li><b><a href="http://en.wikipedia.org/wiki/System_Contention_Scope">Contention Scope</a></b> 是如何决定哪个线程得到调度.
</li>
<li><b>Bound threads</b> 拥有系统级别的Contention Scope,也就是,它们与其他进程一同竞争.
</li>
<li><b>Unbound threads</b> 拥有进程级别的Contention Scope.
</li>
<li><b>Thread-safe</b> 意味共享数据被得到保护,可以同时被多个thread调用而安全.
</li>
<li><b>Reentrant code</b> 意味程序可以被多个thread并行运行.
</li>
<li><b><a href="https://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions">asynchronous-safe function</a></b> 在signal handler下被安全调用并没有任何副作用.
</li>
<li><b>Concurrency vs. Parallelism</b> 并不一样.Parallelism意味同时运行代码.而
Concurrency意味许多任务可以以任何顺序执行或可以是并行运行.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Amdahl法则和Pareto原则</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Threads能提供益处 <i>对于相适</i> 的应用.所以thread的并行性对于应用来说也有它的限制.
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Amdahl法则</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
<a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl法则</a> 陈述到潜在的程序加速由能被并行的代码率P定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{1-P}
\end{align}
$$

<ul class="org-ul">
<li>如果代码中没有能并行的部分,P=0,那么speedup=1.
</li>
<li>如果所有代码都能并行,P=1,那么speedup能达到无限(理论上).
</li>
<li>如果50%的代码能并行,那么最大的speedup=2,也就是最多2倍的加速.
</li>
</ul>

<p>
引入能并行的处理器个数,那么进一步可以定义为:
</p>

$$
\begin{align}
speedup = \dfrac{1}{\dfrac{P}{N} + (1-P)}
其中P并行率,N处理器个数
\end{align}
$$

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl1.gif">

<img class="center" src="/images/blog/2014/c++_multithreaing/amdahl2.gif">
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Pareto原则</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
<a href="http://en.wikipedia.org/wiki/Pareto_principle">Pareto原则</a> 陈述到80%的处理器时间花在20%的代码中.所以仔细分析代码,不要把时间花在并行/优化那部分不重要的代码.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Thread设计模式<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-3">
<p>
在程序中有不同的方法使用线程,这里讨论3种线程设计模式,没有哪一种模式最好,每种模式都有相应适合的应用场合.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Boss/worker(Thread pool)</h3>
<div class="outline-text-3" id="text-3-1">
<img class="center" src="/images/blog/2014/c++_multithreaing/boss_workers_pattern.gif">

<p>
如上图,一个Boss线程创建其他Worker线程,并给它们分配任务,必要的话,并等待其他线程运行结束.通常Boss线程会在初始建立Thread Pool来为之后分配.尽管线程是轻量级的,但是创建它们仍是有开销的.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Peer(Workcrew)</h3>
<div class="outline-text-3" id="text-3-2">
<img class="center" src="/images/blog/2014/c++_multithreaing/peer_pattern.gif">

<p>
Peer模式又叫做workcrew模式,一个thread创建其他peer threads当程序开始,但是如上图,与Boss/worker模式不同,这个thread之后也变成peer thread去处理自己的任务.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Pipeline</h3>
<div class="outline-text-3" id="text-3-3">
<img class="center" src="/images/blog/2014/c++_multithreaing/pipeline_pattern.gif">

<p>
Pipeline模式假定:
</p>
<ul class="org-ul">
<li>一串连续长输入.
</li>
<li>每个输入经过一连串的子操作(熟知为stages或fliers).
</li>
<li>每个处理stage能一次处理个不同的输入.
</li>
</ul>

<p>
如上图, Pipeline就像流水线一般,每个thread是一个长链中的一部分.每个
thread处理由之前thread过的数据.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">线程同步原语</h2>
<div class="outline-text-2" id="text-4">
<p>
如上线程中的定义,线程们共享进程中的全局变量或资源,它们可以并行同时对这些数据和资源操作,如果没有一定的机制协调它们,那么数据或资源将处于一个不安全状态,引起诸如如下的一些问题:
</p>

<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/Race_condition#Software">Race condition</a>发生于不能决定行为的结果因为线程们操作共享数据或资源没有遵循一定的同步规则.
</li>
<li><a href="http://en.wikipedia.org/wiki/ABA_problem">ABA problem</a>发生于一个地方被读取两次,都读到相同的值,'值是相同的'被用来说明'没有东西被改变'.但是,另外一个线程能在这两次读取中间执行操作并修改这个位置的值,然后做一些其他操作,最后把这个值改回去,以致愚弄第一个线程让它认为'没有东西被改变',即使第二个线程的操作已经破坏了这个假设.
</li>
</ul>

<p>
所以我们需要如下的一些线程同步原语满足不同的线程间同步需求.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Mutex</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29">Mutex</a> 又被称为Lock,所以它就像一把Lock,一个线程Lock住一段资源,那么其他线程就不能去访问那段资源,只有等到第一个线程Unlock那么资源,它才能访问.
</p>

<p>
在Lock和Unlock之间的代码,一般被称为 <b>critical section</b>.
</p>

<p>
Mutex也包含一些复杂的类型,如下:
</p>
<ul class="org-ul">
<li>Recursive: 允许占有锁的那一个线程再次获取同样的锁,对递归算法是必要的.
</li>
<li>Queuing: 使得 <b>公平</b> 的获取锁,通过FIFO排序锁的请求.
</li>
<li>Reader/Writer(rwlock): 允许多个reader同时获取锁,如果有reader占用锁,writer只有等到reader释放锁.
</li>
<li>Scoped: <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> 类型定义的锁获取和解锁.
</li>
</ul>

<p>
但Mutex也会引入其他一些问题,如<a href="http://en.wikipedia.org/wiki/Deadlock">deadlock</a> 和 <a href="http://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>.
</p>

<p>
在Blog中之前<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/">浅谈Mutex (Lock)</a>中可以看到更多有关Mutex的性能和开销分析,并如何实现一个轻量级的Mutex.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Join</h3>
<div class="outline-text-3" id="text-4-2">
<p>
线程join机制能让一个线程join到另外一个线程中.比如一个子线程join回主线程,那么主线程就会等待子线程运行结束.从而达到线程间等待的同步机制.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Condition Variable</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Condition variable 允许线程同步到某个共享资源的某个值.
</p>

<p>
比如,程序有一个计数器,当计数器达到某一个值时去激活某个线程运行.把计数器当成一个Condition variable.这个线程可以等待这个Condition variable,其他active线程操作完这个Condition variable,可以通过signal/broadcast去唤醒那些等待这个Condition variable睡眠的线程.
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Barrier</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Barrier是一种能让一系列线程在某个点得到同步的方法,通过让参与barrier的线程等待直到所有参与线程都调用了这个barrier函数.本质上就是,阻塞所有参与barrier的线程直到最慢的那个参与线程调用barrier.
</p>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Spinlock</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Spinlock与mutex类似,是种锁,但当获取锁失败时,spinlock不会让线程进入睡眠,而是不断poll去获取这个锁直到获取成功.更多<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/#mutex-vs-spinlock">Mutex与Spinlock的区别</a>.
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Semaphore</h3>
<div class="outline-text-3" id="text-4-6">
<p>
当某些资源具有多个时,简单的Mutex不能满足,引入Semphore,Semphore可以根据资源个数初始化为任意值.当线程们占有所有资源,使得Semphore为0,那么其他线程再获取资源只有等待.当Semphore值只能是1或0时,它相当于简单的Mutex.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Pthread</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Overview</h3>
<div class="outline-text-3" id="text-5-1">
<p>
原始的Pthread API由ANSI/IEEE POSIX 1003.1 - 1995 standard定义.POSIX标准也随着时间不断改进.
</p>

<p>
接下来主要把Pthread API分成如下主要5部分:
</p>
<ol class="org-ol">
<li>Thread Management
</li>
<li>Mutex Variables
</li>
<li>Condition Variables
</li>
<li>Synchronization
</li>
<li>Miscellaneous
</li>
</ol>

<p>
如果想把Pthread封装成类对象或Scoped Lock,可以参考之后
<a href="#google-wrap">Google wrap the Pthread</a>,或直接使用之后介绍的<a href="#boost-thread">Boost thread library</a>.
</p>

<p>
如果更全面的API参考文章最后的<a href="#pthread-library">Pthread Library Routines Reference</a>.更多有关资料参考文章后的<i>其他资料</i>.
</p>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">编译Pthread程序</h4>
<div class="outline-text-4" id="text-5-1-1">
</div><div id="outline-container-sec-5-1-1-1" class="outline-5">
<h5 id="sec-5-1-1-1">include</h5>
<div class="outline-text-5" id="text-5-1-1-1">
<p>
对于POSIX系统,包含头文件 <code>pthread.h</code>. 如果使用 <code>semaphore</code>, 包含
<code>semaphore.h</code>.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;semaphore.h&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-1-2" class="outline-5">
<h5 id="sec-5-1-1-2">compile</h5>
<div class="outline-text-5" id="text-5-1-1-2">
<p>
对于Gcc编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">gcc Program.o -o Program -lpthread
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Thread Management</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Creating and Terminating Threads</h4>
<div class="outline-text-4" id="text-5-2-1">
</div><div id="outline-container-sec-5-2-1-1" class="outline-5">
<h5 id="sec-5-2-1-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_create</span>(<span style="color: #98fb98;">pthread_t</span> *<span style="color: #eedd82;">thread</span>,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> *(*<span style="color: #eedd82;">start_routine</span>)(<span style="color: #98fb98;">void</span>*), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pthread_exit</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cancel</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_init</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_destroy</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-2" class="outline-5">
<h5 id="sec-5-2-1-2">Creating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-2">
<p>
<code>pthread_create</code> 创建一个新的线程并运行它.它能在代码的任何处被多次调用.
</p>

<p>
<code>pthread_create</code> 的参数:
</p>
<ul class="org-ul">
<li><code>thread</code>:返回新thread程的唯一标识.
</li>
<li><code>attr</code>:设置thread的性质.NULL为默认性质.
</li>
<li><code>start_routine</code>: 新thread运行的函数指针.
</li>
<li><code>arg</code>:传给 <code>start_routine</code> 的参数,必须强制转换成 <code>void *</code>.NULL为没有参数传入.
</li>
</ul>

<p>
Process能创建的最大thread个数由系统配置决定.如下Ubuntu打印出的结果:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       8MB
coredumpsize    0kB
memoryuse       unlimited
maxproc         62694
descriptors     1024
memorylocked    64kB
addressspace    unlimited
maxfilelocks    unlimited
sigpending      62694
msgqueue        819200
nice            0
rt_priority     0
rt_time         unlimited
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-3" class="outline-5">
<h5 id="sec-5-2-1-3">Thread Attributes</h5>
<div class="outline-text-5" id="text-5-2-1-3">
<p>
<code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 被用来初始化/销毁thread
性质对象.
</p>

<p>
性质包括:
</p>
<ul class="org-ul">
<li>Detached or joinable state
</li>
<li>Scheduling inheritance
</li>
<li>Scheduling policy
</li>
<li>Scheduling parameters
</li>
<li>Scheduling contention scope
</li>
<li>Stack size
</li>
<li>Stack address
</li>
<li>Stack guard (overflow) size
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-1-4" class="outline-5">
<h5 id="sec-5-2-1-4">Thread Binding</h5>
<div class="outline-text-5" id="text-5-2-1-4">
<p>
Pthread APIs并没有提供binding threads到特定cpus/cores的接口.但不同系统可能包含这功能,比如提供非标准的<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt"><code>pthread_setaffinity_np</code> </a> 接口.
</p>

<p>
比如设置两个线程都在core0上运行,如下设置:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">cpu_set_t</span> <span style="color: #eedd82;">cpus</span>;
CPU_ZERO(&amp;cpus);
CPU_SET(0, &amp;cpus);
pthread_setaffinity_np(thread[0], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
pthread_setaffinity_np(thread[1], <span style="color: #00ffff;">sizeof</span>(cpu_set_t), &amp;cpus);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-1-5" class="outline-5">
<h5 id="sec-5-2-1-5">Terminating Threads</h5>
<div class="outline-text-5" id="text-5-2-1-5">
<p>
一个线程有很多种方法终止:
</p>
<ul class="org-ul">
<li>线程从它的运行中正常放回.它的工作完成.
</li>
<li>线程调用 <code>pthread_exit</code> 无论它的工作完成否.
</li>
<li>线程被另外一个线程调用 <code>pthread_cancel</code> 来取消.
</li>
<li>整个线程终止因为调用 <code>exec()</code> 或 <code>exit()</code>.
</li>
<li><code>main()</code> 函数先完成,没有调用 <code>pthread_exit</code>.
</li>
</ul>

<p>
<code>pthread_exit()</code> 允许指定一个可选的终止 <code>status parameter</code>.这个可选参数一般返回给线程"joining"到这个终止线程.
</p>

<p>
<code>pthread_exit()</code> 不关闭文件,在线程打开的任何文件将继续打开在线程终止后.
</p>

<p>
在 <code>main()</code> 调用 <code>pthread_exit()</code> :
</p>
<ul class="org-ul">
<li>如果 <code>main()</code> 在它创建的threads之前终止,并没有显示的调用
<code>pthread_exit()</code>,这将是个问题.所有创建的线程将终止因为main()结束,不再存在支持这些线程.
</li>
<li>通过main()在最后调用 <code>pthread_exit()</code>, main()将阻塞并保持存活来支持它创建的线程运行直到它们完成.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-1-6" class="outline-5">
<h5 id="sec-5-2-1-6">Example: Pthread Creation and Termination</h5>
<div class="outline-text-5" id="text-5-2-1-6">
<p>
如果注释掉main()中最后的 <code>pthread_exit(NULL);</code> ,那么它创建的线程将会完成不了所有的打印而被强制退出.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], <span style="color: #7fffd4;">NULL</span>, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Joining and Detaching Threads</h4>
<div class="outline-text-4" id="text-5-2-2">
</div><div id="outline-container-sec-5-2-2-1" class="outline-5">
<h5 id="sec-5-2-2-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_join</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>, <span style="color: #98fb98;">void</span> **<span style="color: #eedd82;">value_ptr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_detach</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setdetachstate</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">detachstate</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getdetachstate</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">detachstate</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-2-2" class="outline-5">
<h5 id="sec-5-2-2-2">Joining</h5>
<div class="outline-text-5" id="text-5-2-2-2">
<p>
Joining是同步不同线程的方法之一,原理如下图:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/join.png">

<ul class="org-ul">
<li><code>pthread_join()</code> 阻塞调用它的线程直到指定的 <code>threadid</code> 的线程终止.
</li>
<li>调用的线程能获取目标线程终止返回的 <code>status</code> 只要目标线程调用
  <code>pthread_exit()</code>.
</li>
<li>当一个线程被创建,它的属性之一是它是否可以join.只有创建的能被join的线程才能被join.如果线程线程以detached创建,它永远都不能被join.
</li>
<li>显示的创建一个线程可join或detached,使用在 <code>pthread_create()</code> 中的 <code>attr</code>
参数.典型的步骤是:
<ol class="org-ol">
<li>定义 <code>pthread_attr_t</code> 类型的pthread属性;
</li>
<li>用 <code>pthread_attr_init()</code> 初始化属性变量;
</li>
<li>用 <code>pthread_attr_setdetachstate()</code> 设置detached属性;
</li>
<li>用 <code>pthread_attr_destroy()</code> 释放属性使用的资源.
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-3" class="outline-5">
<h5 id="sec-5-2-2-3">Detaching</h5>
<div class="outline-text-5" id="text-5-2-2-3">
<ul class="org-ul">
<li><code>pthread_detach()</code> 能显示的detach一个线程即使它是以可join创建.
</li>
<li>没有相反的操作.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2-2-4" class="outline-5">
<h5 id="sec-5-2-2-4">Example: Pthread Joining</h5>
<div class="outline-text-5" id="text-5-2-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(param);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_join(threads[i], &amp;status);
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_join failed, rt=%d\n"</span>, rt);
      exit(1);
    }
    printf(<span style="color: #ffa07a;">"completed join with thread %d having a status of %d\n"</span>
           , i, *<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(status));
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3">Stack Management</h4>
<div class="outline-text-4" id="text-5-2-3">
</div><div id="outline-container-sec-5-2-3-1" class="outline-5">
<h5 id="sec-5-2-3-1">APIs</h5>
<div class="outline-text-5" id="text-5-2-3-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstacksize</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">size_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstacksize</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stacksize</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstackaddr</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>,
              <span style="color: #98fb98;">void</span> **<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">stackaddr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstackaddr</span>(<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">stackaddr</span>);
</pre>
</div>

<p>
每个线程都有各自独立的stack, <code>pthread_attr_getstackaddr</code> 和
<code>pthread_attr_setstackaddr</code> 分别获取和设置线程的stack属性.
</p>
</div>
</div>

<div id="outline-container-sec-5-2-3-2" class="outline-5">
<h5 id="sec-5-2-3-2">Example: Stack Management</h5>
<div class="outline-text-5" id="text-5-2-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">thread_stack_size</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_attr_getstacksize(&amp;attr, &amp;thread_stack_size);
  printf(<span style="color: #ffa07a;">"thread %d: stack size = %d\n"</span>, id, thread_stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
    printf(<span style="color: #ffa07a;">"thread %d: run %d \n"</span>, id, i);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kThround</span> = 1000;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stack_size</span>;

  pthread_attr_init(&amp;attr);
  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);
  printf(<span style="color: #ffa07a;">"Default stack size = %d\n"</span>, stack_size);
  stack_size = <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">double</span>) * kThround * kThround;
  printf(<span style="color: #ffa07a;">"Setting stack size = %d\n"</span>, stack_size);
  pthread_attr_setstacksize(&amp;attr, stack_size);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  pthread_attr_destroy(&amp;attr);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-4" class="outline-4">
<h4 id="sec-5-2-4">Miscellaneous</h4>
<div class="outline-text-4" id="text-5-2-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #87cefa;">pthread_self</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_equal</span>(<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t1</span>, <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">t2</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_once</span>(<span style="color: #98fb98;">pthread_once_t</span> *<span style="color: #eedd82;">once_control</span>,
              <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">init_routine</span>)(<span style="color: #98fb98;">void</span>));
<span style="color: #98fb98;">pthread_once_t</span> <span style="color: #eedd82;">once_control</span> = PTHREAD_ONCE_INIT;
</pre>
</div>

<ul class="org-ul">
<li><code>pthread_self</code> 返回调用线程的唯一thread ID.
</li>
<li><code>pthread_equal</code> 比较两个线程ID是否相等.
</li>
<li><code>pthread_once</code> 只执行 <code>init_routine</code> 仅仅一次在进程中.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">Overview</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Mutex以"mutual exclusion"(互斥)简称.
</p>

<p>
Mutex variable就像一把"锁"一样保护共享数据资源.mutex的基本概念就是,只有一个线程能lock一个mutex变量在任何时候.所以,即使很多线程尝试去锁一个
mute,也仅仅只有一个线程能成功.
</p>

<p>
典型使用mutex的顺序如下:
</p>
<ol class="org-ol">
<li>创建和初始化mutex变量;
</li>
<li>许多线程尝试锁住mutex;
</li>
<li>只有一个线程成功锁住mutex,其他线程等待;
</li>
<li>拥有mutex的线程进行自己的操作;
</li>
<li>拥有线程解锁mutex;
</li>
<li>其他线程继续获取mutex并持续如上步骤;
</li>
<li>最后mutex销毁.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">Creating and Destroying Mutexes</h4>
<div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_destroy</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_init</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">mutex</span>,
          <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_destroy</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutexattr_init</span>(<span style="color: #98fb98;">pthread_mutexattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Mutex变量由 <code>pthread_mutex_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex</span> = PTHREAD_MUTEX_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_mutex_init()</code> 函数,并能设置mutex的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置mutex变量的属性,必须是 <code>pthread_mutexattr_t</code> 类型.Pthread标准中定义的3种可选mutex属性:
</p>

<ul class="org-ul">
<li>Protocol: Specifies the protocol used to prevent priority inversions
for a mutex.
</li>
<li>Prioceiling: Specifies the priority ceiling of a mutex.
</li>
<li>Process-shared: Specifies the process sharing of a mutex.(Pthread
mutex能被process间使用).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3">Locking and Unlocking Mutexes</h4>
<div class="outline-text-4" id="text-5-3-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_lock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_trylock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_mutex_unlock</span>(<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
</pre>
</div>

<p>
<code>pthread_mutex_lock()</code> 函数被用来获取传入的mutex变量,如果mutex已经被其他线程占用,那么这个调用就阻塞调用线程,使它进入睡眠等待这个mutex直到它被释放.
</p>

<p>
<code>pthread_mutex_trylock()</code> 仅尝试获取锁,若不成功也立即返回'busy'信号.
</p>
</div>
</div>
<div id="outline-container-sec-5-3-4" class="outline-4">
<h4 id="sec-5-3-4">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-5-3-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ThreadData</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tid</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">data</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">shared_x</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">lock</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ThreadProc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">ThreadData</span> *<span style="color: #eedd82;">data</span> = <span style="color: #00ffff;">static_cast</span>&lt;ThreadData *&gt;(param);
  printf(<span style="color: #ffa07a;">"begin from thread id: %d\n"</span>, data-&gt;tid);
  pthread_mutex_lock(&amp;lock);
  shared_x += data-&gt;data;
  printf(<span style="color: #ffa07a;">"thread %d: x = %d\n"</span>, data-&gt;tid, shared_x);
  pthread_mutex_unlock(&amp;lock);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 4;
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">ThreadData</span> <span style="color: #eedd82;">threads_data</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  shared_x = 0;
  pthread_mutex_init(&amp;lock, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    threads_data[i].tid = i;
    threads_data[i].data = i * i;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span> = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;threads_data[i]));
    <span style="color: #00ffff;">if</span> (rt) {
      printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
      exit(1);
    }
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">status</span>;
    pthread_join(threads[i], &amp;status);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Condition Variables</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Overview</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Mutex 变量如锁一般防止多个线程访问共享数据资源,如果某个线程等待某个共享数据达到某个数值才进行相应的操作,那么这个线程需要不断的去poll,查看是否满足需要的值,这样开销很大,因为线程需要一直处于忙状态.
</p>

<p>
引入Condition Variables来完成这样的同步到某个实际数据值而不要不断poll.
</p>

<p>
Condition变量一般与mutex一起使用.锁住查看的共享数据资源.
</p>

<p>
使用Condition的一般步骤如下:
</p>
<ul class="org-ul">
<li>声明和定义需要同步的共享数据;
</li>
<li>声明和定义condition变量;
</li>
<li>声明和定义相对应的mutex;
</li>
<li>创建线程使用condition变量同步.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Creating and Destroying Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_destroy</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_init</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">cond</span>,
                      <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #00ffff;">restrict</span> <span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_destroy</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_init</span>(<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);
</pre>
</div>

<p>
Condition变量由 <code>pthread_cond_t</code> 声明定义,而且必须初始化在使用前.两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">convar</span> = PTHREAD_COND_INITIALIZER;
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_cond_init()</code> 函数,并能设置condition的属性 <code>attr</code>.
</li>
</ol>

<p>
<code>attr</code> 用来设置condition变量的属性,必须是 <code>pthread_condattr_t</code> 类型.只有一种属性可选:是否进程共享,也就是允许其他进程中的线程也能看到它.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Waiting and Signaling on Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_wait</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,
                      <span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_signal</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_broadcast</span>(<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);
</pre>
</div>

<p>
<code>pthread_cond_wait()</code> 阻塞调用它的线程直到其中 <code>cond</code> 被signal.这个函数需要在占有 <i>mutex</i> 时被调用,而它将 <b>自动释放</b> mutex当它等待时.等到
signal收到,线程被唤醒, <i>mutex</i> 将 <b>自动被占有</b> .最后当线程完成
condition的操作,要负责对mutex解锁.
</p>

<p>
<code>pthread_cond_signal()</code> 用来signal其他等待这个 <code>cond</code> 的线程.它需要在占有 <i>mutex</i> 时被调用.然后必须对mutex解锁来完成 <code>pthread_cond_wait</code>
的等待.
</p>

<p>
如果有多余一个线程处于等待 <code>cond</code> 而阻塞, 应该用
<code>pthread_cond_broadcast()</code> 替换 <code>pthread_cond_signal()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-5-4-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdio&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumThreads</span> = 3;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kLoops</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kCountLimit</span> = 15;

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g_count</span>;
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">count_cv</span>;

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">IncreaseCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kLoops; ++i) {
    pthread_mutex_lock(&amp;count_mutex);
    g_count++;
    <span style="color: #00ffff;">if</span> (g_count == kCountLimit) {
      pthread_cond_signal(&amp;count_cv);
      printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, signal cond\n"</span>, id, g_count);
    }
    printf(<span style="color: #ffa07a;">"increse thread %d: count = %d, unlock mutex\n"</span>, id, g_count);
    pthread_mutex_unlock(&amp;count_mutex);
    sleep(1);
  }
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">WatchCount</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">param</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>;
  id = *(<span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">int</span> *&gt;(param));
  pthread_mutex_lock(&amp;count_mutex);
  <span style="color: #00ffff;">while</span> (g_count &lt; kCountLimit) {
    pthread_cond_wait(&amp;count_cv, &amp;count_mutex);
    printf(<span style="color: #ffa07a;">"watch thread %d: count = %d, receive signal\n"</span>, id, g_count);
  }
  pthread_mutex_unlock(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[kNumThreads];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">thread_ids</span>[kNumThreads];
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">attr</span>;

  pthread_mutex_init(&amp;count_mutex, <span style="color: #7fffd4;">NULL</span>);
  pthread_cond_init(&amp;count_cv, <span style="color: #7fffd4;">NULL</span>);
  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">rt</span>;
  rt = pthread_create(&amp;threads[0], &amp;attr, WatchCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[0]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[1], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[1]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  rt = pthread_create(&amp;threads[2], &amp;attr, IncreaseCount,
                            <span style="color: #00ffff;">static_cast</span>&lt;<span style="color: #98fb98;">void</span> *&gt;(&amp;thread_ids[2]));
  <span style="color: #00ffff;">if</span> (rt) {
    printf(<span style="color: #ffa07a;">"ERROR: pthread_create failed, rt=%d\n"</span>, rt);
    exit(1);
  }
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kNumThreads; ++i) {
    pthread_join(threads[i], <span style="color: #7fffd4;">NULL</span>);
  }
  pthread_attr_destroy(&amp;attr);
  pthread_cond_destroy(&amp;count_cv);
  pthread_mutex_destroy(&amp;count_mutex);
  pthread_exit(<span style="color: #7fffd4;">NULL</span>);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Barrier</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Overview</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Barrier就是栅栏一样,调用等待barrier的线程需要等待直到满足调用barrier的线程个数达到要求的 <code>count</code>.
</p>
</div>
</div>

<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">Creating, Destroying and Wait Barrier</h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_init</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>,
                <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_destroy</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_init</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrierattr_destroy</span>(<span style="color: #98fb98;">pthread_barrierattr_t</span> *<span style="color: #eedd82;">attr</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_barrier_wait</span>(<span style="color: #98fb98;">pthread_barrier_t</span> *<span style="color: #eedd82;">barrier</span>);
</pre>
</div>

<p>
Barrier变量由 <code>pthread_barrier_t</code> 声明定义,而且必须初始化在使用前.需要传入满足barrier等待的个数 <code>count</code>, 两种方法初始:
</p>
<ol class="org-ol">
<li>静态的,当声明时.如:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_barrier_t</span> <span style="color: #eedd82;">barrier</span> = PTHREAD_BARRIER_INITIALIZER(count);
</pre>
</div>
<ol class="org-ol">
<li>动态的,使用 <code>pthread_barrier_init()</code> 函数,并能设置barrier的属性 <code>attr</code>.
</li>
</ol>

<p>
线程调用barrier,只需要调用 <code>pthread_barrier_wait</code> 来等待barrier达到满足条件.
</p>

<p>
<a id="google-wrap" name="google-wrap"></a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Google wrap the Pthread</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Mutex类和CondVar类</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Google api的base包里封装了Mutex类和CondVar类.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">base</span> {
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">LinkerInitialized</span> { <span style="color: #eedd82;">LINKER_INITIALIZED</span> };
}

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LOCKABLE</span> <span style="color: #eedd82;">PThreadMutex</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #eedd82;">PThreadMutex</span>(<span style="color: #7fffd4;">base</span>::LinkerInitialized) {
    pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>);
  }
  <span style="color: #eedd82;">PThreadMutex</span>()   { pthread_mutex_init(&amp;mutex_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #eedd82;">PThreadMutex</span>()  { pthread_mutex_destroy(&amp;mutex_); }

  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Lock</span>()     { CHECK_EQ(0, pthread_mutex_lock(&amp;mutex_)); }
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Unlock</span>()   { CHECK_EQ(0, pthread_mutex_unlock(&amp;mutex_)); }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #00ffff;">friend</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span>;
  <span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">mutex_</span>;

  DISALLOW_COPY_AND_ASSIGN(PThreadMutex);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PThreadCondVar</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">PThreadCondVar</span>()  { pthread_cond_init(&amp;cv_, <span style="color: #7fffd4;">NULL</span>); }
  ~<span style="color: #87cefa;">PThreadCondVar</span>() { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_destroy</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Signal</span>()        { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_signal</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SignalAll</span>()     { CHECK_EQ(0, <span style="color: #98fb98;">pthread_cond_broadcast</span>(&amp;<span style="color: #eedd82;">cv_</span>)); }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Wait</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>) {
    CHECK_EQ(0, pthread_cond_wait(&amp;cv_, &amp;mu-&gt;mutex_));
  }
  <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">WaitWithTimeout</span>(<span style="color: #98fb98;">PThreadMutex</span>* <span style="color: #eedd82;">mu</span>, <span style="color: #98fb98;">int64</span> <span style="color: #eedd82;">millis</span>) {
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> <span style="color: #eedd82;">tv</span>;
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> <span style="color: #eedd82;">ts</span>;
    gettimeofday(&amp;tv, <span style="color: #7fffd4;">NULL</span>);
    ts.tv_sec = tv.tv_sec + millis / 1000;
    ts.tv_nsec = millis % 1000;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">result</span> = pthread_cond_timedwait(&amp;cv_, &amp;mu-&gt;mutex_, &amp;ts);
    <span style="color: #00ffff;">if</span> (!result) <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

    CHECK_EQ(ETIMEDOUT, result);
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }

 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">cv_</span>;
  DISALLOW_COPY_AND_ASSIGN(<span style="color: #98fb98;">PThreadCondVar</span>);
};

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadCondVar</span> <span style="color: #98fb98;">CondVar</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">PThreadMutex</span> <span style="color: #98fb98;">Mutex</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">GoogleOnceInit类</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pthread_once_t</span> <span style="color: #98fb98;">GoogleOnceType</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">GOOGLE_ONCE_INIT</span> PTHREAD_ONCE_INIT

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">GoogleOnceInit</span>(<span style="color: #98fb98;">GoogleOnceType</span>* <span style="color: #eedd82;">once</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">initializer</span>)()) {
  CHECK_EQ(0, pthread_once(once, initializer));
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Monitoring, Debugging and Performance Analysis Tools for Pthreads</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Monitoring</h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1">Linux <b>ps</b> command</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
使用Linux自带的 <code>ps</code> 命令查看运行的thread情况,<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?ps">ps的man手册</a>.
</p>
<div class="org-src-container">

<pre class="src src-sh">&#10140;$ ps -Lf
UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
shougang 13103  8814 13103  0    1 23:30 pts/17   00:00:00 /bin/zsh
shougang 13237 13103 13237  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13240  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13241  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13242  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13243  0    6 23:30 pts/17   00:00:00 [thread]
shougang 13237 13103 13244  0    6 23:30 pts/17   00:00:00 [thread]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2">Linux <b>top</b> command</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Linux的 <code>top</code> 命令加上 <code>-H</code> 参数, process中的threads也能看到.
如下是 <code>top -H</code> 的一个例子:
</p>

<img class="center" src="/images/blog/2014/c++_multithreaing/top.png">
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Debugging</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">GDB</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Threads.html#Threads">Debugging Programs with Multiple Threads</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/Thread-Stops.html#Thread-Stops">GDB: Stopping and starting multi-thread programs</a>
</li>
<li><a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb/GDB_002fMI-Thread-Commands.html#GDB_002fMI-Thread-Commands">GDB/MI: Threads commands</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2">DDD</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li><a href="http://www.gnu.org/software/ddd/manual/html_mono/ddd.html#Threads">Examining Threads</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Performance Analysis Tools<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li><a href="http://www.openspeedshop.org/wp/">Open|SpeedShop</a>
</li>
<li><a href="http://www.cs.uoregon.edu/research/tau/home.php">TAU</a>
</li>
<li><a href="https://software.intel.com/en-us/intel-advisor-xe">Intel Advisor</a>
</li>
</ul>

<p>
<a id="boost-thread" name="boost-thread"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Boost thread library</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Overview</h3>
<div class="outline-text-3" id="text-8-1">
<p>
直到C++11库才比较好的支持thread,之前C++程序使用操作系统支持的thread库(如
Pthread).但这样做至少有个主要的问题:(1) 这些库基本是C的库,需要很小心的
C++中使用,和(2) 每个操作系统提供自己的一套对thread支持的库.以致,编写的代码既不标准又不可移植.
</p>

<p>
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html">Boost Thread</a>可以解决这两个主要问题. Boost Thread不是通过继承来使用线程,而是Boost的thread类使用一个Callable的对象创建.
</p>
</div>

<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1">编译Boost Thread程序</h4>
<div class="outline-text-4" id="text-8-1-1">
</div><div id="outline-container-sec-8-1-1-1" class="outline-5">
<h5 id="sec-8-1-1-1">include</h5>
<div class="outline-text-5" id="text-8-1-1-1">
<p>
根据使用到的Boost Thread中的类型包含不同头文件:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/locks.hpp&gt;</span> 
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-1-1-2" class="outline-5">
<h5 id="sec-8-1-1-2">compile</h5>
<div class="outline-text-5" id="text-8-1-1-2">
<p>
对于Gcc编译器,使用选项 <code>-l</code>,如下:
</p>
<div class="org-src-container">

<pre class="src src-sh">g++ Program.o -o Program -lboost_thread -lboost_system
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Thread Management</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">Thread类</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">  #include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread</span>
  {
  <span style="color: #00ffff;">public</span>:
      <span style="color: #87cefa;">thread</span>() noexcept;
      <span style="color: #87cefa;">thread</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread</span>&amp;) = <span style="color: #00ffff;">delete</span>;

      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      <span style="color: #98fb98;">thread</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">thread</span>&amp;&amp;) noexcept;
      ~<span style="color: #87cefa;">thread</span>();

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A1</span>,<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">A2</span>,...&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>,<span style="color: #98fb98;">A1</span> <span style="color: #eedd82;">a1</span>,<span style="color: #98fb98;">A2</span> <span style="color: #eedd82;">a2</span>,...);
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);

      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> <span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>&gt;
      <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span> &amp;&amp;<span style="color: #eedd82;">f</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
      <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">F</span>, <span style="color: #00ffff;">class</span> ...Args&gt;
      <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">thread</span>(<span style="color: #98fb98;">attributes</span>&amp; <span style="color: #eedd82;">attrs</span>, <span style="color: #98fb98;">F</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">Args</span>&amp;&amp;... args);
      <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">id</span>;
      <span style="color: #98fb98;">id</span> <span style="color: #87cefa;">get_id</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;

      <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">joinable</span>() <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">noexcept</span>;
      <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join</span>();
...
};
</pre>
</div>

<p>
整个thread类包含thread的所有特性,如thread id, join, detach等.
</p>
</div>
<div id="outline-container-sec-8-2-1-1" class="outline-5">
<h5 id="sec-8-2-1-1">Create Thread</h5>
<div class="outline-text-5" id="text-8-2-1-1">
<p>
Callable对象既可以是一个函数又可以是类中的 <code>operator()</code> 实现,如下:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>() {
  cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Hello</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    cout &lt;&lt; <span style="color: #ffa07a;">"hello world"</span> &lt;&lt; endl;
  }
};

<span style="color: #98fb98;">Hello</span> <span style="color: #eedd82;">h</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(h);
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thread_hello</span>(hello);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-1-2" class="outline-5">
<h5 id="sec-8-2-1-2">Passing data</h5>
<div class="outline-text-5" id="text-8-2-1-2">
<p>
传递参数给线程
</p>
<ol class="org-ol">
<li>thread创建时附加后面
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(hello, str);
</pre>
</div>
<ol class="org-ol">
<li>利用 <code>Boost.bind</code> 库接口
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #87cefa;">thrd</span>(bind(hello, str));
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">Thread group类</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
可以使用thread group类管理thread,通过 <code>add_thread</code> 和 <code>create_thread</code>
添加线程到管理类中, 可以直接 <code>join_all</code> 将所有管理类中的线程join.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">thread_group</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">thread_group</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">thread_group</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">thread_group</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">thread_group</span>();
    ~<span style="color: #87cefa;">thread_group</span>();

    <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #98fb98;">thread</span>* <span style="color: #87cefa;">create_thread</span>(<span style="color: #98fb98;">F</span> <span style="color: #eedd82;">threadfunc</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">add_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove_thread</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_this_thread_in</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">is_thread_in</span>(<span style="color: #98fb98;">thread</span>* <span style="color: #eedd82;">thrd</span>);
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">join_all</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interrupt_all</span>();
    <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">size</span>() <span style="color: #00ffff;">const</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">Miscellaneous</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Boost Thread中还有 <code>strict_scoped_thread</code> 类和 <code>scoped_thread</code> 类,提供线程结束不是调用 <code>terminate</code> ,而是调用传入的参数来执行特定行为.
</p>
</div>
</div>
<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4">Example: Thread Creation</h4>
<div class="outline-text-4" id="text-8-2-4">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/bind.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">std</span>;
<span style="color: #00ffff;">using</span> <span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hello</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;<span style="color: #eedd82;">str</span>) {
  cout &lt;&lt; str &lt;&lt; endl;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(){
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">str</span> = <span style="color: #ffa07a;">"hello"</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thrd</span>(bind(hello, str));
  thrd.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-8-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">mutex</span>:
    <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">noncopyable</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">mutex</span>();
    ~<span style="color: #87cefa;">mutex</span>();

    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">lock</span>();
    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_lock</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unlock</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">platform</span>-specific-type native_handle_type;
    <span style="color: #98fb98;">native_handle_type</span> <span style="color: #87cefa;">native_handle</span>();

    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #98fb98;">scoped_lock</span>;
    <span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unspecified</span>-type scoped_try_lock;
};
</pre>
</div>

<ul class="org-ul">
<li><code>lock()</code> 来获取锁.
</li>
<li><code>unlock()</code> 释放锁.
</li>
<li><code>typedef unique_lock&lt;mutex&gt; scoped_lock;</code> 定义了 <code>scoped_lock</code> 的类型,通过 <code>boost::mutex::scoped_lock</code> 来定义一个RAII-style锁,离开定义区域自动释放锁.
</li>
</ul>
</div>

<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><code>lock_guard</code></h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
<code>boost::lock_guard</code> 非常简单:
</p>
<ul class="org-ul">
<li>构造时,它获取锁.
</li>
<li>析构时,它释放锁.
</li>
</ul>

<p>
它提供了一个简单的RAII-style锁对象,使得exception-safe锁和解锁更容易.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">lock_guard</span>
<span style="color: #b0c4de;">#if</span> ! <span style="color: #b0c4de;">defined</span> BOOST_THREAD_NO_MAKE_LOCK_GUARD
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
  <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Lockable</span>&gt;
  <span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">Lockable</span>&gt; <span style="color: #87cefa;">make_lock_guard</span>(<span style="color: #98fb98;">Lockable</span>&amp; <span style="color: #eedd82;">mtx</span>, <span style="color: #98fb98;">adopt_lock_t</span>); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">EXTENSION</span>
<span style="color: #b0c4de;">#endif</span>
}
</pre>
</div>

<p>
基本使用,传入可 <code>Lockable</code> 的mutex类型:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">lock_guard</span>&lt;<span style="color: #98fb98;">mutex</span>&gt; <span style="color: #87cefa;">lock</span>(count_mutex) ;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2">Example: Using Mutexes</h4>
<div class="outline-text-4" id="text-8-3-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>

<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">count_mutex</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">count</span> {
  <span style="color: #87cefa;">count</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id</span>) : id_(id) {
  }
  <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">()</span> () {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10; ++i) {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(count_mutex);
      cout &lt;&lt; id_ &lt;&lt; <span style="color: #ffa07a;">": "</span> &lt;&lt; i &lt;&lt; endl;
    }
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">id_</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread1</span>(count(1));
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">thread</span> <span style="color: #eedd82;">thread2</span>(count(2));
  thread1.join();
  thread2.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Condition Variables</h3>
<div class="outline-text-3" id="text-8-4">
<p>
与Pthread, Boost Condition Variable功能更全面,如不同条件的
<code>wait_until</code> , <code>wait_for</code> 等功能.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
    <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">condition_variable</span>
    {
    <span style="color: #00ffff;">public</span>:
        <span style="color: #87cefa;">condition_variable</span>();
        ~<span style="color: #87cefa;">condition_variable</span>();

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_one</span>() noexcept;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">notify_all</span>() noexcept;

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>);

        <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">predicate_type</span>&gt;
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait</span>(<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">unique_lock</span>&lt;<span style="color: #7fffd4;">boost</span>::mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,<span style="color: #eedd82;">predicate_type</span> predicate);

        <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Clock</span>, <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Duration</span>&gt;
        <span style="color: #00ffff;">typename</span> <span style="color: #7fffd4;">cv_status</span>::<span style="color: #98fb98;">type</span>
        <span style="color: #87cefa;">wait_until</span>(
            <span style="color: #98fb98;">unique_lock</span>&lt;mutex&gt;&amp; <span style="color: #eedd82;">lock</span>,
            <span style="color: #00ffff;">const</span> <span style="color: #7fffd4;">chrono</span>::<span style="color: #98fb98;">time_point</span>&lt;<span style="color: #98fb98;">Clock</span>, <span style="color: #98fb98;">Duration</span>&gt;&amp; <span style="color: #eedd82;">t</span>);
...
};
</pre>
</div>
</div>

<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1">Example: Using Condition Variables</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
利用Condition Variables实现一个简单的read/writer Buffer.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/mutex.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/condition.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">cout</span>;
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">endl</span>;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kBufSize</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kIters</span> = 100;

<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">io_mutex</span>;

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Buffer</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">typedef</span> <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #98fb98;">scoped_lock</span>;
  <span style="color: #87cefa;">Buffer</span>() : p(0), c(0), full(0) {
  }

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Put</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>) {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == kBufSize) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is full."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == kBufSize) {
        cond.wait(lock);
      }
    }
    buf[p] = m;
    p = (p + 1) % kBufSize;
    ++full;
    cond.notify_one();
  }

  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">Get</span>() {
    <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(<span style="color: #98fb98;">mutex</span>);
    <span style="color: #00ffff;">if</span> (full == 0) {
      {
        <span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
        cout &lt;&lt; <span style="color: #ffa07a;">"Buffer is empty."</span> &lt;&lt; endl;
      }
      <span style="color: #00ffff;">while</span> (full == 0) {
        cond.wait(lock);
      }
    }
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = buf[c];
    c = (c + 1) % kBufSize;
    --full;
    cond.notify_one();
    <span style="color: #00ffff;">return</span> i;
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">mutex</span>;
  <span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">condition</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">full</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">buf</span>[kBufSize];
};

<span style="color: #98fb98;">Buffer</span> <span style="color: #eedd82;">buf</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writer</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"sending: "</span> &lt;&lt; i &lt;&lt; endl;
    }
    buf.Put(i);
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reader</span>() {
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kIters; ++i) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = buf.Get();
    {
      <span style="color: #7fffd4;">boost</span>::<span style="color: #7fffd4;">mutex</span>::<span style="color: #98fb98;">scoped_lock</span> <span style="color: #eedd82;">lock</span>(io_mutex);
      cout &lt;&lt; <span style="color: #ffa07a;">"received: "</span> &lt;&lt; n &lt;&lt; endl;
    }
  }
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) {
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_reader</span>(&amp;<span style="color: #eedd82;">reader</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thread_writer</span>(&amp;<span style="color: #eedd82;">writer</span>);
  thread_reader.join();
  thread_writer.join();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Miscellaneous</h3>
<div class="outline-text-3" id="text-8-5">
</div><div id="outline-container-sec-8-5-1" class="outline-4">
<h4 id="sec-8-5-1">Barrier</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
基本使用:
</p>
<ol class="org-ol">
<li>定义barrier,传入参与thread个数: <code>barrier b(num_threads)</code>.
</li>
<li>thread中等待barrier: <code>b.wait()</code>.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">barrier</span>
{
<span style="color: #00ffff;">public</span>:
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;
    <span style="color: #98fb98;">barrier</span>&amp; <span style="color: #00ffff;">operator</span><span style="color: #87cefa;">=</span>(<span style="color: #98fb98;">barrier</span> <span style="color: #00ffff;">const</span>&amp;) = <span style="color: #00ffff;">delete</span>;

    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>);
    <span style="color: #00ffff;">template</span> &lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">F</span>&gt;
    <span style="color: #87cefa;">barrier</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">F</span>&amp;&amp;);

    ~<span style="color: #87cefa;">barrier</span>();

    <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">wait</span>();
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">count_down_and_wait</span>();
};
</pre>
</div>


<p>
<a id="other-materials" name="other-materials"></a>
</p>
</div>
</div>

<div id="outline-container-sec-8-5-2" class="outline-4">
<h4 id="sec-8-5-2">Once Routines</h4>
<div class="outline-text-4" id="text-8-5-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>

<span style="color: #00ffff;">namespace</span> <span style="color: #7fffd4;">boost</span>
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">once_flag</span>;
  <span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">Function</span>, <span style="color: #00ffff;">class</span> ...ArgTypes&gt;
  <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>, <span style="color: #98fb98;">Function</span>&amp;&amp; <span style="color: #eedd82;">f</span>, <span style="color: #98fb98;">ArgTypes</span>&amp;&amp;... args);

<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span> BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">call_once</span>(<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">func</span>)(),<span style="color: #98fb98;">once_flag</span>&amp; <span style="color: #eedd82;">flag</span>);
<span style="color: #b0c4de;">#endif</span>

}
</pre>
</div>
</div>
<div id="outline-container-sec-8-5-2-1" class="outline-5">
<h5 id="sec-8-5-2-1">Example: Call once</h5>
<div class="outline-text-5" id="text-8-5-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/thread.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;boost/thread/once.hpp&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
<span style="color: #7fffd4;">boost</span>::<span style="color: #98fb98;">once_flag</span> <span style="color: #eedd82;">flag</span> = BOOST_ONCE_INIT;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">init</span>()
{
  ++i;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">thread</span>()
{
  <span style="color: #7fffd4;">boost</span>::call_once(&amp;init, flag);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd1</span>(&amp;<span style="color: #eedd82;">thread</span>);
  <span style="color: #7fffd4;">boost</span>::thread <span style="color: #98fb98;">thrd2</span>(&amp;<span style="color: #eedd82;">thread</span>);
  thrd1.join();
  thrd2.join();
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; i &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">其他资料</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Books:</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li><a href="http://shop.oreilly.com/product/9781565921153.do">PThreads Programming</a> and <a href="http://wiki.dreamrunner.org/public_html/Books%20Review/Pthreads%20Programming/Pthreads%20Programming.html">Its notes</a>
</li>
<li><a href="http://www.justsoftwaresolutions.co.uk/blog/">Anthony Williams’ blog</a> and his book, <a href="http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&amp;tag=preshonprogr-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988770">C++ Concurrency in Action</a>
</li>
<li>Herlihy &amp; Shavit's <i>The Art of Multiprocessor Programming</i>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Online resources:</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li><i>Dmitriy V’jukov’s website</i> and various <a href="https://groups.google.com/forum/?fromgroups#!forum/lock-free">forum discussions</a>
</li>
<li><a href="http://bartoszmilewski.com/">Bartosz Milewski’s blog</a>
</li>
<li>Charles Bloom’s <a href="http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html">Threading Posts</a> on his blog
</li>
<li>Doug Lea's <a href="http://g.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a>
</li>
<li><a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">memory-barriers.txt document</a>
</li>
<li>Hans Boehm’s <a href="http://www.hboehm.info/c++mm/">collection of links about the C++11 memory model</a>
</li>
<li>Scott Meyers's <a href="http://scottmeyers.blogspot.hk/2012/04/information-on-c11-memory-model.html">Information on the C++11 Memory Model </a>
</li>
<li>Herb Sutter’s <a href="http://www.gotw.ca/publications/">Effective Concurrency series</a>
</li>
<li>POSIX Standard: <a href="http://www.unix.org/version3/ieee_std.html">http://www.unix.org/version3/ieee_std.html</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">有关Mutex</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li><a href="http://home.roadrunner.com/~hinnant/mutexes/locking.html">Handling mutexes in C++</a>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">Mutex, Lock, Condition Variable Rationale</a>
</li>
</ul>

<p>
<a id="pthread-library" name="pthread-library"></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Pthread Library Routines Reference</h2>
<div class="outline-text-2" id="text-10">
<p>
<a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_atfork.txt">pthread_atfork</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_destroy.txt">pthread_attr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getdetachstate.txt">pthread_attr_getdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getguardsize.txt">pthread_attr_getguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getinheritsched.txt">pthread_attr_getinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedparam.txt">pthread_attr_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getschedpolicy.txt">pthread_attr_getschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getscope.txt">pthread_attr_getscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstack.txt">pthread_attr_getstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstackaddr.txt">pthread_attr_getstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_getstacksize.txt">pthread_attr_getstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_init.txt">pthread_attr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setdetachstate.txt">pthread_attr_setdetachstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setguardsize.txt">pthread_attr_setguardsize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setinheritsched.txt">pthread_attr_setinheritsched</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedparam.txt">pthread_attr_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setschedpolicy.txt">pthread_attr_setschedpolicy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setscope.txt">pthread_attr_setscope</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstack.txt">pthread_attr_setstack</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstackaddr.txt">pthread_attr_setstackaddr</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_attr_setstacksize.txt">pthread_attr_setstacksize</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_destroy.txt">pthread_barrier_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_init.txt">pthread_barrier_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrier_wait.txt">pthread_barrier_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_destroy.txt">pthread_barrierattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_getpshared.txt">pthread_barrierattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_init.txt">pthread_barrierattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_barrierattr_setpshared.txt">pthread_barrierattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cancel.txt">pthread_cancel</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_pop.txt">pthread_cleanup_pop</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cleanup_push.txt">pthread_cleanup_push</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_broadcast.txt">pthread_cond_broadcast</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt">pthread_cond_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt">pthread_cond_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_signal.txt">pthread_cond_signal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_timedwait.txt">pthread_cond_timedwait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_wait.txt">pthread_cond_wait</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getclock.txt">pthread_condattr_getclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_getpshared.txt">pthread_condattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt">pthread_condattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setclock.txt">pthread_condattr_setclock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_setpshared.txt">pthread_condattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_create.txt">pthread_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_detach.txt">pthread_detach</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_equal.txt">pthread_equal</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_exit.txt">pthread_exit</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getconcurrency.txt">pthread_getconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getcpuclockid.txt">pthread_getcpuclockid</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getschedparam.txt">pthread_getschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_getspecific.txt">pthread_getspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_join.txt">pthread_join</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_create.txt">pthread_key_create</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_key_delete.txt">pthread_key_delete</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_kill.txt">pthread_kill</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_destroy.txt">pthread_mutex_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_getprioceiling.txt">pthread_mutex_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_init.txt">pthread_mutex_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_lock.txt">pthread_mutex_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_setprioceiling.txt">pthread_mutex_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_timedlock.txt">pthread_mutex_timedlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_trylock.txt">pthread_mutex_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutex_unlock.txt">pthread_mutex_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_destroy.txt">pthread_mutexattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprioceiling.txt">pthread_mutexattr_getprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getprotocol.txt">pthread_mutexattr_getprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_getpshared.txt">pthread_mutexattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_gettype.txt">pthread_mutexattr_gettype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt">pthread_mutexattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprioceiling.txt">pthread_mutexattr_setprioceiling</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setprotocol.txt">pthread_mutexattr_setprotocol</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_setpshared.txt">pthread_mutexattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_settype.txt">pthread_mutexattr_settype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_once.txt">pthread_once</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_destroy.txt">pthread_rwlock_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_init.txt">pthread_rwlock_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_rdlock.txt">pthread_rwlock_rdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedrdlock.txt">pthread_rwlock_timedrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_timedwrlock.txt">pthread_rwlock_timedwrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_tryrdlock.txt">pthread_rwlock_tryrdlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_trywrlock.txt">pthread_rwlock_trywrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_unlock.txt">pthread_rwlock_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlock_wrlock.txt">pthread_rwlock_wrlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_destroy.txt">pthread_rwlockattr_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_getpshared.txt">pthread_rwlockattr_getpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_init.txt">pthread_rwlockattr_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_rwlockattr_setpshared.txt">pthread_rwlockattr_setpshared</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_self.txt">pthread_self</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcancelstate.txt">pthread_setcancelstate</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setcanceltype.txt">pthread_setcanceltype</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setconcurrency.txt">pthread_setconcurrency</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedparam.txt">pthread_setschedparam</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setschedprio.txt">pthread_setschedprio</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_setspecific.txt">pthread_setspecific</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_sigmask.txt">pthread_sigmask</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_destroy.txt">pthread_spin_destroy</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_init.txt">pthread_spin_init</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_lock.txt">pthread_spin_lock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_trylock.txt">pthread_spin_trylock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_spin_unlock.txt">pthread_spin_unlock</a>
<br /><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_testcancel.txt">pthread_testcancel</a>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html">http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools">https://computing.llnl.gov/?set=code&amp;page=software_tools#perftools</a>
</p></div>


</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multithreading相关术语总结]]></title>
    <link href="http://dreamrunner.org/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie/"/>
    <updated>2014-07-05T23:23:52+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie</id>
    <content type="html"><![CDATA[<p>在谈到内存模型,Multithreading,尤其lock-free programmming等时,总会遇到
一些相关术语来描述,如Memory Barrier,Acquire semantics,Release
semantics,happens-before relation等.在这里稍微整理一下.</p>

<!-- more -->

<h2 id="memory-barriers">Memory Barriers</h2>

<p>在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/">浅谈Memory Reordering</a>
中谈到编译器reordering和在多核下的处理器的reordering,在lock-free
programming中,如果不控制好这两者的reordering就会引起上文中所不想的结果.</p>

<p>你可以通过指令强制CPU和编译器在内存处理上的顺序,这些指令就被成为
<a href="http://en.wikipedia.org/wiki/Memory_barrier">Memory Barrier</a>.</p>

<p>有很多指令作为memory barriers,所以需要知道很多不同类型的memory
barriers. <a href="http://g.oswego.edu/dl/jmm/cookbook.html">Doug Lea指出</a>如下
的四大类可以很好的归纳在CPU上的特殊指令.尽管不是完全,大多数时候,一个正
真的CPU指令执行包含上面barrier类型的各种组合,或附带其他效果.无论如何,
一旦你理解了这四种类型的memory barriers,你就很好的理解了大部分真正CPU
的关于内存约束的指令.
<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">Memory Barriers Are Like Source Control Operations</a>
这篇把Memory Barriers与Source Control作类比,熟悉Source Control机制的可
以很形象的理解各类Memory Barriers机制.</p>

<p><img class="center" src="/images/blog/2014/multithreading/memory_barriers_types.png" title="‘memory_barriers_types’" ></p>

<h3 id="loadload">LoadLoad</h3>

<p>顺序: Load1; <strong>LoadLoad</strong>; Load2</p>

<p>保证Load1的数据加载在被load2和之后的load指令读取加载之前.是一个比较好
的方法防止看到旧的数据.以这个经典的例子,CPU1检查一个共享的标识变量flag来确
认一些数据是否被CPU1更新.如果标识变量flag是true的话,把<code>LoadLoad</code>barrier
放在读取更新数据之前:</p>

<p><code>c++
if (is_updated) {
    LOADLOAD_FENCE();  // Prevent reordering of loads
    return value;  // Load updated value
}
</code></p>

<p>只要<code>is_updated</code>被CPU1看到为true, <code>LoadLoad</code>fence防止CPU1读到比标识变
量flag本身旧的<code>value</code>.</p>

<h3 id="storestore">StoreStore</h3>

<p>顺序: Store1; <strong>StoreStore</strong>; Store2</p>

<p>保证Store1的数据被其他CPU看到在与这数据相关的Store2和之后的store指令之
前.同样,它足够的防止其他CPU看到自己的旧数据.同上一样的例子,CPU1需要更
新一些数据到共享的内存中,把<code>StoreStore</code> barrier放在标识变量flag是true
之前:</p>

<p><code>c++
value = x;
STORESTORE_FENCE();
is_updated = 1;  // Set shared flag to show the update of data
</code></p>

<p>一旦其他CPU看到<code>is_updated</code>为true,它能自信它看到正确的<code>value</code>值.而且
<code>value</code>不需要原子类型,它可以是一个包含很多元素的大数据结构.</p>

<h3 id="loadstore">LoadStore</h3>

<p>顺序: Load1; <strong>LoadStore</strong>; Store2</p>

<p>保证Load1的数据被加载在与这数据相关的Store2和之后的store指令之
前.</p>

<h3 id="storeload">StoreLoad</h3>

<p>顺序: Store1; <strong>StoreLoad</strong>; Load2</p>

<p>保证Store1的数据被其他CPU看到在数据被Load2和之后的load指令加载之前.也
就是说,它有效的防止所有barrier之前的stores与所有barrier之后的load乱序.</p>

<p><code>StoreLoad</code>是唯一的.它是唯一的memory barrier类型来防止<code>r1=r2=0</code>在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#memory-ordering-at-processor-time">Memory ordering at processor time</a>
中给出的例子.</p>

<p><code>StoreLoad</code>有什么区别与<code>StoreStore</code>之后跟<code>LoadLoad</code>?虽
然,<code>StoreStore</code>按序把存储改变推送到主内存中,<code>LoadLoad</code>按序把改变加载过
来,但是这两种类型的barrier是不够的.Store可以延迟任意的指令,以致在Load
之后,Load也可以不是加载最新Store之后的内容.这就是为啥PowerPC的指令
<code>lwsync</code>,包含这三种memory barriers,<code>LoadLoad</code>,<code>LoadStore</code>和
<code>StoreStore</code>,但不包含<code>StoreLoad</code>,是不足以防止<code>r1=r2=0</code>在那个实例中.</p>

<h3 id="data-dependency-barriers">Data dependency barriers</h3>

<p>除了上面4大类,还有<code>Loadload</code>的弱化模式的<code>Data dependency barrier</code>.如
<code>LoadLoad</code>类似,在两个load顺序执行,load2依赖于load1的结果,<code>Data
dependency barrier</code>需要插入保证两者的顺序.</p>

<p>但与<code>LoadLoad</code>不同,<code>Data dependency barrier</code>只是部分顺序约束在内在以来
的load,就是load1必须与load2是 <strong>data</strong> dependency 而不是仅仅是
<strong>control</strong> dependency.</p>

<ul>
  <li>data dependency</li>
</ul>

<p>r1与r2之间是data dependency.</p>

<p><code>c
r1 = 1;
r2 = r1;
</code></p>

<ul>
  <li>control dependency</li>
</ul>

<p>r1与r2之间是control dependency.</p>

<p><code>c
r1 = value;
if (r1) {
    r2 = r1;
} else {
    r2 = 1;
}
</code></p>

<h3 id="more">More</h3>

<ul>
  <li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS</a> </li>
  <li><a href="www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf">Memory Barriers: a Hardware View for Software Hackers</a></li>
</ul>

<h2 id="acquire-and-release-semantics">Acquire and Release semantics</h2>

<p>在lock-free programming中,共享内存被多个线程通过合作传递信息来处理,在
这种处理下,acquire和release semantics是关键技术保证可靠的传递信息在线
程之间.</p>

<p>acqure和release semantics并没有好的被定义,这里借用Jeff Preshing在
<a href="http://preshing.com/20120913/acquire-and-release-semantics/">这里</a>给
予的定义:</p>

<p><img class="right" src="/images/blog/2014/multithreading/read_acquire.png" width="170" height="110" title="‘read_acquire’" ></p>

<p><strong>Acquire semantics</strong> 是一种只能应用于如下操作的性质: 从
共享内存读取,无论是
<a href="http://en.wikipedia.org/wiki/Read-modify-write">read-modify-write</a>操
作还是普通的加载.这一操作被认为是一个 <strong>read acquire</strong>. Acquire
semantics防止read acquire程序上<strong>之后</strong>的任何读或写操作与它的内存乱
序.</p>

<p><br /></p>

<p><img class="right" src="/images/blog/2014/multithreading/write_release.png" width="170" height="110" title="‘write_release’" ></p>

<p><strong>Release semantics</strong> 是一种只能应用于如下操作的性质: 写入到共享内存,
无论是read-modify-write操作还是普通的存储.这一操作被认为是一个 <strong>write release</strong>.
Release semantics防止write release程序上<strong>之前</strong>的任何读或写
操作与它的乱序.</p>

<p>Acqure和release semantics能通过之前四种memory barrier的简单组合来达到.</p>

<p><img class="center" src="/images/blog/2014/multithreading/acquire_release_semantics.png" title="‘acquire_release_semantics’" ></p>

<p>Acqure和release semantics可以基本划分为如下结构:</p>

<p><img class="center" src="/images/blog/2014/multithreading/acquire_release_semantics_category.png" title="‘acquire_release_semantics_category’" ></p>

<h3 id="fence">使用明确的平台相关Fence指令</h3>

<p>在X86/64使用<code>mefence</code>指令,mfence是一个满足全部memory barrier,防止任何类型的内存乱序.</p>

<p><img class="center" src="/images/blog/2014/multithreading/platform-specific_fence.png" title="‘platform-specific_fence’" ></p>

<h3 id="c11fences">可移植的C++11的Fences</h3>

<p>C++11的atomic库定义了一个可移植的函数<code>atomic_thread_fence()</code>,输入一个
变量来指定什么类型的fence.</p>

<p><img class="center" src="/images/blog/2014/multithreading/fence_in_c++11.png" title="‘fence_in_c++11’" ></p>

<h3 id="c11atomicfence">可移植的C++11的atomic,非明确的fence</h3>

<p>在C++11中,可以直接对atomic变量直接约束fence,而不是显示的明确fence.与上
面明确fence相比,这实际是更优的方法来表达acquire and release semantics
在C++11中.</p>

<p><img class="center" src="/images/blog/2014/multithreading/without_fence_c++11.png" title="‘without_fence_c++11’" ></p>

<h2 id="happens-before-relation">Happens-before relation</h2>

<p><em>Happens-before</em> 是一个术语来描述C++11,Java,LLVM之类背后的<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#weak-vs-strong-memory-models">软件内存模型</a>.</p>

<p>在之上每个语言里都能找到<em>happends-before</em>的定义,尽管每个都有不同的说法,但
内在意思基本一致.粗略地讲,基本定义如下:</p>

<p><blockquote><p>A和B表示一个多线程进行的操作.若A <strong>happens-before</strong> B,那<br/>么,在B进行前,A对B的内存影响有效的被B看到.</p></blockquote></p>

<p>无论使用任何编程语言,它们都有一个共同处:如果操作A和B被同一个进程进行,A
的语句在B的语句之前在程序顺序上,那么A<em>优先发生(happens-before)</em>B.这也
是在之前
<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/#weak-vs-strong-memory-models">Memory ordering</a>
中谈到中心原则.</p>

<p>这里再次提一下指令重排序问题,有人有如下疑问: 指令重排序会破坏
happens-before原则吗？happens-before的程序次序原则说：在一个线程内，按
照程序代码顺序，书写在前面的操作会先行发生于书写在后面的操作。如果线程
内出现指令重排序，那不是破坏了程序次序原则了吗？</p>

<p>是会破坏程序次序的执行,但是并不破坏happens-before原则,并不造成内存对单
线程有效性的破坏.这里主要的困惑是时间上顺序的发生之前(happening
before)与先行发生(happens-before)两者关系.</p>

<p>时间上顺序的发生在前于(happening before)与先行发生(happens-before)两者是
不一样的,基本没太大关系.特别:</p>

<ol>
  <li>A先行发生(happens-before)B并不意味着A发生在前于(happening before)B.</li>
  <li>A发生在前于(happening before)B并不意味A先行发生(happens-before)B.</li>
</ol>

<p>谨记happens-before是由一系列编程语言特定定义的操作间的关系,它的存在独
立于时间的概念.</p>

<h3 id="happens-beforehappening-before">happens-before并不意味happening before</h3>

<p>如下例子有happens-before关系但并不是顺序执行,没有happening before.如下
代码:(1) 存储到A,之后(2)存储到B.根据程序顺序原则,(1) happens-before (2).</p>

<p><code>c++
int A, B;
void test() {
  A = B + 1;  // (1)
  B = 0;  // (2)
}
</code></p>

<p>用O2打开优化编译的如下:</p>

<p>``` sh
$ gcc -S -O2  -masm=intel test.c</p>

<pre><code>mov	eax, DWORD PTR B
mov	DWORD PTR B, 0
add	eax, 1
mov	DWORD PTR A, eax ```
</code></pre>

<p>从汇编指令看出,第二句<code>mov DWORD PTR B, 0</code>就已经完成对<code>B</code>的存储,但是
对<code>A</code>的存储还没进行.(1)顺序上并没有在(2)之前执行!</p>

<p>但是happens-before原则有被违背吗?根据定义,(1)的内存效用必须有效被看到
在进行(2)之前.也就是存储A必须影响存储B.</p>

<p>在这里,存储A实际并没有影响存储B.(2)被提前执行与之后执行仍然一样,相当与
(1)的内存有效性是一样的.因此,这并不算违背happens-before原则.</p>

<h3 id="happening-beforehappens-before">happening before并不意味happens-before</h3>

<p>这是个时间上发生于前但并含有happens-before关系的例子.如下的代码,想象一
个线程调用<code>UpdateValue</code>,而另一个线程调用<code>ConsumeValue</code>.因为处理共享的
数据并行的,为了简单,认为普通的读取和存储<code>int</code>是atomic的.因为程序顺序原
则,在(1)和(2)之间happens-before关系,(3)和(4)之间happens-before关系.</p>

<p>``` c++
int value = 0;
int updated = 0;</p>

<p>void UpdateValue() {
    value = 123;  // (1)
    update = 1;  // (2)
}</p>

<p>void ConsumeValue() {
if (update) {  // (3)
    printf(“%d\n”, value);  // (4)
}
```</p>

<p>进一步假设在运行开始的时候,(3)读取<code>update</code>到为1,这个值是有(2)在另外个线程
中存储的.这里,我们可以得出时间顺序上(2)必须发生前于(3).但是这里并没有规
则意味着在(2)和(3)之间有happens-before关系.(2)和(3)之间没有
happens-before关系,(1)和(4)之间也没有happens-before关系.因此,(1)和(4)
的内存可以重排序,因为编译器重排序或在CPU上内存重排序,以致(4)可以打印
“0”,即使(3)读到1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈Mutex (Lock)]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/"/>
    <updated>2014-06-29T20:52:09+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a>(又叫Lock),在多线程中,作为同步的基本类型,用来保证没有两个线程或进程同时在他们的关键区域.因为Mutex这种排它性,很多人认为Mutex开销很大,尽量避免使用它.就如这篇
分析完共享数据问题后,进一步分析说明
<a href="http://courses.cs.washington.edu/courses/cse451/03wi/section/prodcons.htm">Avoiding locks</a>
来解决这个问题.但Mutex真的开销如此大,还是被大家误解了?Matthew
Dillon<a href="http://groups.google.com/group/net.micro.mac/msg/752d18de371bd65c?dmode=source">写道</a>,”Most
people have the misconception that locks are slow.”, Jeff Preshing也
<a href="http://preshing.com/20111118/locks-arent-slow-lock-contention-is/">写了这篇”Locks Aren’t Slow; Lock Contention Is”</a>.</p>

<p>那么接下来做3个关于Mutex的Benchmark,具体分析一下Mutex的开销如何,最后并
利用原子操作和semaphore实现一个lightweight Mutex.</p>

<!-- more -->

<p>一个Mutex仅仅从Lock到Unlock具体开销是多少,是不是占用很多时间,从
<a href="http://preshing.com/20111124/always-use-a-lightweight-mutex/">Always Use a Lightweight Mutex</a>
从可以看到在windows中有两种
Mutex:<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684266%28v=vs.85%29.aspx">Muetx</a>
和
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682530%28v=vs.85%29.aspx">Critical Section</a>,
重量级和轻量级的区别,两者的时间开销相差25倍多,所以一直使用轻量级的Mutex.</p>

<p><a href="http://ridiculousfish.com/blog/posts/barrier.html">这篇文章</a>在高强度
下lock的性能:每个线程做任何事情都占用lock(高冲突),lock占用极短的时间
(高频率).值得一读,但是在实际应用中,基本避免如此使用locks.这里对
Mutex Contention和Mutex Frequency都做最好和最坏场景的使用测试.</p>

<p>Mutex被灌以避免使用也因为其他原因.现在有很多大家熟知的
<a href="en.wikipedia.org/wiki/Non-blocking_algorithma">lock-free programming</a>
技术.Lock-free编程非常具有挑战性,但在实际场景中获得巨大的性能.既然有
lock-free的技术吸引我们使用它们,那么locks就显得索然无味了.</p>

<p>但也不能因此忽略lock.因为在实际很多场景,它仍然是利器.</p>

<h2 id="lightweight-mutex-benchmark">Lightweight Mutex Benchmark</h2>

<p>Linux下的POSIX thread是轻量级的Mutex.基于Linux特有的
<a href="http://en.wikipedia.org/wiki/Futex">futex</a>技术,当没有其他线程竞争锁时它被优化过.使
用如下简单的例子,测试一个单线程lock和unlock,所有代码在<a href="https://github.com/shishougang/blog_multithreading/tree/master/mutex_time">Github上</a>.</p>

<p><code>c++
pthread_mutex_init(&amp;lock, NULL);
const int kN = 1000000;
for (int i = 0; i &lt; kN; ++i) {
    pthread_mutex_lock(&amp;lock);
    pthread_mutex_unlock(&amp;lock);
}
pthread_mutex_destroy(&amp;lock);
</code></p>

<p>插入相应的时间代码,算出10万次的单线程lock/unlock平均时间.在不同的处理
器下,结果如下:</p>

<p><img class="center" src="/images/blog/2014/multithreading/mutex_benchmark.png" width="450" height="200" title="‘mutex_benchmark’" ></p>

<p>如果假设一个线程每分钟获取1e5次mutex,并且没有其他线程与它竞争.基于如下
的图,可预计0.2%到0.4%的开销.不算差.在比较低频率下,开销基本忽略不计.之
后<a href="http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock#build-own-lightweight-mutex">Build own lightweight mutex</a>,会利用<a href="http://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>和一个原子操作,实现一个lightweight mutex.</p>

<p>POSIX thread与Windows Critical Section不同,它不仅支持线程间的同步,
还支持进程间的同步.实例代码如下:</p>

<p>```  c++  mutex_between_process.cc
pthread_mutex_t mutex;
pthread_mutexattr_t attrmutex;</p>

<p>/* Initialise attribute to mutex. */
pthread_mutexattr_init(&amp;attrmutex);
pthread_mutexattr_setpshared(&amp;attrmutex, PTHREAD_PROCESS_SHARED);
pthread_mutex_init(&amp;mutex, &amp;attrmutex);</p>

<p>/* Use the mutex. */</p>

<p>/* Clean up. */
pthread_mutex_destroy(pmutex);
pthread_mutexattr_destroy(&amp;attrmutex);
```</p>

<h2 id="mutex-contention-benchmark">Mutex Contention Benchmark</h2>

<p>在测试中,产生一个不断生成随机数的线程,使用自己编制的线程安全的
<a href="http://en.wikipedia.org/wiki/Mersenne_twister">Mersenne Twister</a>实现
代码.每过一段时间,它获取和释放一个锁,获取和释放锁之间的时间每次是随机的,但
是总的平均时间是提前设计好的.这个随机的过程就是个泊松分布过程,计算出产
生一个随机数的平均时间6.25 ns在2.93 GHz i7上,把它作为运行单位.利用
<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/poisson-process.html">Poisson Process</a>
的算法决定运行多少个运行单位在获取和释放锁之间.并利用
<a href="http://dreamrunner.org/blog/2014/06/24/high-resolution-time/">High Resolution Time</a>API
计算时间.这个线程的代码如下,所有代码在<a href="https://github.com/shishougang/blog_multithreading/tree/master/mutex_contention">Github上</a>:</p>

<p>``` c++
  GetMonotonicTime(&amp;start);
  for (;;) {
    work_units = static_cast<int> (random.PoissonInterval(
        global_state.average_unlock_count) + 0.5f);
    for (int i = 0; i &lt; work_units; ++i) {
      random.Integer();
    }
    thread_stats.workdone += work_units;</int></p>

<pre><code>GetMonotonicTime(&amp;end);
elapsed_time = GetElapsedTime(&amp;start, &amp;end);
if (elapsed_time &gt;= global_state.time_limit) {
  break;
}

// Do some work while holding the lock
pthread_mutex_lock(&amp;global_state.thread_mutex);
work_units = static_cast&lt;int&gt; (random.PoissonInterval(
    global_state.average_locked_count) + 0.5f);
for (int i = 0; i &lt; work_units; ++i) {
  random.Integer();
}
thread_stats.workdone += work_units;
pthread_mutex_unlock(&amp;global_state.thread_mutex);

thread_stats.iterations++;
GetMonotonicTime(&amp;end);
elapsed_time = GetElapsedTime(&amp;start, &amp;end);
if (elapsed_time &gt;= global_state.time_limit) {
  break;
}   } ```
</code></pre>

<p>这里模拟获取和释放15000次锁每秒,从1个线程运行到2个线程,最后到4个线
程.并且验证占用锁的时间,从0%到100%的每次运行时间占用锁.把1个线程的完成
的工作量作为基准数据,其他的去除以它,计算相对增益.基本测试方案如下:</p>

<p><code>c++
// Test 15000 locks per second: thread number, lock_interval
    1, 1/15000.0f, 
    2, 1/15000.0f,
    3, 1/15000.0f,
    4, 1/15000.0f,
</code></p>

<p><img src="/images/blog/2014/multithreading/lock_benchmark.png" title="lock_benchmark’" ></p>

<p>从图中看出,随着锁占用的时间增加,并行性越来越差,直到最后占用60%以后,单
线程运行的更好.可以说,短时间的占用锁的时间,以10%以内,系统达到很高的并
行性.虽然并不是完美的,但是也接近.锁总体很快.</p>

<p>把这个结果放到实际中,Jeff Preshing在
<a href="http://preshing.com/20111118/locks-arent-slow-lock-contention-is/">这篇</a>
提到,实际的游戏程序中,15000的锁每秒来自3个线程,占用锁的时间相对2%.在图
中很适中的区域.</p>

<h2 id="mutex-frequency-benchmark">Mutex Frequency Benchmark</h2>

<p>尽管一个lightweight mutex有开销,但如上测试在2.40GHz i5上,lock/unlock锁
开销约 <strong>34.2ns</strong> ,因此15000锁每秒开销很低以致不是严重影响结果.那么把
锁的每秒频率提高呢?</p>

<p>只创建2个线程,进行一系列的锁的每秒频率测试在2.40GHz i5上,从占用锁时间
10 ns(1e8/s)到100 us(1e4/s),用单线程的占用锁时间10 ms作为基准工作量,其
他与它比较,测试方案如下:</p>

<p>``` c++
  // Reference
  1, 10e-3f,      // 10 ms        100/s</p>

<pre><code>// Test various lock rates with 2 threads
2, 10e-9f,      // 10 ns        100000000/s
2, 31.6e-9f,    // 31.6 ns      31600000/s
2, 100e-9f,     // 100 ns       10000000/s
2, 316e-9f,     // 316 ns       3160000/s
2, 1e-6f,       // 1 us         1000000/s
2, 3.16e-6f,    // 3.16 us      316000/s
2, 10e-6f,      // 10 us        100000/s
2, 31.6e-6f,    // 31.6 us      31600/s
2, 100e-6f,     // 100 us       10000/s ```
</code></pre>

<p><img src="/images/blog/2014/multithreading/frequency_benchmark.png" title="‘frequency_bechmark’" ></p>

<p>如预想一样,对于非常高频率的锁,锁的开销开始减少实际工作量.在网络上,可以
找到很多同样的测试.图中下边的线条,对于这样高的频率,也就是占用锁的时间
很短,就一些CPU的指令,这样的情况下,当锁之间的工作如此简单,那么一个
lock-free的实现更适合.</p>

<p>我们获得了一大块关于锁的性能:从它进行很好的情况,到缓慢应用的情况.在考
虑实际锁的使用情况,不能说所有锁都是慢的.必须承认,很容易乱用锁,但不用太
担心,任何的瓶颈问题都会在细心的profiling中发现.当你考虑锁是如何的稳定,
相对容易的理解它们(与lock-free技术相比),锁有时候其实很好用.</p>

<h2 id="build-own-lightweight-mutex">Build own lightweight mutex</h2>

<p>我们也可以实现自己的简单轻量级的mutex,但仅仅作为教育手段,理解mutex一些
内在实现细节,实际现在操作系统都提供轻量级的mutex,千万不要自己实现一个
并实际使用,直接只用操作系统提供的即可.</p>

<p>网络上有很多种方法在用户层写自己的mutex:</p>

<ul>
  <li><a href="http://preshing.com/20120226/roll-your-own-lightweight-mutex/">roll-your-own-lightweight-mutex</a>利用Windows提供的semaphore和atomic操作实现的mutex.</li>
  <li><a href="http://cbloomrants.blogspot.hk/2011/07/07-15-11-review-of-many-mutex.html">Review of many Mutex implementations</a>很长的一篇文章,总结了很多种mutex的实现细节.</li>
</ul>

<p>这里利用
<a href="http://www.haiku-os.org/legacy-docs/benewsletter/Issue1-26.html#Engineering1-26">Benaphore</a>
技术,在Linux平台上利用<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_init.html">semaphore</a>和<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">atomic</a>操作实现自己的C++版本的
lightweight mutex.这里并没有用
<a href="http://www.open-std.org/JTC1/sc22/wg21/docs/papers/2007/n2427.html">C++11的原子库</a>.所
有代码在<a href="https://github.com/shishougang/blog_multithreading/tree/master/benaphore_mutex">Github上</a>.</p>

<p>``` c++
 #include <semaphore.h>
class Benaphore {
 public:
  Benaphore() : counter_(0) {
    sem_init(&amp;semaphore_, 0, 0);
  }
  ~Benaphore() {
    sem_destroy(&amp;semaphore_);
  }
  void Lock() {
    if (__sync_add_and_fetch(&amp;counter_, 1) &gt; 1) {
      sem_wait(&amp;semaphore_);
    }
  }
  void Unlock() {
    if (__sync_sub_and_fetch(&amp;counter_, 1) &gt; 0) {
      sem_post(&amp;semaphore_);
    }
  }
  bool TryLock() {
    return __sync_bool_compare_and_swap(&amp;counter_, 0, 1);
  }</semaphore.h></p>

<p>private:
  long counter<em>;
  sem_t semaphore</em>;
};
```</p>

<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html"><code>__sync_add_and_fetch</code></a>
是一个由GCC内部提供的 <em>atomic read-modify-write (RMW)</em> 操作,它把1加到
某个数并且返回新的数,在同一时间所有操作由一个线程原子操作完成,其他线程
不能干涉,只能在后等待.这里<code>counter_</code>初始化为0,第一个线程调用<code>Lock</code>将得
到1从<code>__sync_add_and_fetch</code>,然后跳过<code>sem_wait</code>,一旦这个线程占用这个锁,
之后线程都将递增<code>counter_</code>,获得大于1的数,从而调用<code>sem_wait</code>等待.</p>

<p>之后,第一个线程完成自己的操作,调用<code>Unlock</code>,<code>__sync_sub_and_fetch</code>的返
回值大于1说明有其他线程在等待这个mutex,调用<code>sem_post</code>唤醒其他线程.</p>

<h3 id="section">底层分析与性能</h3>

<p>上面使用了<code>__sync_add_and_fetch</code>,它编译成<code>lock xadd</code>指令如下.在没有竞
争下的lock/unlock操作性能与pthread mutex相当.但是在mutex多线程竞争情况
下,这个mutex性能没有pthread mutex好.</p>

<p><img src="/images/blog/2014/multithreading/lightweight_mutex_assembly.png" title="‘lightweight_mutex_assembly’" ></p>

<h3 id="mutex">增强Mutex支持递归</h3>

<p>上面简单的lightweight mutex的局限性是它不能递归.也就是同一个线程试图获
取同样的锁两次以上,将造成死锁(deadlock).递归锁在函数调用自己时很有用.比
如在内存管理代码中,可能会遇到如下代码:</p>

<p>``` c++
Realloc(void* ptr, size_t size)
{
    LOCK;</p>

<pre><code>if (ptr == NULL)
{
    return Alloc(size);
}
else if (size == 0)
{
    Free(size);
    return NULL;
}
else
    ... }
</code></pre>

<p>Alloc(size_t size)
{
    LOCK;</p>

<pre><code>... } ```
</code></pre>

<p><code>Lock</code>是个封装好的C++宏,用来获取锁和自动结果当退出函数.</p>

<p>可以看到,当传递<code>NULL</code>给<code>Realloc</code>,锁被<code>Realloc</code>函数获取,然后第二次被获
取当<code>Alloc</code>被调用.</p>

<p>把它扩展成可递归的锁如下,加入2个新成员变量,<code>owner_</code>,存储当前占有线程的
ID(TID),和<code>recursion_</code>,存储递归的层数.基本代码如下:</p>

<p>``` c++
 #include <semaphore.h>
 #include <pthread.h>
 #define LIGHT_ASSERT(x) { if (!(x)) __builtin_trap(); }</pthread.h></semaphore.h></p>

<p>class RecursiveBenaphore {
 public:
  RecursiveBenaphore() : counter<em>(0), owner</em>(0), recursion<em>(0) {
    sem_init(&amp;semaphore</em>, 0, 0);
  }
  ~RecursiveBenaphore() {
    sem_destroy(&amp;semaphore<em>);
  }
  void Lock() {
    pthread_t thread_id = pthread_self();
    if (__sync_add_and_fetch(&amp;counter</em>, 1) &gt; 1) {
      if (!pthread_equal(thread_id, owner<em>)) {
        sem_wait(&amp;semaphore</em>);
      }
    }
    owner_ = thread_id;
    recursion<em>++;
  }
  void Unlock() {
    pthread_t thread_id = pthread_self();
    LIGHT_ASSERT(pthread_equal(thread_id, owner</em>));
    long recur = –recursion<em>;
    if (recur == 0) {
      owner</em> = 0;
    }
    long result = <em>_sync_sub_and_fetch(&amp;counter</em>, 1);
    if (result &gt; 0) {
      if (recur == 0) {
        int sem_value;
        sem_getvalue(&amp;semaphore<em>, &amp;sem_value);
        if (sem_value == 0) {
          sem_post(&amp;semaphore</em>);
        }
      }
    }
  }
  bool TryLock() {
    pthread_t thread_id = pthread_self();
    if (pthread_equal(thread_id, owner<em>)) {
      __sync_add_and_fetch(&amp;counter</em>, 1);
    } else {
      bool result = <em>_sync_bool_compare_and_swap(&amp;counter</em>, 0, 1);
      if (result == false) {
        return false;
      }
      owner_ = thread_id;
    }
    recursion_++;
    return true;
  }</p>

<p>private:
  long counter<em>;
  sem_t semaphore</em>;
  pthread_t owner<em>;
  long recursion</em>;
};
```</p>

<p>如之前一样,第一个线程调用<code>Lock</code>,设置<code>owner_</code>为自己的TID,增加
<code>recursion_</code>到1.如果同一个线程再次调用<code>Lock</code>,它将同时增加
<code>recursion_</code>和<code>counter_</code>.</p>

<p>之后,第一个线程完成自己的操作,调用<code>Unlock</code>,同时减少<code>recursion_</code>和<code>counter_</code>,
仅仅调用<code>sem_post</code>唤醒其他线程当<code>recursion_</code>减少到<code>0</code>.如果
<code>recursion_</code>仍然大于0,意味着当前的线程仍然占有此锁在外层程序.</p>

<p>最后进行<strong>压力测试</strong>,建立一些线程,每个随机获取锁,随机的递归层次.代码在
<a href="https://github.com/shishougang/blog_multithreading/tree/master/benaphore_mutex">Github上</a>.</p>

<p>一些细节问题:
* 在<code>Unlock</code>中,设置<code>owner_</code>为0在调用<code>__sync_sub_and_fetch</code>之前,否则可
  能发生死锁(deadlock).比如,有两个线程TID是111和222.
    1. 线程111完成操作调用<code>Unlock</code>,先调用<code>__sync_sub_and_fetch</code>把<code>counter_</code>减到0
    2. 在设置<code>owner_</code>为0被中断,线程222得到运行,它调用<code>Lock</code>,发现<code>counter_</code>为0,跳过<code>sem_wait</code>,设置<code>owner_=222</code>,完成<code>Lock</code>操作.
    3. 线程222被中断调出,线程111重新得到运行,设置<code>owner_</code>为0,然后完成<code>Unlock</code>操作.
    4. 因为此时<code>owner_</code>为0,线程222不能在递归占用锁,一旦它再次获取锁,形成死锁.</p>

<ul>
  <li>
    <p>在<code>Unlock</code>中,<code>recursion_</code>被拷贝到本地变量一次,之后只本地变量,比如没
有在<code>__sync_sub_and_fetch</code>之后重新读取她.因为在那之后它能被其他线程
已经改变. </p>
  </li>
  <li>
    <p><code>recursion_</code>和<code>owner_</code>没有原子操作.因为它们在调用<code>Lock</code>的
<code>__sync_add_and_fetch</code>和调用<code>Unlock</code>的<code>__sync_sub_and_fetch</code>之间,线
程占有锁,独占<code>recursion_</code>和<code>owner_</code>的读写操作,并拥有所有的acquire
and release semantics.对<code>recursion_</code>和<code>owner_</code>使用原子操作没必要.因
为在X86/84的平台上,<code>__sync_add_and_fetch</code>生成<code>lock xadd</code>的指令,保证
全部的memory barrier,也就保证acquire and release semantics.</p>
  </li>
</ul>

<h2 id="mutex-vs-spinlock">Mutex VS Spinlock</h2>

<p>提到Mutex,往往会提到Spinlock,因为在使用Lock时,会遇到如何在Mutex与Spinlock之
间选择.那么接下来对比一下两者.</p>

<h3 id="section-1">定义</h3>

<p>Mutex: 如果一个线程试图获取一个mutex,但是没有成功,因为mutex已经被占用,
它将进入睡眠,让其他进程运行,直到mutex被其他进程释放.</p>

<p>Spinlock: 如果一个线程试图获取一个Spinlock, 但是没有成功,它将持续试着
去获取它,直到它最终成功获取,因为它将不允许其他线程运行(然而,操作系统将
强制调度其他线程).</p>

<h3 id="section-2">各自缺点</h3>

<p>Mutex: Mutex将使得线程睡眠,然后再唤醒它们,两者都是开销比较大的操作,也
就是context switch的开销.如果锁只是被其他线程占用非常短的时间,那么时间
花在使的线程睡眠并唤醒它可能超过它使用spinlock持续获取锁的时间.</p>

<p>Spinlock: Spinlock持续获取锁,浪费很多CPU时间,如果锁被其他线程占用很长
时间,那么它将浪费很多时间,不如使得线程进入睡眠,让出CPU.<a href="http://jfdube.wordpress.com/2011/09/24/lessons-learnt-while-spinning/">Spinlock的确能优化context switches</a>
但会在没有
<a href="http://en.wikipedia.org/wiki/Priority_inversion">threads priority inversion</a>
的平台上产生副作用.(但一个高优先级的线程自旋一个锁来等待一个低优先级的
线程释放这个锁,就会造成死锁).在没有Preemption的Uniprocessor,使用
spinlock是没有意义的,当前只有一个线程运行,没有必要保护关键区域,也没有其他线程同时运行,释放锁
给它.</p>

<p>所以在Linux下,Spinlock在kernel这样实现:</p>

<ul>
  <li>没有打开<code>CONFIG_SMP</code>和<code>CONFIG_PREEMPT</code>,spinlock实现代码是空的.</li>
  <li>没有打开<code>CONFIG_SMP</code>,打开<code>CONFIG_PREEMPT</code>,spinlock仅仅是简单的关闭
preemption,足够来防止任何的
<a href="http://en.wikipedia.org/wiki/Race_condition">races</a>. </li>
  <li>打开<code>CONFIG_SMP</code>,打开<code>CONFIG_PREEMPT</code>,spinlock实现如下代码,不断检查
lock是否被其他线程释放: </li>
</ul>

<p><code>c
  extern inline void spin_lock(spinlock_t *plock)
  {
    __asm__ __volatile__(
        spin_lock_string
        :"=m" (__dummy_lock(plock)));
  }
  // Macro spin_lock_string expand
  extern inline void spin_lock(spinlock_t *plock)
 {
  1:
    lock ; btsl ,plock;
    jc 2f;
    .section .text.lock,"ax"
  2: 
    testb ,plock;
    rep;nop;
    jne 2b;
    jmp 1b;
    .previous
 }
</code></p>

<h3 id="section-3">总结</h3>

<table>
  <thead>
    <tr>
      <th>Criteria</th>
      <th>Muutex</th>
      <th>Spinlock</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>机制</td>
      <td>尝试获取锁.若可得到就占有.若不能,就进入睡眠等待.</td>
      <td>尝试获取锁.若可得到就占有.若不能,持续尝试直到获取.</td>
    </tr>
    <tr>
      <td>什么时候使用</td>
      <td>当线程进入睡眠没有伤害.或需要等待一段足够长的时间才能获取锁.</td>
      <td>当线程不应该进入睡眠如中断处理等.当只需等待非常短的时间就能获取锁.</td>
    </tr>
    <tr>
      <td>缺点</td>
      <td>引起context switch和scheduling开销.</td>
      <td>线程不做任何事情在获取到锁前.浪费CPU运行.</td>
    </tr>
  </tbody>
</table>

<p><a href="http://en.wikipedia.org/wiki/Spinlock#Alternatives">大多数操作系统(包括Solaris,Mac OS X和FreeBSD)使用混合的机制叫”adaptive mutex”或”hybrid mutex”</a>.一
个hybrid mutex首先行为和spinlock一样,如果不能获取锁,持续尝试获取,但过
了一定的时间,它就和mutex一样,让线程进入睡眠.<sup id="fnref:f1"><a href="#fn:f1" rel="footnote">1</a></sup>.</p>

<div class="footnotes">
  <ol>
    <li id="fn:f1">
      <p>http://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex<a href="#fnref:f1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
