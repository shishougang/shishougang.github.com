<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C++ | (learn&think)]]></title>
  <link href="http://dreamrunner.org/tags/c-/atom.xml" rel="self"/>
  <link href="http://dreamrunner.org/"/>
  <updated>2014-06-05T20:40:13+08:00</updated>
  <id>http://dreamrunner.org/</id>
  <author>
    <name><![CDATA[DreamRunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Last Thing D Needs总结]]></title>
    <link href="http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie/"/>
    <updated>2014-06-01T16:24:47+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/06/01/the-last-thing-d-needszong-jie</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#initialization">Initialization</a></li>
  <li><a href="#type-deduction">Type Deduction</a></li>
  <li><a href="#inheritance">Inheritance</a></li>
  <li><a href="#computational-complexity">Computational Complexity</a></li>
  <li><a href="#apis">APIs</a></li>
  <li><a href="#specifications">Specifications</a></li>
  <li><a href="#essential-and-accidental-complexity">Essential and Accidental Complexity</a></li>
</ul>

<p><a href="http://www.amazon.com/gp/product/0321334876?ie=UTF8&amp;tag=aristeia.com-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321334876">Effective C++</a>
系列的作者<a href="http://www.aristeia.com/">Scott Meyers</a>在Dconf中<a href="http://www.ustream.tv/recorded/47947981">The Last Thing D Needs</a>聊了些C++的
特性，稍微总结一下。</p>

<h2 id="initialization">Initialization</h2>

<p><code>c++ Initialization
int x1;         // unknown, initial(pay for it)
int x2;         // (at global scope) 0, no run time cost
static int x3;  // 0, static initialization
int *px = new int;  // heap memory, unknown, has run time cost
{
    int x4;    // unknown, has run time cost 
}
int a1[100];   // unknown
int a2[100];   // (at global scope) 0
static int a3[100];  // 0
std::vector&lt;int&gt; v(100);  // 0, use run time cost
</code></p>

<!-- more -->

<h2 id="type-deduction">Type Deduction</h2>
<p>``` c++ Type Deduction
const int cx = 0;
auto my_cx1 = cx;          // int, new independent value
decltype(cx) my_cx2 = cx;  // const int, standard said</p>

<p>template<typname t="">
void f1(T param);
f1(cx);                    // T's type, int, same rules with auto</typname></p>

<p>template<typename t="">
void f2(T&amp; param);
f2(cx);                   //T's type, const int, reference a chunk of memory, preserve the const</typename></p>

<p>template<typename t="">
void f3(T&amp;&amp; param);
f3(cx);                  //T's type, const int&amp;, perfect argument forwarding, a special rule</typename></p>

<p>const int cx = 0;
auto lam= [cx] {cx = 10;};       //error!
class UpToTheCompiler {
private:
  ??? cx;                      //const int
  …
};</p>

<p>const int cx = 0;
auto lam= [cx = cx] {cx = 10;};     //error!
class UpToTheCompiler {
private:
  ??? cx;                          //int (but acts like const int)
  …
public:
  void operator() const
  {cx = 0;}
};</p>

<p>const int cx = 0;
auto lam1= [cx = cx] mutable {cx = 10;};     //error!
auto lam2= <a href="">cx = cx</a> mutable {cx = 10;};     //correct
class UpToTheCompiler {
private:
  ??? cx;                          //int (but acts like int)
  …
};
```</p>

<p>For
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const int cx = 0;</span></code></pre></td></tr></table></div></figure></notextile></div>
type deduction for cx yields:</p>

<style>
table,th,td
{
border:1px solid black;
}
</style>

<table border="1" style="width:500px">
<tr>
<th> Context </th>
<th> Type </th>
</tr>

<tr>
<td> auto </td>
<td> int </td>
</tr>

<tr>
<td> decltype </td>
<td>  const int</td>
</tr>

<tr>
<td> template(T parameter)  </td>
<td> int </td>
</tr>

<tr>
<td> template(T&amp; parameter)  </td>
<td> const int </td>
</tr>

<tr>
<td> template(T&amp;&amp; parameter)  </td>
<td> const int&amp; </td>
</tr>

<tr>
<td> lambda (by-value capture) </td>
<td> const int  </td>
</tr>

<tr>
<td> lambda (int capture) </td>
<td>  int</td>
</tr>
</table>

<p>``` c++ Type Deduction
//all do the same thing
int x1 = 0;
int x2(0);
int x3 = {0};
int x4 {0};</p>

<p>auto x1 = 0;  // int
auto x2(0);   // int
auto x3 = {0};// initializer_list<int>
auto x4 {0};  // initializer_list<int /></int></p>

<p>template <typname t="">
void f(T param);
f({0});       // error! "{0}" has no type
```</typname></p>

<h2 id="inheritance">Inheritance</h2>
<p>``` c++ inheritance
class Base {
public:
  void doBaseWork();
};
class Derived : public Base {
public:
  void doDerivedWord() {
    doBaseWord();               //ok
  }
};</p>

<p>template <typename t="">
class Base {
public:
  void doBaseWork();
};
template <typename t="">
class Derived : public Base<t> {
public:
  void doDerivedWord() {
    doBaseWord();               //no compile, later specialized version
  }
};</t></typename></typename></p>

<p>template &lt;&gt;
class Base<int> ();  // no doBasework</int></p>

<p>Derived<int> d;
d.doDerivedWord();  // fail
```</int></p>

<p>In essence, the <strong>One Definition Rule</strong> states that the same entity should have the exact same definition throughout an application, otherwise the effects are undefined.</p>

<p>The fundamental problem is that the code that doesn’t see the specialized version of your class template member function might still compile, is likely to link, and sometimes might even run. This is because in the absence of (a forward declaration of) the explicit specialization, the non-specialized version kicks in, likely implementing a generic functionality that works for your specialized type as well.</p>

<h2 id="computational-complexity">Computational Complexity</h2>
<p>``` c++ computational Complexity
std::vector<int> v;
...
std::sort(v.begin(), v.end());   // O(nlogn)</int></p>

<p>std::list<int> li;
...
std::sort(li.begin(), li.end());  // not compile, list doesnot have random access iterator</int></p>

<p>auto it1 =
std::binary_search(v.begin(), v.end(), 10);  // O(logn)</p>

<p>auto it2 =
std::binary_search(li.begin(), li.end(), 10);  // O(n), officially(number of compares): O(logn)
```</p>

<h2 id="apis">APIs</h2>

<p><code>c++ example
std::set&lt;int&gt; si;
...
si.erase(14);    // eliminate all 14s from si
</code></p>

<ul>
  <li>set             –&gt;  erase</li>
  <li>multiset        –&gt;     erase</li>
  <li>map             –&gt;     erase</li>
  <li>multimap        –&gt;     erase</li>
  <li>unordered_set   –&gt;     erase</li>
  <li>unordered_multiset –&gt;  erase</li>
  <li>unordered_map      –&gt;  erase</li>
  <li>unordered_multimap –&gt;  erase</li>
  <li>list               –&gt;  remove</li>
  <li>forward_list       –&gt;  remove</li>
</ul>

<p>Sorts can be stable or unstable. Which are guaranteed to be stable?
* sort –&gt; not guaranteed
* stable_sort  –&gt; guaranteed
* list::sort –&gt; guaranteed</p>

<h2 id="specifications">Specifications</h2>
<p>Five sequence containers:</p>

<ul>
  <li>array –&gt; No</li>
  <li>deque –&gt; Yes</li>
  <li>forward_list  –&gt; No(fulfill of 1 of 16)</li>
  <li>list  –&gt; Yes</li>
  <li>vector – &gt; Yes</li>
</ul>

<h2 id="essential-and-accidental-complexity">Essential and Accidental Complexity</h2>
<p>Essential Complexity: due to inherent design tensions.</p>

<ul>
  <li>Simplicity and regularity vs expressiveness.</li>
  <li>Abstraction and portability vs efficiency.</li>
  <li>New approaches vs compatibility with legacy systems.</li>
  <li>Expressiveness vs ability to issue good diagnostics.</li>
</ul>

<p><em>Essential Complexity</em></p>

<p><code>c++ Point
struct Point {
  int x, y;
};
</code>
What is the type of Point::x?</p>

<p><code>c++ Point
Point p;
const Point &amp;cp = p;
</code>
What is the type of cp.x?</p>

<p>C++ soluction:</p>

<p><code>c++
decltype(cp.x) = int
decltype((cp.x)) = const int&amp;
</code></p>

<p><code>c++ inheritance
template &lt;typename T&gt;
class Base {
public:
  void doBaseWork();
};
template &lt;typename T&gt;
class Derived : public Base&lt;T&gt; {
public:
  void doDerivedWord() {
    doBaseWrd();               //okay?
  }
};
</code></p>

<p>Assume typo and diagnose now?</p>

<ul>
  <li>Wrong if later specialization offers doBaseWrk.</li>
</ul>

<p>Assume later specialization and defer lookup until instantiation?</p>

<ul>
  <li>If typo, imposes diagnostics for library errors on clients.</li>
</ul>

<p>C++ solution:</p>

<ul>
  <li>Template author has control
    <ul>
      <li>doBaseWrk() -&gt; lookup name when parsing template.</li>
      <li>this-&gt;doBaseWrk() -&gt; lookup name when instantiating template.</li>
    </ul>
  </li>
</ul>

<p><em>Accidental Complexity</em></p>

<ul>
  <li>ints are sometimes initialized to 0.</li>
  <li>By-value lambda capture somtimes retains the constness of what’s captured.</li>
  <li>mutable lambdas must declare a parameter list, but non-mutable lambdas don’t</li>
  <li>Braced initializers (e.g.”{0}”) sometimes have a type.</li>
  <li>Computation complexity guarantees usually meaningful.</li>
  <li>Elimination all container elements with a given value usually means
calling <code>erase</code>.</li>
  <li><code>sort</code> is sometimes stable.</li>
  <li>Container “requirements” are sometimes required.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式基本原则]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/05/设计模式基本原则</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 封装那些改变的</h2>
<div class="outline-text-2" id="text-1">
<p>
识别出应用里改变的方面，然后把它们从不变部分里分离出来封装。这样变化的部分就不会影响到不变的部分。那么，之后代码改变的话，只需要修改封装好的变化部分，不引起无意的修改，并提供更好的扩展灵活性。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 面向接口编程，而不是实现</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>由接口定义要实现的每个行为；
</li>
<li>只要依照接口定义好的编程实现；
</li>
<li>我们只需要知道接口是如何，根本不需要实现的细节而去使用这个接口派生的对象；
</li>
<li>在运行时才赋值具体的实现对象。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 使用组合优于继承</h2>
<div class="outline-text-2" id="text-3">
<p>
使用组合创建系统提高灵活性。不单单可以使你把一族的算法封装成它们各自的类，同时让你在运行时可以改变算法行为。
</p>

<p>
而继承，子类直接实现好算法的具体行为，不能在运行时改变算法的行为，同时过多的继承加剧类图的复杂度。
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 追求交互对象间的松耦合</h2>
<div class="outline-text-2" id="text-4">
<p>
当两个对象松耦合时，它们能交互，但互相了解很少。松耦合让我们建立能适应变化的灵活系统，因为它们最小化对象间的内部依赖。
</p>

<p>
松耦合对象A和B：
</p>
<ol class="org-ol">
<li>A和B只要知道对方的接口，就可以互相调用对方;
</li>
<li>我们可以独立复用A或B;
</li>
<li>改变A或B不会影响对方。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 类需要对扩展开放，对修改闭合(The Open-Closed Principle)</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>开放：自由添加任何新的行为来扩展类。
</li>
<li>闭合：现有的代码经过长时间的测试和修正，不允许别人修改现有代码。
</li>
</ol>

<p>
目的是允许类能容易的被扩展新的行为而不用修改现有的代码。为了达到这个目的，模式设计需要能弹性改变并足够灵活来对变化需求的新功能做出反应。
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 依赖于抽象类，而不是依赖具体类（The Dependency Inversion Principle)</h2>
<div class="outline-text-2" id="text-6">
<p>
与“面向接口编程，而不是实现“原则类似，然而依赖反转原则对于抽象接口更严格：
</p>

<ol class="org-ol">
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 得墨忒耳定律(Law of Demeter or Principle of Least Knowledge)</h2>
<div class="outline-text-2" id="text-7">
<p>
得墨忒耳定律是松耦合的一种具体案例:
</p>
<ol class="org-ol">
<li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
</li>
<li>每个单元只能和它的朋友交谈：不能和陌生单元交谈；
</li>
<li>只和自己直接的朋友交谈
</li>
</ol>

<p>
这个原理的名称来源于希腊神话中的农业女神，孤独的得墨忒耳。
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 好莱坞原则(Hollywood Principle)</h2>
<div class="outline-text-2" id="text-8">
<p>
总的概括就是：不要调用我们（高层次模块），我们会调用你（低层次模块）。
</p>

<p>
好莱坞原则提供一种防止依赖腐烂的方法。依赖腐烂发生当高层次模块依赖于低层次模块，低层次模块依赖于高层次模块，高层次模块又依赖于边际模块，边际模块依赖于低层次模块如此。当腐烂发生，没有人能轻易理解这个系统如何设计。
</p>

<p>
遵循好莱坞原则，允许低层次模块连入到系统中，但是由高层次模块决定什么时候它们被需要，和怎么使用它们。而不允许低层次的模块直接去调用一个高层次模块。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 单一功能原则（Single Responsibility Principle）</h2>
<div class="outline-text-2" id="text-9">
<p>
单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
</p>

<p>
也就是一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。
</p>

<p>
保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式附录一: 标识]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/05/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%99%84%E5%BD%95%E4%B8%80/"/>
    <updated>2014-05-05T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/05/浅谈设计模式附录一</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类图</h2>
<div class="outline-text-2" id="text-1">
<img src="/images/blog/2014/appendix/class_relationships.svg">

<ol class="org-ol">
<li>实例化
</li>
</ol>
<img src="/images/blog/2014/appendix/instantiate.jpeg">

<p>
CreateTool创建LineShape对象。
</p>

<!-- more -->

<ol class="org-ol">
<li>继承
</li>
</ol>
<img src="/images/blog/2014/appendix/subclass.jpeg">

<p>
类LineShape是继承父类Shape.
</p>

<ol class="org-ol">
<li>委托
</li>
</ol>
<img src="/images/blog/2014/appendix/delegation.jpeg">

<p>
委托是组合的一种方法，使组合具有继承的复用功能。LineShape保持Color对象的一个引用，当LineShape做一些Color的功能时，它不用从父类继承，它把功能委托给Color来完成。
</p>

<ol class="org-ol">
<li>聚合
</li>
</ol>
<img src="/images/blog/2014/appendix/aggregate.jpeg">

<p>
聚合意味这一个对象拥有另一个对象或对对另一个对象负责。同时意味这一个聚合对象和它的拥有者具有相同的生命周期。
</p>

<ol class="org-ol">
<li>注释
</li>
</ol>
<img src="/images/blog/2014/appendix/annotation.svg">

<p>
右边的框框表示对 <code>Draw()</code> 的注释。
</p>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十三: 访问者模式(Visitor)]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/04/浅谈设计模式23</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">实例</h2>
<div class="outline-text-2" id="text-1">
<p>
一辆汽车的结构是定的，但是对方不同部件的操作确实会时常变化，比如查看汽车各个部件，发动汽车对各个部件操作或修理部件等。那么如何在不改变汽车部件类的前提下，对其定义不同的操作呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">访问者模式(Visitor)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
表示在对象结构元素上进行的一个操作。访问者模式让你在不改变一个类的前提下，对这个类的元素定义新的操作。 
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
利用访问者设计模式，能很好的解决这个问题，一旦定义好汽车各个部件类，不用去修改它们，也能对它们定义新的操作。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/visitor">代码实例在这里</a>。
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">抽象元素类</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
定义一个以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">汽车具体元素类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
这里仅仅定义了汽车部分结构类为例子，分别定义汽车的轮胎类，引擎类和车身类。都实现以访问类为参数的 <code>Accept</code> 操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Wheel</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">explicit</span> <span style="color: #87cefa;">Wheel</span>(<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>);
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Wheel</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>() <span style="color: #00ffff;">const</span> {<span style="color: #00ffff;">return</span> name_;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name_</span>;
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Engine</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Engine</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};

<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Body</span> : <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Body</span>();
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">对象结构</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
整辆车的组合，能枚举它的各个部件，用 <code>vector</code> 维护一个无序的汽车元素集合。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Car</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #87cefa;">Car</span>();
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Car</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>);
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">CarElement</span> *&gt; <span style="color: #eedd82;">elements_array_</span>;
};

<span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">Car</span>() {
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front left"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Wheel</span>(<span style="color: #ffa07a;">"front right"</span>));
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Body</span>());
  elements_array_.push_back(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Engine</span>());
}

<span style="color: #7fffd4;">Car</span>::~<span style="color: #87cefa;">Car</span>() {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    <span style="color: #00ffff;">delete</span> element;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_car</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  visit_elements(visitor);
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">Car</span>::<span style="color: #87cefa;">visit_elements</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) {
  <span style="color: #00ffff;">for</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; elements_array_.size(); ++i) {
    <span style="color: #98fb98;">CarElement</span> *<span style="color: #eedd82;">element</span> = elements_array_[i];
    element-&gt;accept(visitor);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">抽象访问类</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
为结构中的具体元素类（ConcreteElement）类声明一个访问操作。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CarElement</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">CarElement</span>() {}
  <span style="color: #00ffff;">virtual</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">accept</span>(<span style="color: #98fb98;">CarElementVisitor</span> *<span style="color: #eedd82;">visitor</span>) = 0;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5">具体访问类1：访问汽车部件</h4>
<div class="outline-text-4" id="text-2-2-5">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementPrintVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Visiting body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6">具体访问类2：启动汽车部件</h4>
<div class="outline-text-4" id="text-2-2-6">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Wheel</span> *<span style="color: #eedd82;">wheel</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Kicking my "</span> &lt;&lt; wheel-&gt;name() &lt;&lt; <span style="color: #ffa07a;">" wheel"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Engine</span> *<span style="color: #eedd82;">engine</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Starting my engine"</span> &lt;&lt; endl;
}

<span style="color: #98fb98;">void</span> <span style="color: #7fffd4;">CarElementDoVisitor</span>::<span style="color: #87cefa;">visit</span>(<span style="color: #98fb98;">Body</span> *<span style="color: #eedd82;">body</span>) {
  cout &lt;&lt; <span style="color: #ffa07a;">"Moving my body"</span> &lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">访问者模式(Visitor)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="/images/blog/2014/visitor/visitor_structure.jpeg">
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>抽象访问类（Visitor）为结构中的具体元素类（ConcreteElement）类声明一个访问操作。这个操作的名字和签名标识了发送访问请求给访问类的类。以致能让访问者类决定正被访问元素的具体类。然后访问者类能直接通过它的特殊接口访问这个元素。
</li>
<li>具体访问类（ConcreteVisitor）实现抽象访问类声明的每个操作。每个操作实现部分的算法，而这些部分算法为相应的结构中对象类所定义。具体访问类（ConcreteVisitor）提供这算法的场景和存储它的本地状态。这一状态通常再遍历该结构的过程中积累结果。
</li>
<li>抽象元素类（Element）定义一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>具体元素类（ConcreteElement）实现一个以访问类为参数的 <code>Accept</code> 操作。
</li>
<li>对象结构(ObjectStrucutre)
<ol class="org-ol">
<li>能枚举它的元素。
</li>
<li>可以提供允许访问类访问它的元素的上层接口。
</li>
<li>可以是一个组合或一个如列表或无序集合的集合。
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象结构包含许多不同接口对象类，而且你想对这些对象进行一些依赖于它们具体类的操作。
</li>
<li>在一个对象结构中，需要对这些对象进行许多不相关不同的操作，而且你想避免以这些操作污染它们的类。访问者模式让你把相关的操作集中起来定义在一个类中。当这个对象结构被许多应用共享时，使用访问者模式让每个应用仅包含需要用到的操作。
</li>
<li>定义对象结构的类很少改变，但你时常想在这个结构上定义新的操作。改变对象结构类需要重定义对所有访问者类的结构，这潜在会是很大的开销。如果这些对象结构类经常改变，那么可能还是在这些类中定义这些操作。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>增加新的元素很困难。每增加一个新的元素将在抽象访问者类（Visitor)中增加一个新的抽象操作，并在每个具体访问类（ConcreteVisitor）中增加相应的操作。
</li>
<li>破坏封装性。访问者的方法假定具体元素类（ConcreteElement）接口足够强大让访问者对它元素进行操作。因而，这个模式强迫你提供能访问元素内部状态的公开操作，从而导致破坏了它的封装性。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈设计模式二十二: 备忘录模式(Memento)]]></title>
    <link href="http://dreamrunner.org/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F22/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://dreamrunner.org/blog/2014/05/04/浅谈设计模式22</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 实例</h2>
<div class="outline-text-2" id="text-1">
<p>
一个对象的状态必须被存储下来以便它之后能恢复到那个状态，并且一个直接获取状态的接口将暴露实现的细节并破坏对象的封装。 那么如何不用直接获取状态的情况下，实现状态的存储和恢复呢？
</p>

<!-- more -->
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 备忘录模式(Memento)</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
不破坏封装的前提下，采集和外部化对象的内部状态，以便这个对象能被恢复到这状态之后。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 实现</h3>
<div class="outline-text-3" id="text-2-2">
<p>
只有一个状态标识需要保存和恢复的简单发起类演示备忘录模式。<a href="https://github.com/shishougang/DesignPattern-CPP/tree/master/src/memento">代码实例在这里</a>。
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 需要保存和恢复状态的发起类</h4>
<div class="outline-text-4" id="text-2-2-1">
<ol class="org-ol">
<li><code>CreateMemento</code> ：创建一个包含它当前内部状态快照的备忘录类。
</li>
<li><code>SetMemento</code> ：使用备忘录类恢复它的内部状态。
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">T</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Originator</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Originator</span>() {}
  <span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt;* <span style="color: #87cefa;">CreateMemento</span>() {
    <span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt; *<span style="color: #eedd82;">m</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Memento</span>&lt;T&gt;();
    m-&gt;set_state(state_);
    <span style="color: #00ffff;">return</span> m;
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SetMemento</span>(<span style="color: #98fb98;">Memento</span>&lt;<span style="color: #98fb98;">T</span>&gt; *<span style="color: #eedd82;">m</span>) {
    state_ = m-&gt;state();
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_state</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">T</span> &amp;<span style="color: #eedd82;">state</span>) {state_ = state;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ShowState</span>() <span style="color: #00ffff;">const</span> {
    cout &lt;&lt; state_ &lt;&lt; endl;
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 备忘录类</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
保存和返回状态。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">template</span>&lt;<span style="color: #00ffff;">typename</span> <span style="color: #98fb98;">T</span>&gt;
<span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Memento</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Memento</span>() {}
  <span style="color: #98fb98;">T</span> <span style="color: #87cefa;">state</span>() <span style="color: #00ffff;">const</span> {<span style="color: #00ffff;">return</span> state_;}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_state</span>(<span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state</span>) {state_ = state;}
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">T</span> <span style="color: #eedd82;">state_</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 管理者</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
负责备忘录的保护。用 <code>vector</code> 存储备忘录类以便发起者恢复状态。
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Caretaker</span> {
 <span style="color: #00ffff;">public</span>:
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #87cefa;">Caretaker</span>() {}
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">SaveState</span>(<span style="color: #98fb98;">Originator</span>&lt;T&gt; *<span style="color: #eedd82;">orig</span>) {
    memento_array_.push_back(orig-&gt;CreateMemento());
  }
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">RestoreState</span>(<span style="color: #98fb98;">Originator</span>&lt;T&gt; *<span style="color: #eedd82;">orig</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state_number</span>) {
    orig-&gt;SetMemento(<span style="color: #98fb98;">memento_array_</span>[state_number]);
  }
 <span style="color: #00ffff;">private</span>:
  <span style="color: #98fb98;">vector</span>&lt;<span style="color: #98fb98;">Memento</span>&lt;T&gt; *&gt; <span style="color: #eedd82;">memento_array_</span>;
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 总结</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 备忘录模式(Memento)结构</h3>
<div class="outline-text-3" id="text-3-1">
<img src="/images/blog/2014/memento/memento_structure.jpeg">
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 组成</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>备忘录类（Memento）
<ol class="org-ol">
<li>存储发起者（Originator）对象的内部状态。根据它的发起者的判定，备忘录存储尽量多或尽量少的发起者的内部状态。
</li>
<li>防止发起者以外的对象访问。备忘录类实际有两个接口。管理者（Caretaker）拥有备忘录的窄接口——它只能把备忘录类传递给其他对象。发起者（Originator）相反拥有宽接口，让它访问所有必须的数据来自我恢复到之前状态。理想情况下，只有创建备忘录类的那个发起者才允许访问备忘录类的内部状态。
</li>
</ol>
</li>
<li>发起者（Originator）
<ol class="org-ol">
<li>创建一个包含它当前内部状态快照的备忘录类。
</li>
<li>使用备忘录类恢复它的内部状态。
</li>
</ol>
</li>
<li>管理者（Caretaker）
<ol class="org-ol">
<li>负责备忘录的保护。
</li>
<li>从不操作或检查备忘录类的内容。
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 应用场景</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>一个对象的（或部分）状态快照必须被存储下来以便它之后能恢复到那个状态，并且
</li>
<li>一个直接获取状态的接口将暴露实现的细节并且破坏对象的封装。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 缺点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>使用备忘录模式可能会开销很大。备忘录模式会导致很大的开销如果发起类必须在备忘录类你拷贝很大量的信息来恢复或如果客户过多的创建和返回备忘录给创建者。除非封装和恢复发起类状态的开销比较小，否则这个模式可能并不适合。
</li>
<li>定义窄和宽接口。在一些编程语言里确保只有发起类能访问备忘录类的状态可能比较困难。
</li>
<li>管理备忘录类的隐藏开销。一个管理者（caretaker）负责删除它管理的备忘录类。然而，这个管理者不清楚到底有多少的状态存储在备忘录里。因此一个轻量级管理者反而会引起大的存储开销当它存储备忘录时。
</li>
</ul>
</div>
</div>
</div>
]]></content>
  </entry>
  
</feed>
